/*! For license information please see app.js.LICENSE.txt */
(() => {
    var __webpack_modules__ = {
            862: function(t, e) {
                var n, i, r, a;

                function s(t) {
                    return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                        return typeof t
                    } : function(t) {
                        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                    })(t)
                }
                a = function(t) {
                    "use strict";
                    var e, n, i, r = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/,
                        a = /(?:\r|\n|\t\t)/g,
                        o = /(?:\s\s+)/g,
                        l = function(t) {
                            return n.getComputedStyle(t)
                        },
                        h = Array.isArray,
                        u = [].slice,
                        c = function(t, n) {
                            var i;
                            return h(t) ? t : "string" === (i = s(t)) && !n && t ? u.call(e.querySelectorAll(t), 0) : t && "object" === i && "length" in t ? u.call(t, 0) : t ? [t] : []
                        },
                        p = function(t) {
                            return "absolute" === t.position || !0 === t.absolute
                        },
                        f = function(t, e) {
                            for (var n, i = e.length; --i > -1;)
                                if (n = e[i], t.substr(0, n.length) === n) return n.length
                        },
                        d = function(t, e) {
                            void 0 === t && (t = "");
                            var n = ~t.indexOf("++"),
                                i = 1;
                            return n && (t = t.split("++").join("")),
                                function() {
                                    return "<" + e + " style='position:relative;display:inline-block;'" + (t ? " class='" + t + (n ? i++ : "") + "'>" : ">")
                                }
                        },
                        m = function t(e, n, i) {
                            var r = e.nodeType;
                            if (1 === r || 9 === r || 11 === r)
                                for (e = e.firstChild; e; e = e.nextSibling) t(e, n, i);
                            else 3 !== r && 4 !== r || (e.nodeValue = e.nodeValue.split(n).join(i))
                        },
                        g = function(t, e) {
                            for (var n = e.length; --n > -1;) t.push(e[n])
                        },
                        v = function(t, e, n) {
                            for (var i; t && t !== e;) {
                                if (i = t._next || t.nextSibling) return i.textContent.charAt(0) === n;
                                t = t.parentNode || t._parent
                            }
                        },
                        y = function t(e) {
                            var n, i, r = c(e.childNodes),
                                a = r.length;
                            for (n = 0; n < a; n++)(i = r[n])._isSplit ? t(i) : (n && 3 === i.previousSibling.nodeType ? i.previousSibling.nodeValue += 3 === i.nodeType ? i.nodeValue : i.firstChild.nodeValue : 3 !== i.nodeType && e.insertBefore(i.firstChild, i), e.removeChild(i))
                        },
                        _ = function(t, e) {
                            return parseFloat(e[t]) || 0
                        },
                        x = function(t, n, i, r, a, s, o) {
                            var h, u, c, f, d, x, b, E, w, D, S, M, T = l(t),
                                A = _("paddingLeft", T),
                                C = -999,
                                P = _("borderBottomWidth", T) + _("borderTopWidth", T),
                                F = _("borderLeftWidth", T) + _("borderRightWidth", T),
                                L = _("paddingTop", T) + _("paddingBottom", T),
                                R = _("paddingLeft", T) + _("paddingRight", T),
                                I = .2 * _("fontSize", T),
                                k = T.textAlign,
                                O = [],
                                N = [],
                                B = [],
                                z = n.wordDelimiter || " ",
                                V = n.tag ? n.tag : n.span ? "span" : "div",
                                U = n.type || n.split || "chars,words,lines",
                                G = a && ~U.indexOf("lines") ? [] : null,
                                H = ~U.indexOf("words"),
                                j = ~U.indexOf("chars"),
                                W = p(n),
                                X = n.linesClass,
                                q = ~(X || "").indexOf("++"),
                                Y = [];
                            for (q && (X = X.split("++").join("")), c = (u = t.getElementsByTagName("*")).length, d = [], h = 0; h < c; h++) d[h] = u[h];
                            if (G || W)
                                for (h = 0; h < c; h++)((x = (f = d[h]).parentNode === t) || W || j && !H) && (M = f.offsetTop, G && x && Math.abs(M - C) > I && ("BR" !== f.nodeName || 0 === h) && (b = [], G.push(b), C = M), W && (f._x = f.offsetLeft, f._y = M, f._w = f.offsetWidth, f._h = f.offsetHeight), G && ((f._isSplit && x || !j && x || H && x || !H && f.parentNode.parentNode === t && !f.parentNode._isSplit) && (b.push(f), f._x -= A, v(f, t, z) && (f._wordEnd = !0)), "BR" === f.nodeName && (f.nextSibling && "BR" === f.nextSibling.nodeName || 0 === h) && G.push([])));
                            for (h = 0; h < c; h++) x = (f = d[h]).parentNode === t, "BR" !== f.nodeName ? (W && (w = f.style, H || x || (f._x += f.parentNode._x, f._y += f.parentNode._y), w.left = f._x + "px", w.top = f._y + "px", w.position = "absolute", w.display = "block", w.width = f._w + 1 + "px", w.height = f._h + "px"), !H && j ? f._isSplit ? (f._next = f.nextSibling, f.parentNode.appendChild(f)) : f.parentNode._isSplit ? (f._parent = f.parentNode, !f.previousSibling && f.firstChild && (f.firstChild._isFirst = !0), f.nextSibling && " " === f.nextSibling.textContent && !f.nextSibling.nextSibling && Y.push(f.nextSibling), f._next = f.nextSibling && f.nextSibling._isFirst ? null : f.nextSibling, f.parentNode.removeChild(f), d.splice(h--, 1), c--) : x || (M = !f.nextSibling && v(f.parentNode, t, z), f.parentNode._parent && f.parentNode._parent.appendChild(f), M && f.parentNode.appendChild(e.createTextNode(" ")), "span" === V && (f.style.display = "inline"), O.push(f)) : f.parentNode._isSplit && !f._isSplit && "" !== f.innerHTML ? N.push(f) : j && !f._isSplit && ("span" === V && (f.style.display = "inline"), O.push(f))) : G || W ? (f.parentNode && f.parentNode.removeChild(f), d.splice(h--, 1), c--) : H || t.appendChild(f);
                            for (h = Y.length; --h > -1;) Y[h].parentNode.removeChild(Y[h]);
                            if (G) {
                                for (W && (D = e.createElement(V), t.appendChild(D), S = D.offsetWidth + "px", M = D.offsetParent === t ? 0 : t.offsetLeft, t.removeChild(D)), w = t.style.cssText, t.style.cssText = "display:none;"; t.firstChild;) t.removeChild(t.firstChild);
                                for (E = " " === z && (!W || !H && !j), h = 0; h < G.length; h++) {
                                    for (b = G[h], (D = e.createElement(V)).style.cssText = "display:block;text-align:" + k + ";position:" + (W ? "absolute;" : "relative;"), X && (D.className = X + (q ? h + 1 : "")), B.push(D), c = b.length, u = 0; u < c; u++) "BR" !== b[u].nodeName && (f = b[u], D.appendChild(f), E && f._wordEnd && D.appendChild(e.createTextNode(" ")), W && (0 === u && (D.style.top = f._y + "px", D.style.left = A + M + "px"), f.style.top = "0px", M && (f.style.left = f._x - M + "px")));
                                    0 === c ? D.innerHTML = "&nbsp;" : H || j || (y(D), m(D, String.fromCharCode(160), " ")), W && (D.style.width = S, D.style.height = f._h + "px"), t.appendChild(D)
                                }
                                t.style.cssText = w
                            }
                            W && (o > t.clientHeight && (t.style.height = o - L + "px", t.clientHeight < o && (t.style.height = o + P + "px")), s > t.clientWidth && (t.style.width = s - R + "px", t.clientWidth < s && (t.style.width = s + F + "px"))), g(i, O), H && g(r, N), g(a, B)
                        },
                        b = function(t, n, i, s) {
                            var l, h, u, c, d, g, v, y, _ = n.tag ? n.tag : n.span ? "span" : "div",
                                x = ~(n.type || n.split || "chars,words,lines").indexOf("chars"),
                                b = p(n),
                                E = n.wordDelimiter || " ",
                                w = " " !== E ? "" : b ? "&#173; " : " ",
                                D = "</" + _ + ">",
                                S = 1,
                                M = n.specialChars ? "function" == typeof n.specialChars ? n.specialChars : f : null,
                                T = e.createElement("div"),
                                A = t.parentNode;
                            for (A.insertBefore(T, t), T.textContent = t.nodeValue, A.removeChild(t), v = -1 !== (l = function t(e) {
                                    var n = e.nodeType,
                                        i = "";
                                    if (1 === n || 9 === n || 11 === n) {
                                        if ("string" == typeof e.textContent) return e.textContent;
                                        for (e = e.firstChild; e; e = e.nextSibling) i += t(e)
                                    } else if (3 === n || 4 === n) return e.nodeValue;
                                    return i
                                }(t = T)).indexOf("<"), !1 !== n.reduceWhiteSpace && (l = l.replace(o, " ").replace(a, "")), v && (l = l.split("<").join("{{LT}}")), d = l.length, h = (" " === l.charAt(0) ? w : "") + i(), u = 0; u < d; u++)
                                if (g = l.charAt(u), M && (y = M(l.substr(u), n.specialChars))) g = l.substr(u, y || 1), h += x && " " !== g ? s() + g + "</" + _ + ">" : g, u += y - 1;
                                else if (g === E && l.charAt(u - 1) !== E && u) {
                                for (h += S ? D : "", S = 0; l.charAt(u + 1) === E;) h += w, u++;
                                u === d - 1 ? h += w : ")" !== l.charAt(u + 1) && (h += w + i(), S = 1)
                            } else "{" === g && "{{LT}}" === l.substr(u, 6) ? (h += x ? s() + "{{LT}}</" + _ + ">" : "{{LT}}", u += 5) : g.charCodeAt(0) >= 55296 && g.charCodeAt(0) <= 56319 || l.charCodeAt(u + 1) >= 65024 && l.charCodeAt(u + 1) <= 65039 ? (c = ((l.substr(u, 12).split(r) || [])[1] || "").length || 2, h += x && " " !== g ? s() + l.substr(u, c) + "</" + _ + ">" : l.substr(u, c), u += c - 1) : h += x && " " !== g ? s() + g + "</" + _ + ">" : g;
                            t.outerHTML = h + (S ? D : ""), v && m(A, "{{LT}}", "<")
                        },
                        E = function t(e, n, i, r) {
                            var a, s, o = c(e.childNodes),
                                h = o.length,
                                u = p(n);
                            if (3 !== e.nodeType || h > 1) {
                                for (n.absolute = !1, a = 0; a < h; a++)(3 !== (s = o[a]).nodeType || /\S+/.test(s.nodeValue)) && (u && 3 !== s.nodeType && "inline" === l(s).display && (s.style.display = "inline-block", s.style.position = "relative"), s._isSplit = !0, t(s, n, i, r));
                                return n.absolute = u, void(e._isSplit = !0)
                            }
                            b(e, n, i, r)
                        },
                        w = function() {
                            function t(t, r) {
                                i || (e = document, n = window, i = 1), this.elements = c(t), this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = r || {}, this.split(r)
                            }
                            var r = t.prototype;
                            return r.split = function(t) {
                                this.isSplit && this.revert(), this.vars = t = t || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
                                for (var e, n, i, r = this.elements.length, a = t.tag ? t.tag : t.span ? "span" : "div", s = d(t.wordsClass, a), o = d(t.charsClass, a); --r > -1;) i = this.elements[r], this._originals[r] = i.innerHTML, e = i.clientHeight, n = i.clientWidth, E(i, t, s, o), x(i, t, this.chars, this.words, this.lines, n, e);
                                return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this
                            }, r.revert = function() {
                                var t = this._originals;
                                if (!t) throw "revert() call wasn't scoped properly.";
                                return this.elements.forEach((function(e, n) {
                                    return e.innerHTML = t[n]
                                })), this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this
                            }, t.create = function(e, n) {
                                return new t(e, n)
                            }, t
                        }();
                    w.version = "3.0.0", t.SplitText = w, t.default = w, Object.defineProperty(t, "__esModule", {
                        value: !0
                    })
                }, "object" === s(e) ? a(e) : (i = [e], void 0 === (r = "function" == typeof(n = a) ? n.apply(e, i) : n) || (t.exports = r))
            },
            913: () => {
                function t(t) {
                    var a = t.card,
                        s = t.isPaymentRetry,
                        o = t.invoiceId,
                        l = t.customerId,
                        h = t.stripe,
                        u = t.priceId,
                        c = document.querySelector("#name").value;
                    return h.createPaymentMethod({
                        type: "card",
                        card: a,
                        billing_details: {
                            name: c
                        }
                    }).then((function(t) {
                        if (!t.error) return s ? function(t) {
                            var i = t.customerId,
                                a = t.paymentMethodId,
                                s = t.invoiceId,
                                o = t.priceId,
                                l = t.stripe;
                            return fetch("/.netlify/functions/retryInvoice", {
                                method: "post",
                                headers: {
                                    "Content-type": "application/json"
                                },
                                body: JSON.stringify({
                                    customerId: i,
                                    paymentMethodId: a,
                                    invoiceId: s
                                })
                            }).then((function(t) {
                                return t.json()
                            }), display).then((function(t) {
                                if (t.error) throw t;
                                return t
                            }), e).then((function(t) {
                                return {
                                    invoice: t,
                                    paymentMethodId: a,
                                    priceId: o,
                                    isRetry: !0,
                                    stripe: l
                                }
                            }), e).then(n, e).then(r, e)
                        }({
                            customerId: l,
                            paymentMethodId: t.paymentMethod.id,
                            invoiceId: o,
                            priceId: u,
                            stripe: h
                        }) : function(t) {
                            var a = t.customerId,
                                s = t.paymentMethodId,
                                o = t.priceId,
                                l = t.stripe;
                            return fetch("/.netlify/functions/createSubscription", {
                                method: "post",
                                headers: {
                                    "Content-type": "application/json"
                                },
                                body: JSON.stringify({
                                    customerId: a,
                                    paymentMethodId: s,
                                    priceId: o
                                })
                            }).catch(e).then((function(t) {
                                return t.json()
                            }), e).then((function(t) {
                                if (t.error) throw t.error;
                                return t
                            }), e).then((function(t) {
                                return {
                                    paymentMethodId: s,
                                    priceId: o,
                                    subscription: t,
                                    stripe: l
                                }
                            }), e).then(n, e).then(i, e).then(r, e).catch(e)
                        }({
                            stripe: h,
                            customerId: l,
                            paymentMethodId: t.paymentMethod.id,
                            priceId: u
                        });
                        e(t.error)
                    }), e)
                }

                function e(t) {
                    throw console.log("error:", t), document.querySelector("#submitSpinner").style.display = "none",
                        function(t) {
                            document.querySelector("#error_msg").innerHTML = t.message
                        }(t), t
                }

                function n(t) {
                    var n = t.subscription,
                        i = t.invoice,
                        r = t.priceId,
                        a = t.paymentMethodId,
                        s = t.isRetry,
                        o = t.stripe;
                    if (n && "active" === n.status) return {
                        subscription: n,
                        priceId: r,
                        paymentMethodId: a,
                        stripe: o
                    };
                    var l = i ? i.payment_intent : n.latest_invoice.payment_intent;
                    return "requires_action" === l.status || !0 === s && "requires_payment_method" === l.status ? o.confirmCardPayment(l.client_secret, {
                        payment_method: a
                    }).then((function(t) {
                        return t.error ? Promise.reject(t.error) : "succeeded" === t.paymentIntent.status ? {
                            priceId: r,
                            subscription: n,
                            invoice: i,
                            paymentMethodId: a,
                            stripe: o
                        } : void 0
                    }), e) : {
                        subscription: n,
                        priceId: r,
                        paymentMethodId: a,
                        stripe: o,
                        invoice: i
                    }
                }

                function i(t) {
                    var e = t.subscription,
                        n = t.paymentMethodId,
                        i = t.priceId,
                        r = t.stripe;
                    if ("active" === e.status) return {
                        subscription: e,
                        priceId: i,
                        paymentMethodId: n,
                        stripe: r
                    };
                    if ("requires_payment_method" === e.latest_invoice.payment_intent.status) throw localStorage.setItem("latestInvoiceId", e.latest_invoice.id), localStorage.setItem("latestInvoicePaymentIntentStatus", e.latest_invoice.payment_intent.status), {
                        message: "Your card was declined."
                    };
                    return {
                        subscription: e,
                        priceId: i,
                        paymentMethodId: n,
                        stripe: r
                    }
                }

                function r(t) {
                    document.querySelector("#submitSpinner").style.display = "none";
                    var e = t.subscription && t.subscription.latest_invoice ? t.subscription.latest_invoice.hosted_invoice_url : t.invoice ? t.invoice.hosted_invoice_url : null;
                    e && window.location.replace(e)
                }
                // document.addEventListener("DOMContentLoaded", (function(e) {
                //     fetch("/.netlify/functions/config").then((function(t) {
                //         return t.json()
                //     })).then((function(e) {
                //         window.config = e;
                //         var n = Stripe(config.publicKey),
                //             i = n.elements(),
                //             r = {
                //                 base: {
                //                     color: "#32325d",
                //                     fontFamily: '"Helvetica Neue", Helvetica, sans-serif',
                //                     fontSmoothing: "antialiased",
                //                     fontSize: "16px",
                //                     "::placeholder": {
                //                         color: "#aab7c4"
                //                     }
                //                 },
                //                 invalid: {
                //                     color: "#fa755a",
                //                     iconColor: "#fa755a"
                //                 }
                //             },
                //             a = i.create("cardNumber", {
                //                 style: r,
                //                 icon: "solid",
                //                 showIcon: !0
                //             });
                //         a.mount("#credit_card_number"), i.create("cardExpiry", {
                //             style: r
                //         }).mount("#credit_card_expiry"), i.create("cardCvc", {
                //             style: r
                //         }).mount("#credit_card_cvc");
                //         var s = localStorage.getItem("latestInvoicePaymentIntentStatus"),
                //             o = document.querySelector("#submitSpinner");
                //         localStorage.getItem("latestInvoiceId");
                //         paymentButton = document.querySelector("#paymentRequestButton");
                //         var l = document.querySelector("#payment-form"),
                //             h = document.getElementById("price_id").value;
                //         l.addEventListener("submit", (function(e) {
                //             var i, r;
                //             document.querySelector("#error_msg").innerHTML = "", o.style.display = "block", e.preventDefault(), (i = document.querySelector("#email").value, r = document.querySelector("#name").value, fetch("/.netlify/functions/createCustomer", {
                //                 method: "post",
                //                 headers: {
                //                     "Content-Type": "application/json"
                //                 },
                //                 body: JSON.stringify({
                //                     email: i,
                //                     name: r
                //                 })
                //             }).then((function(t) {
                //                 return t.json()
                //             })).then((function(t) {
                //                 return t
                //             }))).then((function(e) {
                //                 var i = e.id;
                //                 if ("requires_payment_method" === s) {
                //                     var r = localStorage.getItem("latestInvoiceId");
                //                     t({
                //                         card: a,
                //                         isPaymentRetry: !0,
                //                         invoiceId: r,
                //                         customerId: i,
                //                         stripe: n,
                //                         priceId: h
                //                     }).then((function() {
                //                         o.style.display = "none"
                //                     })).catch((function(t) {
                //                         o.style.display = "none"
                //                     }))
                //                 } else t({
                //                     card: a,
                //                     customerId: i,
                //                     stripe: n,
                //                     priceId: h
                //                 }).then((function() {
                //                     o.style.display = "none"
                //                 })).catch((function(t) {
                //                     o.style.display = "none"
                //                 }))
                //             }))
                //         }))
                //     }))
                // }))
            },
            763: t => {
                "use strict";
                t.exports = function(t) {
                    if ("string" != typeof t) throw new TypeError("expected a string");
                    return (t = (t = (t = t.replace(/([a-z])([A-Z])/g, "$1-$2")).replace(/[ \t\W]/g, "-")).replace(/^-+|-+$/g, "")).toLowerCase()
                }
            },
            827: () => {
                ! function() {
                    "use strict";
                    if ("object" == typeof window)
                        if ("IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype) "isIntersecting" in window.IntersectionObserverEntry.prototype || Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", {
                            get: function() {
                                return this.intersectionRatio > 0
                            }
                        });
                        else {
                            var t = window.document,
                                e = [],
                                n = null,
                                i = null;
                            a.prototype.THROTTLE_TIMEOUT = 100, a.prototype.POLL_INTERVAL = null, a.prototype.USE_MUTATION_OBSERVER = !0, a._setupCrossOriginUpdater = function() {
                                return n || (n = function(t, n) {
                                    i = t && n ? u(t, n) : {
                                        top: 0,
                                        bottom: 0,
                                        left: 0,
                                        right: 0,
                                        width: 0,
                                        height: 0
                                    }, e.forEach((function(t) {
                                        t._checkForIntersections()
                                    }))
                                }), n
                            }, a._resetCrossOriginUpdater = function() {
                                n = null, i = null
                            }, a.prototype.observe = function(t) {
                                if (!this._observationTargets.some((function(e) {
                                        return e.element == t
                                    }))) {
                                    if (!t || 1 != t.nodeType) throw new Error("target must be an Element");
                                    this._registerInstance(), this._observationTargets.push({
                                        element: t,
                                        entry: null
                                    }), this._monitorIntersections(t.ownerDocument), this._checkForIntersections()
                                }
                            }, a.prototype.unobserve = function(t) {
                                this._observationTargets = this._observationTargets.filter((function(e) {
                                    return e.element != t
                                })), this._unmonitorIntersections(t.ownerDocument), 0 == this._observationTargets.length && this._unregisterInstance()
                            }, a.prototype.disconnect = function() {
                                this._observationTargets = [], this._unmonitorAllIntersections(), this._unregisterInstance()
                            }, a.prototype.takeRecords = function() {
                                var t = this._queuedEntries.slice();
                                return this._queuedEntries = [], t
                            }, a.prototype._initThresholds = function(t) {
                                var e = t || [0];
                                return Array.isArray(e) || (e = [e]), e.sort().filter((function(t, e, n) {
                                    if ("number" != typeof t || isNaN(t) || t < 0 || t > 1) throw new Error("threshold must be a number between 0 and 1 inclusively");
                                    return t !== n[e - 1]
                                }))
                            }, a.prototype._parseRootMargin = function(t) {
                                var e = (t || "0px").split(/\s+/).map((function(t) {
                                    var e = /^(-?\d*\.?\d+)(px|%)$/.exec(t);
                                    if (!e) throw new Error("rootMargin must be specified in pixels or percent");
                                    return {
                                        value: parseFloat(e[1]),
                                        unit: e[2]
                                    }
                                }));
                                return e[1] = e[1] || e[0], e[2] = e[2] || e[0], e[3] = e[3] || e[1], e
                            }, a.prototype._monitorIntersections = function(e) {
                                var n = e.defaultView;
                                if (n && -1 == this._monitoringDocuments.indexOf(e)) {
                                    var i = this._checkForIntersections,
                                        r = null,
                                        a = null;
                                    if (this.POLL_INTERVAL ? r = n.setInterval(i, this.POLL_INTERVAL) : (s(n, "resize", i, !0), s(e, "scroll", i, !0), this.USE_MUTATION_OBSERVER && "MutationObserver" in n && (a = new n.MutationObserver(i)).observe(e, {
                                            attributes: !0,
                                            childList: !0,
                                            characterData: !0,
                                            subtree: !0
                                        })), this._monitoringDocuments.push(e), this._monitoringUnsubscribes.push((function() {
                                            var t = e.defaultView;
                                            t && (r && t.clearInterval(r), o(t, "resize", i, !0)), o(e, "scroll", i, !0), a && a.disconnect()
                                        })), e != (this.root && this.root.ownerDocument || t)) {
                                        var l = f(e);
                                        l && this._monitorIntersections(l.ownerDocument)
                                    }
                                }
                            }, a.prototype._unmonitorIntersections = function(e) {
                                var n = this._monitoringDocuments.indexOf(e);
                                if (-1 != n) {
                                    var i = this.root && this.root.ownerDocument || t;
                                    if (!this._observationTargets.some((function(t) {
                                            var n = t.element.ownerDocument;
                                            if (n == e) return !0;
                                            for (; n && n != i;) {
                                                var r = f(n);
                                                if ((n = r && r.ownerDocument) == e) return !0
                                            }
                                            return !1
                                        }))) {
                                        var r = this._monitoringUnsubscribes[n];
                                        if (this._monitoringDocuments.splice(n, 1), this._monitoringUnsubscribes.splice(n, 1), r(), e != i) {
                                            var a = f(e);
                                            a && this._unmonitorIntersections(a.ownerDocument)
                                        }
                                    }
                                }
                            }, a.prototype._unmonitorAllIntersections = function() {
                                var t = this._monitoringUnsubscribes.slice(0);
                                this._monitoringDocuments.length = 0, this._monitoringUnsubscribes.length = 0;
                                for (var e = 0; e < t.length; e++) t[e]()
                            }, a.prototype._checkForIntersections = function() {
                                if (this.root || !n || i) {
                                    var t = this._rootIsInDom(),
                                        e = t ? this._getRootRect() : {
                                            top: 0,
                                            bottom: 0,
                                            left: 0,
                                            right: 0,
                                            width: 0,
                                            height: 0
                                        };
                                    this._observationTargets.forEach((function(i) {
                                        var a = i.element,
                                            s = l(a),
                                            o = this._rootContainsTarget(a),
                                            h = i.entry,
                                            u = t && o && this._computeTargetAndRootIntersection(a, s, e),
                                            c = i.entry = new r({
                                                time: window.performance && performance.now && performance.now(),
                                                target: a,
                                                boundingClientRect: s,
                                                rootBounds: n && !this.root ? null : e,
                                                intersectionRect: u
                                            });
                                        h ? t && o ? this._hasCrossedThreshold(h, c) && this._queuedEntries.push(c) : h && h.isIntersecting && this._queuedEntries.push(c) : this._queuedEntries.push(c)
                                    }), this), this._queuedEntries.length && this._callback(this.takeRecords(), this)
                                }
                            }, a.prototype._computeTargetAndRootIntersection = function(e, r, a) {
                                if ("none" != window.getComputedStyle(e).display) {
                                    for (var s, o, h, c, f, d, m, g, v = r, y = p(e), _ = !1; !_ && y;) {
                                        var x = null,
                                            b = 1 == y.nodeType ? window.getComputedStyle(y) : {};
                                        if ("none" == b.display) return null;
                                        if (y == this.root || 9 == y.nodeType)
                                            if (_ = !0, y == this.root || y == t) n && !this.root ? !i || 0 == i.width && 0 == i.height ? (y = null, x = null, v = null) : x = i : x = a;
                                            else {
                                                var E = p(y),
                                                    w = E && l(E),
                                                    D = E && this._computeTargetAndRootIntersection(E, w, a);
                                                w && D ? (y = E, x = u(w, D)) : (y = null, v = null)
                                            }
                                        else {
                                            var S = y.ownerDocument;
                                            y != S.body && y != S.documentElement && "visible" != b.overflow && (x = l(y))
                                        }
                                        if (x && (s = x, o = v, h = void 0, c = void 0, f = void 0, d = void 0, m = void 0, g = void 0, h = Math.max(s.top, o.top), c = Math.min(s.bottom, o.bottom), f = Math.max(s.left, o.left), d = Math.min(s.right, o.right), g = c - h, v = (m = d - f) >= 0 && g >= 0 && {
                                                top: h,
                                                bottom: c,
                                                left: f,
                                                right: d,
                                                width: m,
                                                height: g
                                            } || null), !v) break;
                                        y = y && p(y)
                                    }
                                    return v
                                }
                            }, a.prototype._getRootRect = function() {
                                var e;
                                if (this.root) e = l(this.root);
                                else {
                                    var n = t.documentElement,
                                        i = t.body;
                                    e = {
                                        top: 0,
                                        left: 0,
                                        right: n.clientWidth || i.clientWidth,
                                        width: n.clientWidth || i.clientWidth,
                                        bottom: n.clientHeight || i.clientHeight,
                                        height: n.clientHeight || i.clientHeight
                                    }
                                }
                                return this._expandRectByRootMargin(e)
                            }, a.prototype._expandRectByRootMargin = function(t) {
                                var e = this._rootMarginValues.map((function(e, n) {
                                        return "px" == e.unit ? e.value : e.value * (n % 2 ? t.width : t.height) / 100
                                    })),
                                    n = {
                                        top: t.top - e[0],
                                        right: t.right + e[1],
                                        bottom: t.bottom + e[2],
                                        left: t.left - e[3]
                                    };
                                return n.width = n.right - n.left, n.height = n.bottom - n.top, n
                            }, a.prototype._hasCrossedThreshold = function(t, e) {
                                var n = t && t.isIntersecting ? t.intersectionRatio || 0 : -1,
                                    i = e.isIntersecting ? e.intersectionRatio || 0 : -1;
                                if (n !== i)
                                    for (var r = 0; r < this.thresholds.length; r++) {
                                        var a = this.thresholds[r];
                                        if (a == n || a == i || a < n != a < i) return !0
                                    }
                            }, a.prototype._rootIsInDom = function() {
                                return !this.root || c(t, this.root)
                            }, a.prototype._rootContainsTarget = function(e) {
                                return c(this.root || t, e) && (!this.root || this.root.ownerDocument == e.ownerDocument)
                            }, a.prototype._registerInstance = function() {
                                e.indexOf(this) < 0 && e.push(this)
                            }, a.prototype._unregisterInstance = function() {
                                var t = e.indexOf(this); - 1 != t && e.splice(t, 1)
                            }, window.IntersectionObserver = a, window.IntersectionObserverEntry = r
                        }
                    function r(t) {
                        this.time = t.time, this.target = t.target, this.rootBounds = h(t.rootBounds), this.boundingClientRect = h(t.boundingClientRect), this.intersectionRect = h(t.intersectionRect || {
                            top: 0,
                            bottom: 0,
                            left: 0,
                            right: 0,
                            width: 0,
                            height: 0
                        }), this.isIntersecting = !!t.intersectionRect;
                        var e = this.boundingClientRect,
                            n = e.width * e.height,
                            i = this.intersectionRect,
                            r = i.width * i.height;
                        this.intersectionRatio = n ? Number((r / n).toFixed(4)) : this.isIntersecting ? 1 : 0
                    }

                    function a(t, e) {
                        var n, i, r, a = e || {};
                        if ("function" != typeof t) throw new Error("callback must be a function");
                        if (a.root && 1 != a.root.nodeType) throw new Error("root must be an Element");
                        this._checkForIntersections = (n = this._checkForIntersections.bind(this), i = this.THROTTLE_TIMEOUT, r = null, function() {
                            r || (r = setTimeout((function() {
                                n(), r = null
                            }), i))
                        }), this._callback = t, this._observationTargets = [], this._queuedEntries = [], this._rootMarginValues = this._parseRootMargin(a.rootMargin), this.thresholds = this._initThresholds(a.threshold), this.root = a.root || null, this.rootMargin = this._rootMarginValues.map((function(t) {
                            return t.value + t.unit
                        })).join(" "), this._monitoringDocuments = [], this._monitoringUnsubscribes = []
                    }

                    function s(t, e, n, i) {
                        "function" == typeof t.addEventListener ? t.addEventListener(e, n, i || !1) : "function" == typeof t.attachEvent && t.attachEvent("on" + e, n)
                    }

                    function o(t, e, n, i) {
                        "function" == typeof t.removeEventListener ? t.removeEventListener(e, n, i || !1) : "function" == typeof t.detatchEvent && t.detatchEvent("on" + e, n)
                    }

                    function l(t) {
                        var e;
                        try {
                            e = t.getBoundingClientRect()
                        } catch (t) {}
                        return e ? (e.width && e.height || (e = {
                            top: e.top,
                            right: e.right,
                            bottom: e.bottom,
                            left: e.left,
                            width: e.right - e.left,
                            height: e.bottom - e.top
                        }), e) : {
                            top: 0,
                            bottom: 0,
                            left: 0,
                            right: 0,
                            width: 0,
                            height: 0
                        }
                    }

                    function h(t) {
                        return !t || "x" in t ? t : {
                            top: t.top,
                            y: t.top,
                            bottom: t.bottom,
                            left: t.left,
                            x: t.left,
                            right: t.right,
                            width: t.width,
                            height: t.height
                        }
                    }

                    function u(t, e) {
                        var n = e.top - t.top,
                            i = e.left - t.left;
                        return {
                            top: n,
                            left: i,
                            height: e.height,
                            width: e.width,
                            bottom: n + e.height,
                            right: i + e.width
                        }
                    }

                    function c(t, e) {
                        for (var n = e; n;) {
                            if (n == t) return !0;
                            n = p(n)
                        }
                        return !1
                    }

                    function p(e) {
                        var n = e.parentNode;
                        return 9 == e.nodeType && e != t ? f(e) : n && 11 == n.nodeType && n.host ? n.host : n && n.assignedSlot ? n.assignedSlot.parentNode : n
                    }

                    function f(t) {
                        try {
                            return t.defaultView && t.defaultView.frameElement || null
                        } catch (t) {
                            return null
                        }
                    }
                }()
            },
            198: (t, e, n) => {
                var i = /^\s+|\s+$/g,
                    r = /^[-+]0x[0-9a-f]+$/i,
                    a = /^0b[01]+$/i,
                    s = /^0o[0-7]+$/i,
                    o = parseInt,
                    l = "object" == typeof n.g && n.g && n.g.Object === Object && n.g,
                    h = "object" == typeof self && self && self.Object === Object && self,
                    u = l || h || Function("return this")(),
                    c = Object.prototype.toString,
                    p = Math.max,
                    f = Math.min,
                    d = function() {
                        return u.Date.now()
                    };

                function m(t) {
                    var e = typeof t;
                    return !!t && ("object" == e || "function" == e)
                }

                function g(t) {
                    if ("number" == typeof t) return t;
                    if (function(t) {
                            return "symbol" == typeof t || function(t) {
                                return !!t && "object" == typeof t
                            }(t) && "[object Symbol]" == c.call(t)
                        }(t)) return NaN;
                    if (m(t)) {
                        var e = "function" == typeof t.valueOf ? t.valueOf() : t;
                        t = m(e) ? e + "" : e
                    }
                    if ("string" != typeof t) return 0 === t ? t : +t;
                    t = t.replace(i, "");
                    var n = a.test(t);
                    return n || s.test(t) ? o(t.slice(2), n ? 2 : 8) : r.test(t) ? NaN : +t
                }
                t.exports = function(t, e, n) {
                    var i, r, a, s, o, l, h = 0,
                        u = !1,
                        c = !1,
                        v = !0;
                    if ("function" != typeof t) throw new TypeError("Expected a function");

                    function y(e) {
                        var n = i,
                            a = r;
                        return i = r = void 0, h = e, s = t.apply(a, n)
                    }

                    function _(t) {
                        return h = t, o = setTimeout(b, e), u ? y(t) : s
                    }

                    function x(t) {
                        var n = t - l;
                        return void 0 === l || n >= e || n < 0 || c && t - h >= a
                    }

                    function b() {
                        var t = d();
                        if (x(t)) return E(t);
                        o = setTimeout(b, function(t) {
                            var n = e - (t - l);
                            return c ? f(n, a - (t - h)) : n
                        }(t))
                    }

                    function E(t) {
                        return o = void 0, v && i ? y(t) : (i = r = void 0, s)
                    }

                    function w() {
                        var t = d(),
                            n = x(t);
                        if (i = arguments, r = this, l = t, n) {
                            if (void 0 === o) return _(l);
                            if (c) return o = setTimeout(b, e), y(l)
                        }
                        return void 0 === o && (o = setTimeout(b, e)), s
                    }
                    return e = g(e) || 0, m(n) && (u = !!n.leading, a = (c = "maxWait" in n) ? p(g(n.maxWait) || 0, e) : a, v = "trailing" in n ? !!n.trailing : v), w.cancel = function() {
                        void 0 !== o && clearTimeout(o), h = 0, i = l = r = o = void 0
                    }, w.flush = function() {
                        return void 0 === o ? s : E(d())
                    }, w
                }
            },
            809: (module, exports, __webpack_require__) => {
                var __WEBPACK_AMD_DEFINE_RESULT__;
                "undefined" != typeof navigator && function(t, e) {
                    void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                        return e(t)
                    }.call(exports, __webpack_require__, exports, module)) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)
                }(window || {}, (function(window) {
                    "use strict";
                    var svgNS = "http://www.w3.org/2000/svg",
                        locationHref = "",
                        initialDefaultFrame = -999999,
                        subframeEnabled = !0,
                        expressionsPlugin, isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
                        cachedColors = {},
                        bm_rounder = Math.round,
                        bm_rnd, bm_pow = Math.pow,
                        bm_sqrt = Math.sqrt,
                        bm_abs = Math.abs,
                        bm_floor = Math.floor,
                        bm_max = Math.max,
                        bm_min = Math.min,
                        blitter = 10,
                        BMMath = {};

                    function ProjectInterface() {
                        return {}
                    }! function() {
                        var t, e = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"],
                            n = e.length;
                        for (t = 0; t < n; t += 1) BMMath[e[t]] = Math[e[t]]
                    }(), BMMath.random = Math.random, BMMath.abs = function(t) {
                        if ("object" === typeof t && t.length) {
                            var e, n = createSizedArray(t.length),
                                i = t.length;
                            for (e = 0; e < i; e += 1) n[e] = Math.abs(t[e]);
                            return n
                        }
                        return Math.abs(t)
                    };
                    var defaultCurveSegments = 150,
                        degToRads = Math.PI / 180,
                        roundCorner = .5519;

                    function roundValues(t) {
                        bm_rnd = t ? Math.round : function(t) {
                            return t
                        }
                    }

                    function styleDiv(t) {
                        t.style.position = "absolute", t.style.top = 0, t.style.left = 0, t.style.display = "block", t.style.transformOrigin = t.style.webkitTransformOrigin = "0 0", t.style.backfaceVisibility = t.style.webkitBackfaceVisibility = "visible", t.style.transformStyle = t.style.webkitTransformStyle = t.style.mozTransformStyle = "preserve-3d"
                    }

                    function BMEnterFrameEvent(t, e, n, i) {
                        this.type = t, this.currentTime = e, this.totalTime = n, this.direction = i < 0 ? -1 : 1
                    }

                    function BMCompleteEvent(t, e) {
                        this.type = t, this.direction = e < 0 ? -1 : 1
                    }

                    function BMCompleteLoopEvent(t, e, n, i) {
                        this.type = t, this.currentLoop = n, this.totalLoops = e, this.direction = i < 0 ? -1 : 1
                    }

                    function BMSegmentStartEvent(t, e, n) {
                        this.type = t, this.firstFrame = e, this.totalFrames = n
                    }

                    function BMDestroyEvent(t, e) {
                        this.type = t, this.target = e
                    }

                    function BMRenderFrameErrorEvent(t, e) {
                        this.type = "renderFrameError", this.nativeError = t, this.currentTime = e
                    }

                    function BMConfigErrorEvent(t) {
                        this.type = "configError", this.nativeError = t
                    }

                    function BMAnimationConfigErrorEvent(t, e) {
                        this.type = t, this.nativeError = e, this.currentTime = currentTime
                    }
                    roundValues(!1);
                    var createElementID = (_count = 0, function() {
                            return "__lottie_element_" + ++_count
                        }),
                        _count;

                    function HSVtoRGB(t, e, n) {
                        var i, r, a, s, o, l, h, u;
                        switch (l = n * (1 - e), h = n * (1 - (o = 6 * t - (s = Math.floor(6 * t))) * e), u = n * (1 - (1 - o) * e), s % 6) {
                            case 0:
                                i = n, r = u, a = l;
                                break;
                            case 1:
                                i = h, r = n, a = l;
                                break;
                            case 2:
                                i = l, r = n, a = u;
                                break;
                            case 3:
                                i = l, r = h, a = n;
                                break;
                            case 4:
                                i = u, r = l, a = n;
                                break;
                            case 5:
                                i = n, r = l, a = h
                        }
                        return [i, r, a]
                    }

                    function RGBtoHSV(t, e, n) {
                        var i, r = Math.max(t, e, n),
                            a = Math.min(t, e, n),
                            s = r - a,
                            o = 0 === r ? 0 : s / r,
                            l = r / 255;
                        switch (r) {
                            case a:
                                i = 0;
                                break;
                            case t:
                                i = e - n + s * (e < n ? 6 : 0), i /= 6 * s;
                                break;
                            case e:
                                i = n - t + 2 * s, i /= 6 * s;
                                break;
                            case n:
                                i = t - e + 4 * s, i /= 6 * s
                        }
                        return [i, o, l]
                    }

                    function addSaturationToRGB(t, e) {
                        var n = RGBtoHSV(255 * t[0], 255 * t[1], 255 * t[2]);
                        return n[1] += e, n[1] > 1 ? n[1] = 1 : n[1] <= 0 && (n[1] = 0), HSVtoRGB(n[0], n[1], n[2])
                    }

                    function addBrightnessToRGB(t, e) {
                        var n = RGBtoHSV(255 * t[0], 255 * t[1], 255 * t[2]);
                        return n[2] += e, n[2] > 1 ? n[2] = 1 : n[2] < 0 && (n[2] = 0), HSVtoRGB(n[0], n[1], n[2])
                    }

                    function addHueToRGB(t, e) {
                        var n = RGBtoHSV(255 * t[0], 255 * t[1], 255 * t[2]);
                        return n[0] += e / 360, n[0] > 1 ? n[0] -= 1 : n[0] < 0 && (n[0] += 1), HSVtoRGB(n[0], n[1], n[2])
                    }
                    var rgbToHex = function() {
                        var t, e, n = [];
                        for (t = 0; t < 256; t += 1) e = t.toString(16), n[t] = 1 == e.length ? "0" + e : e;
                        return function(t, e, i) {
                            return t < 0 && (t = 0), e < 0 && (e = 0), i < 0 && (i = 0), "#" + n[t] + n[e] + n[i]
                        }
                    }();

                    function BaseEvent() {}
                    BaseEvent.prototype = {
                        triggerEvent: function(t, e) {
                            if (this._cbs[t])
                                for (var n = this._cbs[t].length, i = 0; i < n; i++) this._cbs[t][i](e)
                        },
                        addEventListener: function(t, e) {
                            return this._cbs[t] || (this._cbs[t] = []), this._cbs[t].push(e),
                                function() {
                                    this.removeEventListener(t, e)
                                }.bind(this)
                        },
                        removeEventListener: function(t, e) {
                            if (e) {
                                if (this._cbs[t]) {
                                    for (var n = 0, i = this._cbs[t].length; n < i;) this._cbs[t][n] === e && (this._cbs[t].splice(n, 1), n -= 1, i -= 1), n += 1;
                                    this._cbs[t].length || (this._cbs[t] = null)
                                }
                            } else this._cbs[t] = null
                        }
                    };
                    var createTypedArray = "function" == typeof Uint8ClampedArray && "function" == typeof Float32Array ? function(t, e) {
                        return "float32" === t ? new Float32Array(e) : "int16" === t ? new Int16Array(e) : "uint8c" === t ? new Uint8ClampedArray(e) : void 0
                    } : function(t, e) {
                        var n, i = 0,
                            r = [];
                        switch (t) {
                            case "int16":
                            case "uint8c":
                                n = 1;
                                break;
                            default:
                                n = 1.1
                        }
                        for (i = 0; i < e; i += 1) r.push(n);
                        return r
                    };

                    function createSizedArray(t) {
                        return Array.apply(null, {
                            length: t
                        })
                    }

                    function createNS(t) {
                        return document.createElementNS(svgNS, t)
                    }

                    function createTag(t) {
                        return document.createElement(t)
                    }

                    function DynamicPropertyContainer() {}
                    DynamicPropertyContainer.prototype = {
                        addDynamicProperty: function(t) {
                            -1 === this.dynamicProperties.indexOf(t) && (this.dynamicProperties.push(t), this.container.addDynamicProperty(this), this._isAnimated = !0)
                        },
                        iterateDynamicProperties: function() {
                            this._mdf = !1;
                            var t, e = this.dynamicProperties.length;
                            for (t = 0; t < e; t += 1) this.dynamicProperties[t].getValue(), this.dynamicProperties[t]._mdf && (this._mdf = !0)
                        },
                        initDynamicPropertyContainer: function(t) {
                            this.container = t, this.dynamicProperties = [], this._mdf = !1, this._isAnimated = !1
                        }
                    };
                    var getBlendMode = (blendModeEnums = {
                            0: "source-over",
                            1: "multiply",
                            2: "screen",
                            3: "overlay",
                            4: "darken",
                            5: "lighten",
                            6: "color-dodge",
                            7: "color-burn",
                            8: "hard-light",
                            9: "soft-light",
                            10: "difference",
                            11: "exclusion",
                            12: "hue",
                            13: "saturation",
                            14: "color",
                            15: "luminosity"
                        }, function(t) {
                            return blendModeEnums[t] || ""
                        }),
                        blendModeEnums, Matrix = function() {
                            var t = Math.cos,
                                e = Math.sin,
                                n = Math.tan,
                                i = Math.round;

                            function r() {
                                return this.props[0] = 1, this.props[1] = 0, this.props[2] = 0, this.props[3] = 0, this.props[4] = 0, this.props[5] = 1, this.props[6] = 0, this.props[7] = 0, this.props[8] = 0, this.props[9] = 0, this.props[10] = 1, this.props[11] = 0, this.props[12] = 0, this.props[13] = 0, this.props[14] = 0, this.props[15] = 1, this
                            }

                            function a(n) {
                                if (0 === n) return this;
                                var i = t(n),
                                    r = e(n);
                                return this._t(i, -r, 0, 0, r, i, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                            }

                            function s(n) {
                                if (0 === n) return this;
                                var i = t(n),
                                    r = e(n);
                                return this._t(1, 0, 0, 0, 0, i, -r, 0, 0, r, i, 0, 0, 0, 0, 1)
                            }

                            function o(n) {
                                if (0 === n) return this;
                                var i = t(n),
                                    r = e(n);
                                return this._t(i, 0, r, 0, 0, 1, 0, 0, -r, 0, i, 0, 0, 0, 0, 1)
                            }

                            function l(n) {
                                if (0 === n) return this;
                                var i = t(n),
                                    r = e(n);
                                return this._t(i, -r, 0, 0, r, i, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                            }

                            function h(t, e) {
                                return this._t(1, e, t, 1, 0, 0)
                            }

                            function u(t, e) {
                                return this.shear(n(t), n(e))
                            }

                            function c(i, r) {
                                var a = t(r),
                                    s = e(r);
                                return this._t(a, s, 0, 0, -s, a, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, n(i), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(a, -s, 0, 0, s, a, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                            }

                            function p(t, e, n) {
                                return n || 0 === n || (n = 1), 1 === t && 1 === e && 1 === n ? this : this._t(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1)
                            }

                            function f(t, e, n, i, r, a, s, o, l, h, u, c, p, f, d, m) {
                                return this.props[0] = t, this.props[1] = e, this.props[2] = n, this.props[3] = i, this.props[4] = r, this.props[5] = a, this.props[6] = s, this.props[7] = o, this.props[8] = l, this.props[9] = h, this.props[10] = u, this.props[11] = c, this.props[12] = p, this.props[13] = f, this.props[14] = d, this.props[15] = m, this
                            }

                            function d(t, e, n) {
                                return n = n || 0, 0 !== t || 0 !== e || 0 !== n ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, t, e, n, 1) : this
                            }

                            function m(t, e, n, i, r, a, s, o, l, h, u, c, p, f, d, m) {
                                var g = this.props;
                                if (1 === t && 0 === e && 0 === n && 0 === i && 0 === r && 1 === a && 0 === s && 0 === o && 0 === l && 0 === h && 1 === u && 0 === c) return g[12] = g[12] * t + g[15] * p, g[13] = g[13] * a + g[15] * f, g[14] = g[14] * u + g[15] * d, g[15] = g[15] * m, this._identityCalculated = !1, this;
                                var v = g[0],
                                    y = g[1],
                                    _ = g[2],
                                    x = g[3],
                                    b = g[4],
                                    E = g[5],
                                    w = g[6],
                                    D = g[7],
                                    S = g[8],
                                    M = g[9],
                                    T = g[10],
                                    A = g[11],
                                    C = g[12],
                                    P = g[13],
                                    F = g[14],
                                    L = g[15];
                                return g[0] = v * t + y * r + _ * l + x * p, g[1] = v * e + y * a + _ * h + x * f, g[2] = v * n + y * s + _ * u + x * d, g[3] = v * i + y * o + _ * c + x * m, g[4] = b * t + E * r + w * l + D * p, g[5] = b * e + E * a + w * h + D * f, g[6] = b * n + E * s + w * u + D * d, g[7] = b * i + E * o + w * c + D * m, g[8] = S * t + M * r + T * l + A * p, g[9] = S * e + M * a + T * h + A * f, g[10] = S * n + M * s + T * u + A * d, g[11] = S * i + M * o + T * c + A * m, g[12] = C * t + P * r + F * l + L * p, g[13] = C * e + P * a + F * h + L * f, g[14] = C * n + P * s + F * u + L * d, g[15] = C * i + P * o + F * c + L * m, this._identityCalculated = !1, this
                            }

                            function g() {
                                return this._identityCalculated || (this._identity = !(1 !== this.props[0] || 0 !== this.props[1] || 0 !== this.props[2] || 0 !== this.props[3] || 0 !== this.props[4] || 1 !== this.props[5] || 0 !== this.props[6] || 0 !== this.props[7] || 0 !== this.props[8] || 0 !== this.props[9] || 1 !== this.props[10] || 0 !== this.props[11] || 0 !== this.props[12] || 0 !== this.props[13] || 0 !== this.props[14] || 1 !== this.props[15]), this._identityCalculated = !0), this._identity
                            }

                            function v(t) {
                                for (var e = 0; e < 16;) {
                                    if (t.props[e] !== this.props[e]) return !1;
                                    e += 1
                                }
                                return !0
                            }

                            function y(t) {
                                var e;
                                for (e = 0; e < 16; e += 1) t.props[e] = this.props[e];
                                return t
                            }

                            function _(t) {
                                var e;
                                for (e = 0; e < 16; e += 1) this.props[e] = t[e]
                            }

                            function x(t, e, n) {
                                return {
                                    x: t * this.props[0] + e * this.props[4] + n * this.props[8] + this.props[12],
                                    y: t * this.props[1] + e * this.props[5] + n * this.props[9] + this.props[13],
                                    z: t * this.props[2] + e * this.props[6] + n * this.props[10] + this.props[14]
                                }
                            }

                            function b(t, e, n) {
                                return t * this.props[0] + e * this.props[4] + n * this.props[8] + this.props[12]
                            }

                            function E(t, e, n) {
                                return t * this.props[1] + e * this.props[5] + n * this.props[9] + this.props[13]
                            }

                            function w(t, e, n) {
                                return t * this.props[2] + e * this.props[6] + n * this.props[10] + this.props[14]
                            }

                            function D() {
                                var t = this.props[0] * this.props[5] - this.props[1] * this.props[4],
                                    e = this.props[5] / t,
                                    n = -this.props[1] / t,
                                    i = -this.props[4] / t,
                                    r = this.props[0] / t,
                                    a = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / t,
                                    s = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / t,
                                    o = new Matrix;
                                return o.props[0] = e, o.props[1] = n, o.props[4] = i, o.props[5] = r, o.props[12] = a, o.props[13] = s, o
                            }

                            function S(t) {
                                return this.getInverseMatrix().applyToPointArray(t[0], t[1], t[2] || 0)
                            }

                            function M(t) {
                                var e, n = t.length,
                                    i = [];
                                for (e = 0; e < n; e += 1) i[e] = S(t[e]);
                                return i
                            }

                            function T(t, e, n) {
                                var i = createTypedArray("float32", 6);
                                if (this.isIdentity()) i[0] = t[0], i[1] = t[1], i[2] = e[0], i[3] = e[1], i[4] = n[0], i[5] = n[1];
                                else {
                                    var r = this.props[0],
                                        a = this.props[1],
                                        s = this.props[4],
                                        o = this.props[5],
                                        l = this.props[12],
                                        h = this.props[13];
                                    i[0] = t[0] * r + t[1] * s + l, i[1] = t[0] * a + t[1] * o + h, i[2] = e[0] * r + e[1] * s + l, i[3] = e[0] * a + e[1] * o + h, i[4] = n[0] * r + n[1] * s + l, i[5] = n[0] * a + n[1] * o + h
                                }
                                return i
                            }

                            function A(t, e, n) {
                                return this.isIdentity() ? [t, e, n] : [t * this.props[0] + e * this.props[4] + n * this.props[8] + this.props[12], t * this.props[1] + e * this.props[5] + n * this.props[9] + this.props[13], t * this.props[2] + e * this.props[6] + n * this.props[10] + this.props[14]]
                            }

                            function C(t, e) {
                                if (this.isIdentity()) return t + "," + e;
                                var n = this.props;
                                return Math.round(100 * (t * n[0] + e * n[4] + n[12])) / 100 + "," + Math.round(100 * (t * n[1] + e * n[5] + n[13])) / 100
                            }

                            function P() {
                                for (var t = 0, e = this.props, n = "matrix3d("; t < 16;) n += i(1e4 * e[t]) / 1e4, n += 15 === t ? ")" : ",", t += 1;
                                return n
                            }

                            function F(t) {
                                return t < 1e-6 && t > 0 || t > -1e-6 && t < 0 ? i(1e4 * t) / 1e4 : t
                            }

                            function L() {
                                var t = this.props;
                                return "matrix(" + F(t[0]) + "," + F(t[1]) + "," + F(t[4]) + "," + F(t[5]) + "," + F(t[12]) + "," + F(t[13]) + ")"
                            }
                            return function() {
                                this.reset = r, this.rotate = a, this.rotateX = s, this.rotateY = o, this.rotateZ = l, this.skew = u, this.skewFromAxis = c, this.shear = h, this.scale = p, this.setTransform = f, this.translate = d, this.transform = m, this.applyToPoint = x, this.applyToX = b, this.applyToY = E, this.applyToZ = w, this.applyToPointArray = A, this.applyToTriplePoints = T, this.applyToPointStringified = C, this.toCSS = P, this.to2dCSS = L, this.clone = y, this.cloneFromProps = _, this.equals = v, this.inversePoints = M, this.inversePoint = S, this.getInverseMatrix = D, this._t = this.transform, this.isIdentity = g, this._identity = !0, this._identityCalculated = !1, this.props = createTypedArray("float32", 16), this.reset()
                            }
                        }();
                    ! function(t, e) {
                        var n = this,
                            i = e.pow(256, 6),
                            r = e.pow(2, 52),
                            a = 2 * r;

                        function s(t) {
                            var e, n = t.length,
                                i = this,
                                r = 0,
                                a = i.i = i.j = 0,
                                s = i.S = [];
                            for (n || (t = [n++]); r < 256;) s[r] = r++;
                            for (r = 0; r < 256; r++) s[r] = s[a = 255 & a + t[r % n] + (e = s[r])], s[a] = e;
                            i.g = function(t) {
                                for (var e, n = 0, r = i.i, a = i.j, s = i.S; t--;) e = s[r = 255 & r + 1], n = 256 * n + s[255 & (s[r] = s[a = 255 & a + e]) + (s[a] = e)];
                                return i.i = r, i.j = a, n
                            }
                        }

                        function o(t, e) {
                            return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e
                        }

                        function l(t, e) {
                            for (var n, i = t + "", r = 0; r < i.length;) e[255 & r] = 255 & (n ^= 19 * e[255 & r]) + i.charCodeAt(r++);
                            return h(e)
                        }

                        function h(t) {
                            return String.fromCharCode.apply(0, t)
                        }
                        e.seedrandom = function(u, c, p) {
                            var f = [],
                                d = l(function t(e, n) {
                                    var i, r = [],
                                        a = typeof e;
                                    if (n && "object" == a)
                                        for (i in e) try {
                                            r.push(t(e[i], n - 1))
                                        } catch (t) {}
                                    return r.length ? r : "string" == a ? e : e + "\0"
                                }((c = !0 === c ? {
                                    entropy: !0
                                } : c || {}).entropy ? [u, h(t)] : null === u ? function() {
                                    try {
                                        void 0;
                                        var e = new Uint8Array(256);
                                        return (n.crypto || n.msCrypto).getRandomValues(e), h(e)
                                    } catch (e) {
                                        var i = n.navigator,
                                            r = i && i.plugins;
                                        return [+new Date, n, r, n.screen, h(t)]
                                    }
                                }() : u, 3), f),
                                m = new s(f),
                                g = function() {
                                    for (var t = m.g(6), e = i, n = 0; t < r;) t = 256 * (t + n), e *= 256, n = m.g(1);
                                    for (; t >= a;) t /= 2, e /= 2, n >>>= 1;
                                    return (t + n) / e
                                };
                            return g.int32 = function() {
                                return 0 | m.g(4)
                            }, g.quick = function() {
                                return m.g(4) / 4294967296
                            }, g.double = g, l(h(m.S), t), (c.pass || p || function(t, n, i, r) {
                                return r && (r.S && o(r, m), t.state = function() {
                                    return o(m, {})
                                }), i ? (e.random = t, n) : t
                            })(g, d, "global" in c ? c.global : this == e, c.state)
                        }, l(e.random(), t)
                    }([], BMMath);
                    var BezierFactory = function() {
                        var t = {
                                getBezierEasing: function(t, n, i, r, a) {
                                    var s = a || ("bez_" + t + "_" + n + "_" + i + "_" + r).replace(/\./g, "p");
                                    if (e[s]) return e[s];
                                    var o = new l([t, n, i, r]);
                                    return e[s] = o, o
                                }
                            },
                            e = {};
                        var n = "function" == typeof Float32Array;

                        function i(t, e) {
                            return 1 - 3 * e + 3 * t
                        }

                        function r(t, e) {
                            return 3 * e - 6 * t
                        }

                        function a(t) {
                            return 3 * t
                        }

                        function s(t, e, n) {
                            return ((i(e, n) * t + r(e, n)) * t + a(e)) * t
                        }

                        function o(t, e, n) {
                            return 3 * i(e, n) * t * t + 2 * r(e, n) * t + a(e)
                        }

                        function l(t) {
                            this._p = t, this._mSampleValues = n ? new Float32Array(11) : new Array(11), this._precomputed = !1, this.get = this.get.bind(this)
                        }
                        return l.prototype = {
                            get: function(t) {
                                var e = this._p[0],
                                    n = this._p[1],
                                    i = this._p[2],
                                    r = this._p[3];
                                return this._precomputed || this._precompute(), e === n && i === r ? t : 0 === t ? 0 : 1 === t ? 1 : s(this._getTForX(t), n, r)
                            },
                            _precompute: function() {
                                var t = this._p[0],
                                    e = this._p[1],
                                    n = this._p[2],
                                    i = this._p[3];
                                this._precomputed = !0, t === e && n === i || this._calcSampleValues()
                            },
                            _calcSampleValues: function() {
                                for (var t = this._p[0], e = this._p[2], n = 0; n < 11; ++n) this._mSampleValues[n] = s(.1 * n, t, e)
                            },
                            _getTForX: function(t) {
                                for (var e = this._p[0], n = this._p[2], i = this._mSampleValues, r = 0, a = 1; 10 !== a && i[a] <= t; ++a) r += .1;
                                var l = r + .1 * ((t - i[--a]) / (i[a + 1] - i[a])),
                                    h = o(l, e, n);
                                return h >= .001 ? function(t, e, n, i) {
                                    for (var r = 0; r < 4; ++r) {
                                        var a = o(e, n, i);
                                        if (0 === a) return e;
                                        e -= (s(e, n, i) - t) / a
                                    }
                                    return e
                                }(t, l, e, n) : 0 === h ? l : function(t, e, n, i, r) {
                                    var a, o, l = 0;
                                    do {
                                        (a = s(o = e + (n - e) / 2, i, r) - t) > 0 ? n = o : e = o
                                    } while (Math.abs(a) > 1e-7 && ++l < 10);
                                    return o
                                }(t, r, r + .1, e, n)
                            }
                        }, t
                    }();

                    function extendPrototype(t, e) {
                        var n, i, r = t.length;
                        for (n = 0; n < r; n += 1)
                            for (var a in i = t[n].prototype) i.hasOwnProperty(a) && (e.prototype[a] = i[a])
                    }

                    function getDescriptor(t, e) {
                        return Object.getOwnPropertyDescriptor(t, e)
                    }

                    function createProxyFunction(t) {
                        function e() {}
                        return e.prototype = t, e
                    }

                    function bezFunction() {
                        Math;

                        function t(t, e, n, i, r, a) {
                            var s = t * i + e * r + n * a - r * i - a * t - n * e;
                            return s > -.001 && s < .001
                        }
                        var e = function(t, e, n, i) {
                            var r, a, s, o, l, h, u = defaultCurveSegments,
                                c = 0,
                                p = [],
                                f = [],
                                d = bezier_length_pool.newElement();
                            for (s = n.length, r = 0; r < u; r += 1) {
                                for (l = r / (u - 1), h = 0, a = 0; a < s; a += 1) o = bm_pow(1 - l, 3) * t[a] + 3 * bm_pow(1 - l, 2) * l * n[a] + 3 * (1 - l) * bm_pow(l, 2) * i[a] + bm_pow(l, 3) * e[a], p[a] = o, null !== f[a] && (h += bm_pow(p[a] - f[a], 2)), f[a] = p[a];
                                h && (c += h = bm_sqrt(h)), d.percents[r] = l, d.lengths[r] = c
                            }
                            return d.addedLength = c, d
                        };

                        function n(t) {
                            this.segmentLength = 0, this.points = new Array(t)
                        }

                        function i(t, e) {
                            this.partialLength = t, this.point = e
                        }
                        var r, a = (r = {}, function(e, a, s, o) {
                            var l = (e[0] + "_" + e[1] + "_" + a[0] + "_" + a[1] + "_" + s[0] + "_" + s[1] + "_" + o[0] + "_" + o[1]).replace(/\./g, "p");
                            if (!r[l]) {
                                var h, u, c, p, f, d, m, g = defaultCurveSegments,
                                    v = 0,
                                    y = null;
                                2 === e.length && (e[0] != a[0] || e[1] != a[1]) && t(e[0], e[1], a[0], a[1], e[0] + s[0], e[1] + s[1]) && t(e[0], e[1], a[0], a[1], a[0] + o[0], a[1] + o[1]) && (g = 2);
                                var _ = new n(g);
                                for (c = s.length, h = 0; h < g; h += 1) {
                                    for (m = createSizedArray(c), f = h / (g - 1), d = 0, u = 0; u < c; u += 1) p = bm_pow(1 - f, 3) * e[u] + 3 * bm_pow(1 - f, 2) * f * (e[u] + s[u]) + 3 * (1 - f) * bm_pow(f, 2) * (a[u] + o[u]) + bm_pow(f, 3) * a[u], m[u] = p, null !== y && (d += bm_pow(m[u] - y[u], 2));
                                    v += d = bm_sqrt(d), _.points[h] = new i(d, m), y = m
                                }
                                _.segmentLength = v, r[l] = _
                            }
                            return r[l]
                        });

                        function s(t, e) {
                            var n = e.percents,
                                i = e.lengths,
                                r = n.length,
                                a = bm_floor((r - 1) * t),
                                s = t * e.addedLength,
                                o = 0;
                            if (a === r - 1 || 0 === a || s === i[a]) return n[a];
                            for (var l = i[a] > s ? -1 : 1, h = !0; h;)
                                if (i[a] <= s && i[a + 1] > s ? (o = (s - i[a]) / (i[a + 1] - i[a]), h = !1) : a += l, a < 0 || a >= r - 1) {
                                    if (a === r - 1) return n[a];
                                    h = !1
                                }
                            return n[a] + (n[a + 1] - n[a]) * o
                        }
                        var o = createTypedArray("float32", 8);
                        return {
                            getSegmentsLength: function(t) {
                                var n, i = segments_length_pool.newElement(),
                                    r = t.c,
                                    a = t.v,
                                    s = t.o,
                                    o = t.i,
                                    l = t._length,
                                    h = i.lengths,
                                    u = 0;
                                for (n = 0; n < l - 1; n += 1) h[n] = e(a[n], a[n + 1], s[n], o[n + 1]), u += h[n].addedLength;
                                return r && l && (h[n] = e(a[n], a[0], s[n], o[0]), u += h[n].addedLength), i.totalLength = u, i
                            },
                            getNewSegment: function(t, e, n, i, r, a, l) {
                                var h, u = s(r = r < 0 ? 0 : r > 1 ? 1 : r, l),
                                    c = s(a = a > 1 ? 1 : a, l),
                                    p = t.length,
                                    f = 1 - u,
                                    d = 1 - c,
                                    m = f * f * f,
                                    g = u * f * f * 3,
                                    v = u * u * f * 3,
                                    y = u * u * u,
                                    _ = f * f * d,
                                    x = u * f * d + f * u * d + f * f * c,
                                    b = u * u * d + f * u * c + u * f * c,
                                    E = u * u * c,
                                    w = f * d * d,
                                    D = u * d * d + f * c * d + f * d * c,
                                    S = u * c * d + f * c * c + u * d * c,
                                    M = u * c * c,
                                    T = d * d * d,
                                    A = c * d * d + d * c * d + d * d * c,
                                    C = c * c * d + d * c * c + c * d * c,
                                    P = c * c * c;
                                for (h = 0; h < p; h += 1) o[4 * h] = Math.round(1e3 * (m * t[h] + g * n[h] + v * i[h] + y * e[h])) / 1e3, o[4 * h + 1] = Math.round(1e3 * (_ * t[h] + x * n[h] + b * i[h] + E * e[h])) / 1e3, o[4 * h + 2] = Math.round(1e3 * (w * t[h] + D * n[h] + S * i[h] + M * e[h])) / 1e3, o[4 * h + 3] = Math.round(1e3 * (T * t[h] + A * n[h] + C * i[h] + P * e[h])) / 1e3;
                                return o
                            },
                            getPointInSegment: function(t, e, n, i, r, a) {
                                var o = s(r, a),
                                    l = 1 - o;
                                return [Math.round(1e3 * (l * l * l * t[0] + (o * l * l + l * o * l + l * l * o) * n[0] + (o * o * l + l * o * o + o * l * o) * i[0] + o * o * o * e[0])) / 1e3, Math.round(1e3 * (l * l * l * t[1] + (o * l * l + l * o * l + l * l * o) * n[1] + (o * o * l + l * o * o + o * l * o) * i[1] + o * o * o * e[1])) / 1e3]
                            },
                            buildBezierData: a,
                            pointOnLine2D: t,
                            pointOnLine3D: function(e, n, i, r, a, s, o, l, h) {
                                if (0 === i && 0 === s && 0 === h) return t(e, n, r, a, o, l);
                                var u, c = Math.sqrt(Math.pow(r - e, 2) + Math.pow(a - n, 2) + Math.pow(s - i, 2)),
                                    p = Math.sqrt(Math.pow(o - e, 2) + Math.pow(l - n, 2) + Math.pow(h - i, 2)),
                                    f = Math.sqrt(Math.pow(o - r, 2) + Math.pow(l - a, 2) + Math.pow(h - s, 2));
                                return (u = c > p ? c > f ? c - p - f : f - p - c : f > p ? f - p - c : p - c - f) > -1e-4 && u < 1e-4
                            }
                        }
                    }! function() {
                        for (var t = 0, e = ["ms", "moz", "webkit", "o"], n = 0; n < e.length && !window.requestAnimationFrame; ++n) window.requestAnimationFrame = window[e[n] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[e[n] + "CancelAnimationFrame"] || window[e[n] + "CancelRequestAnimationFrame"];
                        window.requestAnimationFrame || (window.requestAnimationFrame = function(e, n) {
                            var i = (new Date).getTime(),
                                r = Math.max(0, 16 - (i - t)),
                                a = setTimeout((function() {
                                    e(i + r)
                                }), r);
                            return t = i + r, a
                        }), window.cancelAnimationFrame || (window.cancelAnimationFrame = function(t) {
                            clearTimeout(t)
                        })
                    }();
                    var bez = bezFunction();

                    function dataFunctionManager() {
                        function t(r, a, s) {
                            var o, l, h, c, p, f, d = r.length;
                            for (l = 0; l < d; l += 1)
                                if ("ks" in (o = r[l]) && !o.completed) {
                                    if (o.completed = !0, o.tt && (r[l - 1].td = o.tt), [], -1, o.hasMask) {
                                        var m = o.masksProperties;
                                        for (c = m.length, h = 0; h < c; h += 1)
                                            if (m[h].pt.k.i) i(m[h].pt.k);
                                            else
                                                for (f = m[h].pt.k.length, p = 0; p < f; p += 1) m[h].pt.k[p].s && i(m[h].pt.k[p].s[0]), m[h].pt.k[p].e && i(m[h].pt.k[p].e[0])
                                    }
                                    0 === o.ty ? (o.layers = e(o.refId, a), t(o.layers, a, s)) : 4 === o.ty ? n(o.shapes) : 5 == o.ty && u(o, s)
                                }
                        }

                        function e(t, e) {
                            for (var n = 0, i = e.length; n < i;) {
                                if (e[n].id === t) return e[n].layers.__used ? JSON.parse(JSON.stringify(e[n].layers)) : (e[n].layers.__used = !0, e[n].layers);
                                n += 1
                            }
                        }

                        function n(t) {
                            var e, r, a;
                            for (e = t.length - 1; e >= 0; e -= 1)
                                if ("sh" == t[e].ty) {
                                    if (t[e].ks.k.i) i(t[e].ks.k);
                                    else
                                        for (a = t[e].ks.k.length, r = 0; r < a; r += 1) t[e].ks.k[r].s && i(t[e].ks.k[r].s[0]), t[e].ks.k[r].e && i(t[e].ks.k[r].e[0]);
                                    !0
                                } else "gr" == t[e].ty && n(t[e].it)
                        }

                        function i(t) {
                            var e, n = t.i.length;
                            for (e = 0; e < n; e += 1) t.i[e][0] += t.v[e][0], t.i[e][1] += t.v[e][1], t.o[e][0] += t.v[e][0], t.o[e][1] += t.v[e][1]
                        }

                        function r(t, e) {
                            var n = e ? e.split(".") : [100, 100, 100];
                            return t[0] > n[0] || !(n[0] > t[0]) && (t[1] > n[1] || !(n[1] > t[1]) && (t[2] > n[2] || !(n[2] > t[2]) && void 0))
                        }
                        var a, s = function() {
                                var t = [4, 4, 14];

                                function e(t) {
                                    var e, n, i, r = t.length;
                                    for (e = 0; e < r; e += 1) 5 === t[e].ty && (n = t[e], i = void 0, i = n.t.d, n.t.d = {
                                        k: [{
                                            s: i,
                                            t: 0
                                        }]
                                    })
                                }
                                return function(n) {
                                    if (r(t, n.v) && (e(n.layers), n.assets)) {
                                        var i, a = n.assets.length;
                                        for (i = 0; i < a; i += 1) n.assets[i].layers && e(n.assets[i].layers)
                                    }
                                }
                            }(),
                            o = (a = [4, 7, 99], function(t) {
                                if (t.chars && !r(a, t.v)) {
                                    var e, n, s, o, l, h = t.chars.length;
                                    for (e = 0; e < h; e += 1)
                                        if (t.chars[e].data && t.chars[e].data.shapes)
                                            for (s = (l = t.chars[e].data.shapes[0].it).length, n = 0; n < s; n += 1)(o = l[n].ks.k).__converted || (i(l[n].ks.k), o.__converted = !0)
                                }
                            }),
                            l = function() {
                                var t = [4, 1, 9];

                                function e(t) {
                                    var n, i, r, a = t.length;
                                    for (n = 0; n < a; n += 1)
                                        if ("gr" === t[n].ty) e(t[n].it);
                                        else if ("fl" === t[n].ty || "st" === t[n].ty)
                                        if (t[n].c.k && t[n].c.k[0].i)
                                            for (r = t[n].c.k.length, i = 0; i < r; i += 1) t[n].c.k[i].s && (t[n].c.k[i].s[0] /= 255, t[n].c.k[i].s[1] /= 255, t[n].c.k[i].s[2] /= 255, t[n].c.k[i].s[3] /= 255), t[n].c.k[i].e && (t[n].c.k[i].e[0] /= 255, t[n].c.k[i].e[1] /= 255, t[n].c.k[i].e[2] /= 255, t[n].c.k[i].e[3] /= 255);
                                        else t[n].c.k[0] /= 255, t[n].c.k[1] /= 255, t[n].c.k[2] /= 255, t[n].c.k[3] /= 255
                                }

                                function n(t) {
                                    var n, i = t.length;
                                    for (n = 0; n < i; n += 1) 4 === t[n].ty && e(t[n].shapes)
                                }
                                return function(e) {
                                    if (r(t, e.v) && (n(e.layers), e.assets)) {
                                        var i, a = e.assets.length;
                                        for (i = 0; i < a; i += 1) e.assets[i].layers && n(e.assets[i].layers)
                                    }
                                }
                            }(),
                            h = function() {
                                var t = [4, 4, 18];

                                function e(t) {
                                    var n, i, r;
                                    for (n = t.length - 1; n >= 0; n -= 1)
                                        if ("sh" == t[n].ty) {
                                            if (t[n].ks.k.i) t[n].ks.k.c = t[n].closed;
                                            else
                                                for (r = t[n].ks.k.length, i = 0; i < r; i += 1) t[n].ks.k[i].s && (t[n].ks.k[i].s[0].c = t[n].closed), t[n].ks.k[i].e && (t[n].ks.k[i].e[0].c = t[n].closed);
                                            !0
                                        } else "gr" == t[n].ty && e(t[n].it)
                                }

                                function n(t) {
                                    var n, i, r, a, s, o, l = t.length;
                                    for (i = 0; i < l; i += 1) {
                                        if ((n = t[i]).hasMask) {
                                            var h = n.masksProperties;
                                            for (a = h.length, r = 0; r < a; r += 1)
                                                if (h[r].pt.k.i) h[r].pt.k.c = h[r].cl;
                                                else
                                                    for (o = h[r].pt.k.length, s = 0; s < o; s += 1) h[r].pt.k[s].s && (h[r].pt.k[s].s[0].c = h[r].cl), h[r].pt.k[s].e && (h[r].pt.k[s].e[0].c = h[r].cl)
                                        }
                                        4 === n.ty && e(n.shapes)
                                    }
                                }
                                return function(e) {
                                    if (r(t, e.v) && (n(e.layers), e.assets)) {
                                        var i, a = e.assets.length;
                                        for (i = 0; i < a; i += 1) e.assets[i].layers && n(e.assets[i].layers)
                                    }
                                }
                            }();

                        function u(t, e) {
                            0 !== t.t.a.length || "m" in t.t.p || (t.singleShape = !0)
                        }
                        var c = {
                            completeData: function(e, n) {
                                e.__complete || (l(e), s(e), o(e), h(e), t(e.layers, e.assets, n), e.__complete = !0)
                            }
                        };
                        return c.checkColors = l, c.checkChars = o, c.checkShapes = h, c.completeLayers = t, c
                    }
                    var dataManager = dataFunctionManager(),
                        FontManager = function() {
                            var t = {
                                    w: 0,
                                    size: 0,
                                    shapes: []
                                },
                                e = [];

                            function n(t, e) {
                                var n = createTag("span");
                                n.style.fontFamily = e;
                                var i = createTag("span");
                                i.innerText = "giItT1WQy@!-/#", n.style.position = "absolute", n.style.left = "-10000px", n.style.top = "-10000px", n.style.fontSize = "300px", n.style.fontVariant = "normal", n.style.fontStyle = "normal", n.style.fontWeight = "normal", n.style.letterSpacing = "0", n.appendChild(i), document.body.appendChild(n);
                                var r = i.offsetWidth;
                                return i.style.fontFamily = function(t) {
                                    var e, n = t.split(","),
                                        i = n.length,
                                        r = [];
                                    for (e = 0; e < i; e += 1) "sans-serif" !== n[e] && "monospace" !== n[e] && r.push(n[e]);
                                    return r.join(",")
                                }(t) + ", " + e, {
                                    node: i,
                                    w: r,
                                    parent: n
                                }
                            }

                            function i(t, e) {
                                var n = createNS("text");
                                return n.style.fontSize = "100px", n.setAttribute("font-family", e.fFamily), n.setAttribute("font-style", e.fStyle), n.setAttribute("font-weight", e.fWeight), n.textContent = "1", e.fClass ? (n.style.fontFamily = "inherit", n.setAttribute("class", e.fClass)) : n.style.fontFamily = e.fFamily, t.appendChild(n), createTag("canvas").getContext("2d").font = e.fWeight + " " + e.fStyle + " 100px " + e.fFamily, n
                            }
                            e = e.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
                            var r = function() {
                                this.fonts = [], this.chars = null, this.typekitLoaded = 0, this.isLoaded = !1, this._warned = !1, this.initTime = Date.now(), this.setIsLoadedBinded = this.setIsLoaded.bind(this), this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this)
                            };
                            return r.getCombinedCharacterCodes = function() {
                                return e
                            }, r.prototype = {
                                addChars: function(t) {
                                    if (t) {
                                        this.chars || (this.chars = []);
                                        var e, n, i, r = t.length,
                                            a = this.chars.length;
                                        for (e = 0; e < r; e += 1) {
                                            for (n = 0, i = !1; n < a;) this.chars[n].style === t[e].style && this.chars[n].fFamily === t[e].fFamily && this.chars[n].ch === t[e].ch && (i = !0), n += 1;
                                            i || (this.chars.push(t[e]), a += 1)
                                        }
                                    }
                                },
                                addFonts: function(t, e) {
                                    if (t) {
                                        if (this.chars) return this.isLoaded = !0, void(this.fonts = t.list);
                                        var r, a = t.list,
                                            s = a.length,
                                            o = s;
                                        for (r = 0; r < s; r += 1) {
                                            var l, h, u = !0;
                                            if (a[r].loaded = !1, a[r].monoCase = n(a[r].fFamily, "monospace"), a[r].sansCase = n(a[r].fFamily, "sans-serif"), a[r].fPath) {
                                                if ("p" === a[r].fOrigin || 3 === a[r].origin) {
                                                    if ((l = document.querySelectorAll('style[f-forigin="p"][f-family="' + a[r].fFamily + '"], style[f-origin="3"][f-family="' + a[r].fFamily + '"]')).length > 0 && (u = !1), u) {
                                                        var c = createTag("style");
                                                        c.setAttribute("f-forigin", a[r].fOrigin), c.setAttribute("f-origin", a[r].origin), c.setAttribute("f-family", a[r].fFamily), c.type = "text/css", c.innerText = "@font-face {font-family: " + a[r].fFamily + "; font-style: normal; src: url('" + a[r].fPath + "');}", e.appendChild(c)
                                                    }
                                                } else if ("g" === a[r].fOrigin || 1 === a[r].origin) {
                                                    for (l = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]'), h = 0; h < l.length; h++) - 1 !== l[h].href.indexOf(a[r].fPath) && (u = !1);
                                                    if (u) {
                                                        var p = createTag("link");
                                                        p.setAttribute("f-forigin", a[r].fOrigin), p.setAttribute("f-origin", a[r].origin), p.type = "text/css", p.rel = "stylesheet", p.href = a[r].fPath, document.body.appendChild(p)
                                                    }
                                                } else if ("t" === a[r].fOrigin || 2 === a[r].origin) {
                                                    for (l = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]'), h = 0; h < l.length; h++) a[r].fPath === l[h].src && (u = !1);
                                                    if (u) {
                                                        var f = createTag("link");
                                                        f.setAttribute("f-forigin", a[r].fOrigin), f.setAttribute("f-origin", a[r].origin), f.setAttribute("rel", "stylesheet"), f.setAttribute("href", a[r].fPath), e.appendChild(f)
                                                    }
                                                }
                                            } else a[r].loaded = !0, o -= 1;
                                            a[r].helper = i(e, a[r]), a[r].cache = {}, this.fonts.push(a[r])
                                        }
                                        0 === o ? this.isLoaded = !0 : setTimeout(this.checkLoadedFonts.bind(this), 100)
                                    } else this.isLoaded = !0
                                },
                                getCharData: function(e, n, i) {
                                    for (var r = 0, a = this.chars.length; r < a;) {
                                        if (this.chars[r].ch === e && this.chars[r].style === n && this.chars[r].fFamily === i) return this.chars[r];
                                        r += 1
                                    }
                                    return ("string" == typeof e && 13 !== e.charCodeAt(0) || !e) && console && console.warn && !this._warned && (this._warned = !0, console.warn("Missing character from exported characters list: ", e, n, i)), t
                                },
                                getFontByName: function(t) {
                                    for (var e = 0, n = this.fonts.length; e < n;) {
                                        if (this.fonts[e].fName === t) return this.fonts[e];
                                        e += 1
                                    }
                                    return this.fonts[0]
                                },
                                measureText: function(t, e, n) {
                                    var i = this.getFontByName(e),
                                        r = t.charCodeAt(0);
                                    if (!i.cache[r + 1]) {
                                        var a = i.helper;
                                        if (" " === t) {
                                            a.textContent = "|" + t + "|";
                                            var s = a.getComputedTextLength();
                                            a.textContent = "||";
                                            var o = a.getComputedTextLength();
                                            i.cache[r + 1] = (s - o) / 100
                                        } else a.textContent = t, i.cache[r + 1] = a.getComputedTextLength() / 100
                                    }
                                    return i.cache[r + 1] * n
                                },
                                checkLoadedFonts: function() {
                                    var t, e, n, i = this.fonts.length,
                                        r = i;
                                    for (t = 0; t < i; t += 1) this.fonts[t].loaded ? r -= 1 : "n" === this.fonts[t].fOrigin || 0 === this.fonts[t].origin ? this.fonts[t].loaded = !0 : (e = this.fonts[t].monoCase.node, n = this.fonts[t].monoCase.w, e.offsetWidth !== n ? (r -= 1, this.fonts[t].loaded = !0) : (e = this.fonts[t].sansCase.node, n = this.fonts[t].sansCase.w, e.offsetWidth !== n && (r -= 1, this.fonts[t].loaded = !0)), this.fonts[t].loaded && (this.fonts[t].sansCase.parent.parentNode.removeChild(this.fonts[t].sansCase.parent), this.fonts[t].monoCase.parent.parentNode.removeChild(this.fonts[t].monoCase.parent)));
                                    0 !== r && Date.now() - this.initTime < 5e3 ? setTimeout(this.checkLoadedFontsBinded, 20) : setTimeout(this.setIsLoadedBinded, 10)
                                },
                                setIsLoaded: function() {
                                    this.isLoaded = !0
                                }
                            }, r
                        }(),
                        PropertyFactory = function() {
                            var t = initialDefaultFrame,
                                e = Math.abs;

                            function n(t, e) {
                                var n, r = this.offsetTime;
                                "multidimensional" === this.propType && (n = createTypedArray("float32", this.pv.length));
                                for (var a, s, o, l, h, u, c, p, f = e.lastIndex, d = f, m = this.keyframes.length - 1, g = !0; g;) {
                                    if (a = this.keyframes[d], s = this.keyframes[d + 1], d === m - 1 && t >= s.t - r) {
                                        a.h && (a = s), f = 0;
                                        break
                                    }
                                    if (s.t - r > t) {
                                        f = d;
                                        break
                                    }
                                    d < m - 1 ? d += 1 : (f = 0, g = !1)
                                }
                                var v, y = s.t - r,
                                    _ = a.t - r;
                                if (a.to) {
                                    a.bezierData || (a.bezierData = bez.buildBezierData(a.s, s.s || a.e, a.to, a.ti));
                                    var x = a.bezierData;
                                    if (t >= y || t < _) {
                                        var b = t >= y ? x.points.length - 1 : 0;
                                        for (l = x.points[b].point.length, o = 0; o < l; o += 1) n[o] = x.points[b].point[o]
                                    } else {
                                        a.__fnct ? p = a.__fnct : (p = BezierFactory.getBezierEasing(a.o.x, a.o.y, a.i.x, a.i.y, a.n).get, a.__fnct = p), h = p((t - _) / (y - _));
                                        var E, w = x.segmentLength * h,
                                            D = e.lastFrame < t && e._lastKeyframeIndex === d ? e._lastAddedLength : 0;
                                        for (c = e.lastFrame < t && e._lastKeyframeIndex === d ? e._lastPoint : 0, g = !0, u = x.points.length; g;) {
                                            if (D += x.points[c].partialLength, 0 === w || 0 === h || c === x.points.length - 1) {
                                                for (l = x.points[c].point.length, o = 0; o < l; o += 1) n[o] = x.points[c].point[o];
                                                break
                                            }
                                            if (w >= D && w < D + x.points[c + 1].partialLength) {
                                                for (E = (w - D) / x.points[c + 1].partialLength, l = x.points[c].point.length, o = 0; o < l; o += 1) n[o] = x.points[c].point[o] + (x.points[c + 1].point[o] - x.points[c].point[o]) * E;
                                                break
                                            }
                                            c < u - 1 ? c += 1 : g = !1
                                        }
                                        e._lastPoint = c, e._lastAddedLength = D - x.points[c].partialLength, e._lastKeyframeIndex = d
                                    }
                                } else {
                                    var S, M, T, A, C;
                                    if (m = a.s.length, v = s.s || a.e, this.sh && 1 !== a.h)
                                        if (t >= y) n[0] = v[0], n[1] = v[1], n[2] = v[2];
                                        else if (t <= _) n[0] = a.s[0], n[1] = a.s[1], n[2] = a.s[2];
                                    else {
                                        ! function(t, e) {
                                            var n = e[0],
                                                i = e[1],
                                                r = e[2],
                                                a = e[3],
                                                s = Math.atan2(2 * i * a - 2 * n * r, 1 - 2 * i * i - 2 * r * r),
                                                o = Math.asin(2 * n * i + 2 * r * a),
                                                l = Math.atan2(2 * n * a - 2 * i * r, 1 - 2 * n * n - 2 * r * r);
                                            t[0] = s / degToRads, t[1] = o / degToRads, t[2] = l / degToRads
                                        }(n, function(t, e, n) {
                                            var i, r, a, s, o, l = [],
                                                h = t[0],
                                                u = t[1],
                                                c = t[2],
                                                p = t[3],
                                                f = e[0],
                                                d = e[1],
                                                m = e[2],
                                                g = e[3];
                                            (r = h * f + u * d + c * m + p * g) < 0 && (r = -r, f = -f, d = -d, m = -m, g = -g);
                                            1 - r > 1e-6 ? (i = Math.acos(r), a = Math.sin(i), s = Math.sin((1 - n) * i) / a, o = Math.sin(n * i) / a) : (s = 1 - n, o = n);
                                            return l[0] = s * h + o * f, l[1] = s * u + o * d, l[2] = s * c + o * m, l[3] = s * p + o * g, l
                                        }(i(a.s), i(v), (t - _) / (y - _)))
                                    } else
                                        for (d = 0; d < m; d += 1) 1 !== a.h && (t >= y ? h = 1 : t < _ ? h = 0 : (a.o.x.constructor === Array ? (a.__fnct || (a.__fnct = []), a.__fnct[d] ? p = a.__fnct[d] : (S = void 0 === a.o.x[d] ? a.o.x[0] : a.o.x[d], M = void 0 === a.o.y[d] ? a.o.y[0] : a.o.y[d], T = void 0 === a.i.x[d] ? a.i.x[0] : a.i.x[d], A = void 0 === a.i.y[d] ? a.i.y[0] : a.i.y[d], p = BezierFactory.getBezierEasing(S, M, T, A).get, a.__fnct[d] = p)) : a.__fnct ? p = a.__fnct : (S = a.o.x, M = a.o.y, T = a.i.x, A = a.i.y, p = BezierFactory.getBezierEasing(S, M, T, A).get, a.__fnct = p), h = p((t - _) / (y - _)))), v = s.s || a.e, C = 1 === a.h ? a.s[d] : a.s[d] + (v[d] - a.s[d]) * h, "multidimensional" === this.propType ? n[d] = C : n = C
                                }
                                return e.lastIndex = f, n
                            }

                            function i(t) {
                                var e = t[0] * degToRads,
                                    n = t[1] * degToRads,
                                    i = t[2] * degToRads,
                                    r = Math.cos(e / 2),
                                    a = Math.cos(n / 2),
                                    s = Math.cos(i / 2),
                                    o = Math.sin(e / 2),
                                    l = Math.sin(n / 2),
                                    h = Math.sin(i / 2);
                                return [o * l * s + r * a * h, o * a * s + r * l * h, r * l * s - o * a * h, r * a * s - o * l * h]
                            }

                            function r() {
                                var e = this.comp.renderedFrame - this.offsetTime,
                                    n = this.keyframes[0].t - this.offsetTime,
                                    i = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
                                if (!(e === this._caching.lastFrame || this._caching.lastFrame !== t && (this._caching.lastFrame >= i && e >= i || this._caching.lastFrame < n && e < n))) {
                                    this._caching.lastFrame >= e && (this._caching._lastKeyframeIndex = -1, this._caching.lastIndex = 0);
                                    var r = this.interpolateValue(e, this._caching);
                                    this.pv = r
                                }
                                return this._caching.lastFrame = e, this.pv
                            }

                            function a(t) {
                                var n;
                                if ("unidimensional" === this.propType) n = t * this.mult, e(this.v - n) > 1e-5 && (this.v = n, this._mdf = !0);
                                else
                                    for (var i = 0, r = this.v.length; i < r;) n = t[i] * this.mult, e(this.v[i] - n) > 1e-5 && (this.v[i] = n, this._mdf = !0), i += 1
                            }

                            function s() {
                                if (this.elem.globalData.frameId !== this.frameId && this.effectsSequence.length)
                                    if (this.lock) this.setVValue(this.pv);
                                    else {
                                        this.lock = !0, this._mdf = this._isFirstFrame;
                                        var t, e = this.effectsSequence.length,
                                            n = this.kf ? this.pv : this.data.k;
                                        for (t = 0; t < e; t += 1) n = this.effectsSequence[t](n);
                                        this.setVValue(n), this._isFirstFrame = !1, this.lock = !1, this.frameId = this.elem.globalData.frameId
                                    }
                            }

                            function o(t) {
                                this.effectsSequence.push(t), this.container.addDynamicProperty(this)
                            }

                            function l(t, e, n, i) {
                                this.propType = "unidimensional", this.mult = n || 1, this.data = e, this.v = n ? e.k * n : e.k, this.pv = e.k, this._mdf = !1, this.elem = t, this.container = i, this.comp = t.comp, this.k = !1, this.kf = !1, this.vel = 0, this.effectsSequence = [], this._isFirstFrame = !0, this.getValue = s, this.setVValue = a, this.addEffect = o
                            }

                            function h(t, e, n, i) {
                                this.propType = "multidimensional", this.mult = n || 1, this.data = e, this._mdf = !1, this.elem = t, this.container = i, this.comp = t.comp, this.k = !1, this.kf = !1, this.frameId = -1;
                                var r, l = e.k.length;
                                this.v = createTypedArray("float32", l), this.pv = createTypedArray("float32", l);
                                createTypedArray("float32", l);
                                for (this.vel = createTypedArray("float32", l), r = 0; r < l; r += 1) this.v[r] = e.k[r] * this.mult, this.pv[r] = e.k[r];
                                this._isFirstFrame = !0, this.effectsSequence = [], this.getValue = s, this.setVValue = a, this.addEffect = o
                            }

                            function u(e, i, l, h) {
                                this.propType = "unidimensional", this.keyframes = i.k, this.offsetTime = e.data.st, this.frameId = -1, this._caching = {
                                    lastFrame: t,
                                    lastIndex: 0,
                                    value: 0,
                                    _lastKeyframeIndex: -1
                                }, this.k = !0, this.kf = !0, this.data = i, this.mult = l || 1, this.elem = e, this.container = h, this.comp = e.comp, this.v = t, this.pv = t, this._isFirstFrame = !0, this.getValue = s, this.setVValue = a, this.interpolateValue = n, this.effectsSequence = [r.bind(this)], this.addEffect = o
                            }

                            function c(e, i, l, h) {
                                this.propType = "multidimensional";
                                var u, c, p, f, d, m = i.k.length;
                                for (u = 0; u < m - 1; u += 1) i.k[u].to && i.k[u].s && i.k[u + 1] && i.k[u + 1].s && (c = i.k[u].s, p = i.k[u + 1].s, f = i.k[u].to, d = i.k[u].ti, (2 === c.length && (c[0] !== p[0] || c[1] !== p[1]) && bez.pointOnLine2D(c[0], c[1], p[0], p[1], c[0] + f[0], c[1] + f[1]) && bez.pointOnLine2D(c[0], c[1], p[0], p[1], p[0] + d[0], p[1] + d[1]) || 3 === c.length && (c[0] !== p[0] || c[1] !== p[1] || c[2] !== p[2]) && bez.pointOnLine3D(c[0], c[1], c[2], p[0], p[1], p[2], c[0] + f[0], c[1] + f[1], c[2] + f[2]) && bez.pointOnLine3D(c[0], c[1], c[2], p[0], p[1], p[2], p[0] + d[0], p[1] + d[1], p[2] + d[2])) && (i.k[u].to = null, i.k[u].ti = null), c[0] === p[0] && c[1] === p[1] && 0 === f[0] && 0 === f[1] && 0 === d[0] && 0 === d[1] && (2 === c.length || c[2] === p[2] && 0 === f[2] && 0 === d[2]) && (i.k[u].to = null, i.k[u].ti = null));
                                this.effectsSequence = [r.bind(this)], this.data = i, this.keyframes = i.k, this.offsetTime = e.data.st, this.k = !0, this.kf = !0, this._isFirstFrame = !0, this.mult = l || 1, this.elem = e, this.container = h, this.comp = e.comp, this.getValue = s, this.setVValue = a, this.interpolateValue = n, this.frameId = -1;
                                var g = i.k[0].s.length;
                                for (this.v = createTypedArray("float32", g), this.pv = createTypedArray("float32", g), u = 0; u < g; u += 1) this.v[u] = t, this.pv[u] = t;
                                this._caching = {
                                    lastFrame: t,
                                    lastIndex: 0,
                                    value: createTypedArray("float32", g)
                                }, this.addEffect = o
                            }
                            return {
                                getProp: function(t, e, n, i, r) {
                                    var a;
                                    if (e.k.length)
                                        if ("number" == typeof e.k[0]) a = new h(t, e, i, r);
                                        else switch (n) {
                                            case 0:
                                                a = new u(t, e, i, r);
                                                break;
                                            case 1:
                                                a = new c(t, e, i, r)
                                        } else a = new l(t, e, i, r);
                                    return a.effectsSequence.length && r.addDynamicProperty(a), a
                                }
                            }
                        }(),
                        TransformPropertyFactory = function() {
                            var t = [0, 0];

                            function e(t, e, n) {
                                if (this.elem = t, this.frameId = -1, this.propType = "transform", this.data = e, this.v = new Matrix, this.pre = new Matrix, this.appliedTransformations = 0, this.initDynamicPropertyContainer(n || t), e.p && e.p.s ? (this.px = PropertyFactory.getProp(t, e.p.x, 0, 0, this), this.py = PropertyFactory.getProp(t, e.p.y, 0, 0, this), e.p.z && (this.pz = PropertyFactory.getProp(t, e.p.z, 0, 0, this))) : this.p = PropertyFactory.getProp(t, e.p || {
                                        k: [0, 0, 0]
                                    }, 1, 0, this), e.rx) {
                                    if (this.rx = PropertyFactory.getProp(t, e.rx, 0, degToRads, this), this.ry = PropertyFactory.getProp(t, e.ry, 0, degToRads, this), this.rz = PropertyFactory.getProp(t, e.rz, 0, degToRads, this), e.or.k[0].ti) {
                                        var i, r = e.or.k.length;
                                        for (i = 0; i < r; i += 1) e.or.k[i].to = e.or.k[i].ti = null
                                    }
                                    this.or = PropertyFactory.getProp(t, e.or, 1, degToRads, this), this.or.sh = !0
                                } else this.r = PropertyFactory.getProp(t, e.r || {
                                    k: 0
                                }, 0, degToRads, this);
                                e.sk && (this.sk = PropertyFactory.getProp(t, e.sk, 0, degToRads, this), this.sa = PropertyFactory.getProp(t, e.sa, 0, degToRads, this)), this.a = PropertyFactory.getProp(t, e.a || {
                                    k: [0, 0, 0]
                                }, 1, 0, this), this.s = PropertyFactory.getProp(t, e.s || {
                                    k: [100, 100, 100]
                                }, 1, .01, this), e.o ? this.o = PropertyFactory.getProp(t, e.o, 0, .01, t) : this.o = {
                                    _mdf: !1,
                                    v: 1
                                }, this._isDirty = !0, this.dynamicProperties.length || this.getValue(!0)
                            }
                            return e.prototype = {
                                applyToMatrix: function(t) {
                                    var e = this._mdf;
                                    this.iterateDynamicProperties(), this._mdf = this._mdf || e, this.a && t.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.s && t.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && t.skewFromAxis(-this.sk.v, this.sa.v), this.r ? t.rotate(-this.r.v) : t.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.data.p.s ? this.data.p.z ? t.translate(this.px.v, this.py.v, -this.pz.v) : t.translate(this.px.v, this.py.v, 0) : t.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
                                },
                                getValue: function(e) {
                                    if (this.elem.globalData.frameId !== this.frameId) {
                                        if (this._isDirty && (this.precalculateMatrix(), this._isDirty = !1), this.iterateDynamicProperties(), this._mdf || e) {
                                            if (this.v.cloneFromProps(this.pre.props), this.appliedTransformations < 1 && this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations < 2 && this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && this.appliedTransformations < 3 && this.v.skewFromAxis(-this.sk.v, this.sa.v), this.r && this.appliedTransformations < 4 ? this.v.rotate(-this.r.v) : !this.r && this.appliedTransformations < 4 && this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.autoOriented) {
                                                var n, i, r = this.elem.globalData.frameRate;
                                                if (this.p && this.p.keyframes && this.p.getValueAtTime) this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t ? (n = this.p.getValueAtTime((this.p.keyframes[0].t + .01) / r, 0), i = this.p.getValueAtTime(this.p.keyframes[0].t / r, 0)) : this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t ? (n = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / r, 0), i = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - .05) / r, 0)) : (n = this.p.pv, i = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - .01) / r, this.p.offsetTime));
                                                else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                                                    n = [], i = [];
                                                    var a = this.px,
                                                        s = this.py;
                                                    a._caching.lastFrame + a.offsetTime <= a.keyframes[0].t ? (n[0] = a.getValueAtTime((a.keyframes[0].t + .01) / r, 0), n[1] = s.getValueAtTime((s.keyframes[0].t + .01) / r, 0), i[0] = a.getValueAtTime(a.keyframes[0].t / r, 0), i[1] = s.getValueAtTime(s.keyframes[0].t / r, 0)) : a._caching.lastFrame + a.offsetTime >= a.keyframes[a.keyframes.length - 1].t ? (n[0] = a.getValueAtTime(a.keyframes[a.keyframes.length - 1].t / r, 0), n[1] = s.getValueAtTime(s.keyframes[s.keyframes.length - 1].t / r, 0), i[0] = a.getValueAtTime((a.keyframes[a.keyframes.length - 1].t - .01) / r, 0), i[1] = s.getValueAtTime((s.keyframes[s.keyframes.length - 1].t - .01) / r, 0)) : (n = [a.pv, s.pv], i[0] = a.getValueAtTime((a._caching.lastFrame + a.offsetTime - .01) / r, a.offsetTime), i[1] = s.getValueAtTime((s._caching.lastFrame + s.offsetTime - .01) / r, s.offsetTime))
                                                } else n = i = t;
                                                this.v.rotate(-Math.atan2(n[1] - i[1], n[0] - i[0]))
                                            }
                                            this.data.p && this.data.p.s ? this.data.p.z ? this.v.translate(this.px.v, this.py.v, -this.pz.v) : this.v.translate(this.px.v, this.py.v, 0) : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
                                        }
                                        this.frameId = this.elem.globalData.frameId
                                    }
                                },
                                precalculateMatrix: function() {
                                    if (!this.a.k && (this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations = 1, !this.s.effectsSequence.length)) {
                                        if (this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.appliedTransformations = 2, this.sk) {
                                            if (this.sk.effectsSequence.length || this.sa.effectsSequence.length) return;
                                            this.pre.skewFromAxis(-this.sk.v, this.sa.v), this.appliedTransformations = 3
                                        }
                                        if (this.r) {
                                            if (this.r.effectsSequence.length) return;
                                            this.pre.rotate(-this.r.v), this.appliedTransformations = 4
                                        } else this.rz.effectsSequence.length || this.ry.effectsSequence.length || this.rx.effectsSequence.length || this.or.effectsSequence.length || (this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.appliedTransformations = 4)
                                    }
                                },
                                autoOrient: function() {}
                            }, extendPrototype([DynamicPropertyContainer], e), e.prototype.addDynamicProperty = function(t) {
                                this._addDynamicProperty(t), this.elem.addDynamicProperty(t), this._isDirty = !0
                            }, e.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty, {
                                getTransformProperty: function(t, n, i) {
                                    return new e(t, n, i)
                                }
                            }
                        }();

                    function ShapePath() {
                        this.c = !1, this._length = 0, this._maxLength = 8, this.v = createSizedArray(this._maxLength), this.o = createSizedArray(this._maxLength), this.i = createSizedArray(this._maxLength)
                    }
                    ShapePath.prototype.setPathData = function(t, e) {
                        this.c = t, this.setLength(e);
                        for (var n = 0; n < e;) this.v[n] = point_pool.newElement(), this.o[n] = point_pool.newElement(), this.i[n] = point_pool.newElement(), n += 1
                    }, ShapePath.prototype.setLength = function(t) {
                        for (; this._maxLength < t;) this.doubleArrayLength();
                        this._length = t
                    }, ShapePath.prototype.doubleArrayLength = function() {
                        this.v = this.v.concat(createSizedArray(this._maxLength)), this.i = this.i.concat(createSizedArray(this._maxLength)), this.o = this.o.concat(createSizedArray(this._maxLength)), this._maxLength *= 2
                    }, ShapePath.prototype.setXYAt = function(t, e, n, i, r) {
                        var a;
                        switch (this._length = Math.max(this._length, i + 1), this._length >= this._maxLength && this.doubleArrayLength(), n) {
                            case "v":
                                a = this.v;
                                break;
                            case "i":
                                a = this.i;
                                break;
                            case "o":
                                a = this.o
                        }(!a[i] || a[i] && !r) && (a[i] = point_pool.newElement()), a[i][0] = t, a[i][1] = e
                    }, ShapePath.prototype.setTripleAt = function(t, e, n, i, r, a, s, o) {
                        this.setXYAt(t, e, "v", s, o), this.setXYAt(n, i, "o", s, o), this.setXYAt(r, a, "i", s, o)
                    }, ShapePath.prototype.reverse = function() {
                        var t = new ShapePath;
                        t.setPathData(this.c, this._length);
                        var e = this.v,
                            n = this.o,
                            i = this.i,
                            r = 0;
                        this.c && (t.setTripleAt(e[0][0], e[0][1], i[0][0], i[0][1], n[0][0], n[0][1], 0, !1), r = 1);
                        var a, s = this._length - 1,
                            o = this._length;
                        for (a = r; a < o; a += 1) t.setTripleAt(e[s][0], e[s][1], i[s][0], i[s][1], n[s][0], n[s][1], a, !1), s -= 1;
                        return t
                    };
                    var ShapePropertyFactory = function() {
                            function t(t, e, n) {
                                var i, r, a, s, o, l, h, u, c, p = n.lastIndex,
                                    f = this.keyframes;
                                if (t < f[0].t - this.offsetTime) i = f[0].s[0], a = !0, p = 0;
                                else if (t >= f[f.length - 1].t - this.offsetTime) i = f[f.length - 1].s ? f[f.length - 1].s[0] : f[f.length - 2].e[0], a = !0;
                                else {
                                    for (var d, m, g = p, v = f.length - 1, y = !0; y && (d = f[g], !((m = f[g + 1]).t - this.offsetTime > t));) g < v - 1 ? g += 1 : y = !1;
                                    if (p = g, !(a = 1 === d.h)) {
                                        if (t >= m.t - this.offsetTime) u = 1;
                                        else if (t < d.t - this.offsetTime) u = 0;
                                        else {
                                            var _;
                                            d.__fnct ? _ = d.__fnct : (_ = BezierFactory.getBezierEasing(d.o.x, d.o.y, d.i.x, d.i.y).get, d.__fnct = _), u = _((t - (d.t - this.offsetTime)) / (m.t - this.offsetTime - (d.t - this.offsetTime)))
                                        }
                                        r = m.s ? m.s[0] : d.e[0]
                                    }
                                    i = d.s[0]
                                }
                                for (l = e._length, h = i.i[0].length, n.lastIndex = p, s = 0; s < l; s += 1)
                                    for (o = 0; o < h; o += 1) c = a ? i.i[s][o] : i.i[s][o] + (r.i[s][o] - i.i[s][o]) * u, e.i[s][o] = c, c = a ? i.o[s][o] : i.o[s][o] + (r.o[s][o] - i.o[s][o]) * u, e.o[s][o] = c, c = a ? i.v[s][o] : i.v[s][o] + (r.v[s][o] - i.v[s][o]) * u, e.v[s][o] = c
                            }

                            function e() {
                                var t = this.comp.renderedFrame - this.offsetTime,
                                    e = this.keyframes[0].t - this.offsetTime,
                                    n = this.keyframes[this.keyframes.length - 1].t - this.offsetTime,
                                    i = this._caching.lastFrame;
                                return -999999 !== i && (i < e && t < e || i > n && t > n) || (this._caching.lastIndex = i < t ? this._caching.lastIndex : 0, this.interpolateShape(t, this.pv, this._caching)), this._caching.lastFrame = t, this.pv
                            }

                            function n() {
                                this.paths = this.localShapeCollection
                            }

                            function i(t) {
                                (function(t, e) {
                                    if (t._length !== e._length || t.c !== e.c) return !1;
                                    var n, i = t._length;
                                    for (n = 0; n < i; n += 1)
                                        if (t.v[n][0] !== e.v[n][0] || t.v[n][1] !== e.v[n][1] || t.o[n][0] !== e.o[n][0] || t.o[n][1] !== e.o[n][1] || t.i[n][0] !== e.i[n][0] || t.i[n][1] !== e.i[n][1]) return !1;
                                    return !0
                                })(this.v, t) || (this.v = shape_pool.clone(t), this.localShapeCollection.releaseShapes(), this.localShapeCollection.addShape(this.v), this._mdf = !0, this.paths = this.localShapeCollection)
                            }

                            function r() {
                                if (this.elem.globalData.frameId !== this.frameId)
                                    if (this.effectsSequence.length)
                                        if (this.lock) this.setVValue(this.pv);
                                        else {
                                            this.lock = !0, this._mdf = !1;
                                            var t, e = this.kf ? this.pv : this.data.ks ? this.data.ks.k : this.data.pt.k,
                                                n = this.effectsSequence.length;
                                            for (t = 0; t < n; t += 1) e = this.effectsSequence[t](e);
                                            this.setVValue(e), this.lock = !1, this.frameId = this.elem.globalData.frameId
                                        }
                                else this._mdf = !1
                            }

                            function a(t, e, i) {
                                this.propType = "shape", this.comp = t.comp, this.container = t, this.elem = t, this.data = e, this.k = !1, this.kf = !1, this._mdf = !1;
                                var r = 3 === i ? e.pt.k : e.ks.k;
                                this.v = shape_pool.clone(r), this.pv = shape_pool.clone(this.v), this.localShapeCollection = shapeCollection_pool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.reset = n, this.effectsSequence = []
                            }

                            function s(t) {
                                this.effectsSequence.push(t), this.container.addDynamicProperty(this)
                            }

                            function o(t, i, r) {
                                this.propType = "shape", this.comp = t.comp, this.elem = t, this.container = t, this.offsetTime = t.data.st, this.keyframes = 3 === r ? i.pt.k : i.ks.k, this.k = !0, this.kf = !0;
                                var a = this.keyframes[0].s[0].i.length;
                                this.keyframes[0].s[0].i[0].length;
                                this.v = shape_pool.newElement(), this.v.setPathData(this.keyframes[0].s[0].c, a), this.pv = shape_pool.clone(this.v), this.localShapeCollection = shapeCollection_pool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.lastFrame = -999999, this.reset = n, this._caching = {
                                    lastFrame: -999999,
                                    lastIndex: 0
                                }, this.effectsSequence = [e.bind(this)]
                            }
                            a.prototype.interpolateShape = t, a.prototype.getValue = r, a.prototype.setVValue = i, a.prototype.addEffect = s, o.prototype.getValue = r, o.prototype.interpolateShape = t, o.prototype.setVValue = i, o.prototype.addEffect = s;
                            var l = function() {
                                    var t = roundCorner;

                                    function e(t, e) {
                                        this.v = shape_pool.newElement(), this.v.setPathData(!0, 4), this.localShapeCollection = shapeCollection_pool.newShapeCollection(), this.paths = this.localShapeCollection, this.localShapeCollection.addShape(this.v), this.d = e.d, this.elem = t, this.comp = t.comp, this.frameId = -1, this.initDynamicPropertyContainer(t), this.p = PropertyFactory.getProp(t, e.p, 1, 0, this), this.s = PropertyFactory.getProp(t, e.s, 1, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertEllToPath())
                                    }
                                    return e.prototype = {
                                        reset: n,
                                        getValue: function() {
                                            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertEllToPath())
                                        },
                                        convertEllToPath: function() {
                                            var e = this.p.v[0],
                                                n = this.p.v[1],
                                                i = this.s.v[0] / 2,
                                                r = this.s.v[1] / 2,
                                                a = 3 !== this.d,
                                                s = this.v;
                                            s.v[0][0] = e, s.v[0][1] = n - r, s.v[1][0] = a ? e + i : e - i, s.v[1][1] = n, s.v[2][0] = e, s.v[2][1] = n + r, s.v[3][0] = a ? e - i : e + i, s.v[3][1] = n, s.i[0][0] = a ? e - i * t : e + i * t, s.i[0][1] = n - r, s.i[1][0] = a ? e + i : e - i, s.i[1][1] = n - r * t, s.i[2][0] = a ? e + i * t : e - i * t, s.i[2][1] = n + r, s.i[3][0] = a ? e - i : e + i, s.i[3][1] = n + r * t, s.o[0][0] = a ? e + i * t : e - i * t, s.o[0][1] = n - r, s.o[1][0] = a ? e + i : e - i, s.o[1][1] = n + r * t, s.o[2][0] = a ? e - i * t : e + i * t, s.o[2][1] = n + r, s.o[3][0] = a ? e - i : e + i, s.o[3][1] = n - r * t
                                        }
                                    }, extendPrototype([DynamicPropertyContainer], e), e
                                }(),
                                h = function() {
                                    function t(t, e) {
                                        this.v = shape_pool.newElement(), this.v.setPathData(!0, 0), this.elem = t, this.comp = t.comp, this.data = e, this.frameId = -1, this.d = e.d, this.initDynamicPropertyContainer(t), 1 === e.sy ? (this.ir = PropertyFactory.getProp(t, e.ir, 0, 0, this), this.is = PropertyFactory.getProp(t, e.is, 0, .01, this), this.convertToPath = this.convertStarToPath) : this.convertToPath = this.convertPolygonToPath, this.pt = PropertyFactory.getProp(t, e.pt, 0, 0, this), this.p = PropertyFactory.getProp(t, e.p, 1, 0, this), this.r = PropertyFactory.getProp(t, e.r, 0, degToRads, this), this.or = PropertyFactory.getProp(t, e.or, 0, 0, this), this.os = PropertyFactory.getProp(t, e.os, 0, .01, this), this.localShapeCollection = shapeCollection_pool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertToPath())
                                    }
                                    return t.prototype = {
                                        reset: n,
                                        getValue: function() {
                                            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertToPath())
                                        },
                                        convertStarToPath: function() {
                                            var t, e, n, i, r = 2 * Math.floor(this.pt.v),
                                                a = 2 * Math.PI / r,
                                                s = !0,
                                                o = this.or.v,
                                                l = this.ir.v,
                                                h = this.os.v,
                                                u = this.is.v,
                                                c = 2 * Math.PI * o / (2 * r),
                                                p = 2 * Math.PI * l / (2 * r),
                                                f = -Math.PI / 2;
                                            f += this.r.v;
                                            var d = 3 === this.data.d ? -1 : 1;
                                            for (this.v._length = 0, t = 0; t < r; t += 1) {
                                                n = s ? h : u, i = s ? c : p;
                                                var m = (e = s ? o : l) * Math.cos(f),
                                                    g = e * Math.sin(f),
                                                    v = 0 === m && 0 === g ? 0 : g / Math.sqrt(m * m + g * g),
                                                    y = 0 === m && 0 === g ? 0 : -m / Math.sqrt(m * m + g * g);
                                                m += +this.p.v[0], g += +this.p.v[1], this.v.setTripleAt(m, g, m - v * i * n * d, g - y * i * n * d, m + v * i * n * d, g + y * i * n * d, t, !0), s = !s, f += a * d
                                            }
                                        },
                                        convertPolygonToPath: function() {
                                            var t, e = Math.floor(this.pt.v),
                                                n = 2 * Math.PI / e,
                                                i = this.or.v,
                                                r = this.os.v,
                                                a = 2 * Math.PI * i / (4 * e),
                                                s = -Math.PI / 2,
                                                o = 3 === this.data.d ? -1 : 1;
                                            for (s += this.r.v, this.v._length = 0, t = 0; t < e; t += 1) {
                                                var l = i * Math.cos(s),
                                                    h = i * Math.sin(s),
                                                    u = 0 === l && 0 === h ? 0 : h / Math.sqrt(l * l + h * h),
                                                    c = 0 === l && 0 === h ? 0 : -l / Math.sqrt(l * l + h * h);
                                                l += +this.p.v[0], h += +this.p.v[1], this.v.setTripleAt(l, h, l - u * a * r * o, h - c * a * r * o, l + u * a * r * o, h + c * a * r * o, t, !0), s += n * o
                                            }
                                            this.paths.length = 0, this.paths[0] = this.v
                                        }
                                    }, extendPrototype([DynamicPropertyContainer], t), t
                                }(),
                                u = function() {
                                    function t(t, e) {
                                        this.v = shape_pool.newElement(), this.v.c = !0, this.localShapeCollection = shapeCollection_pool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.elem = t, this.comp = t.comp, this.frameId = -1, this.d = e.d, this.initDynamicPropertyContainer(t), this.p = PropertyFactory.getProp(t, e.p, 1, 0, this), this.s = PropertyFactory.getProp(t, e.s, 1, 0, this), this.r = PropertyFactory.getProp(t, e.r, 0, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertRectToPath())
                                    }
                                    return t.prototype = {
                                        convertRectToPath: function() {
                                            var t = this.p.v[0],
                                                e = this.p.v[1],
                                                n = this.s.v[0] / 2,
                                                i = this.s.v[1] / 2,
                                                r = bm_min(n, i, this.r.v),
                                                a = r * (1 - roundCorner);
                                            this.v._length = 0, 2 === this.d || 1 === this.d ? (this.v.setTripleAt(t + n, e - i + r, t + n, e - i + r, t + n, e - i + a, 0, !0), this.v.setTripleAt(t + n, e + i - r, t + n, e + i - a, t + n, e + i - r, 1, !0), 0 !== r ? (this.v.setTripleAt(t + n - r, e + i, t + n - r, e + i, t + n - a, e + i, 2, !0), this.v.setTripleAt(t - n + r, e + i, t - n + a, e + i, t - n + r, e + i, 3, !0), this.v.setTripleAt(t - n, e + i - r, t - n, e + i - r, t - n, e + i - a, 4, !0), this.v.setTripleAt(t - n, e - i + r, t - n, e - i + a, t - n, e - i + r, 5, !0), this.v.setTripleAt(t - n + r, e - i, t - n + r, e - i, t - n + a, e - i, 6, !0), this.v.setTripleAt(t + n - r, e - i, t + n - a, e - i, t + n - r, e - i, 7, !0)) : (this.v.setTripleAt(t - n, e + i, t - n + a, e + i, t - n, e + i, 2), this.v.setTripleAt(t - n, e - i, t - n, e - i + a, t - n, e - i, 3))) : (this.v.setTripleAt(t + n, e - i + r, t + n, e - i + a, t + n, e - i + r, 0, !0), 0 !== r ? (this.v.setTripleAt(t + n - r, e - i, t + n - r, e - i, t + n - a, e - i, 1, !0), this.v.setTripleAt(t - n + r, e - i, t - n + a, e - i, t - n + r, e - i, 2, !0), this.v.setTripleAt(t - n, e - i + r, t - n, e - i + r, t - n, e - i + a, 3, !0), this.v.setTripleAt(t - n, e + i - r, t - n, e + i - a, t - n, e + i - r, 4, !0), this.v.setTripleAt(t - n + r, e + i, t - n + r, e + i, t - n + a, e + i, 5, !0), this.v.setTripleAt(t + n - r, e + i, t + n - a, e + i, t + n - r, e + i, 6, !0), this.v.setTripleAt(t + n, e + i - r, t + n, e + i - r, t + n, e + i - a, 7, !0)) : (this.v.setTripleAt(t - n, e - i, t - n + a, e - i, t - n, e - i, 1, !0), this.v.setTripleAt(t - n, e + i, t - n, e + i - a, t - n, e + i, 2, !0), this.v.setTripleAt(t + n, e + i, t + n - a, e + i, t + n, e + i, 3, !0)))
                                        },
                                        getValue: function(t) {
                                            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertRectToPath())
                                        },
                                        reset: n
                                    }, extendPrototype([DynamicPropertyContainer], t), t
                                }();
                            var c = {
                                getShapeProp: function(t, e, n) {
                                    var i;
                                    return 3 === n || 4 === n ? i = (3 === n ? e.pt : e.ks).k.length ? new o(t, e, n) : new a(t, e, n) : 5 === n ? i = new u(t, e) : 6 === n ? i = new l(t, e) : 7 === n && (i = new h(t, e)), i.k && t.addDynamicProperty(i), i
                                },
                                getConstructorFunction: function() {
                                    return a
                                },
                                getKeyframedConstructorFunction: function() {
                                    return o
                                }
                            };
                            return c
                        }(),
                        ShapeModifiers = (ob = {}, modifiers = {}, ob.registerModifier = function(t, e) {
                            modifiers[t] || (modifiers[t] = e)
                        }, ob.getModifier = function(t, e, n) {
                            return new modifiers[t](e, n)
                        }, ob),
                        ob, modifiers;

                    function ShapeModifier() {}

                    function TrimModifier() {}

                    function RoundCornersModifier() {}

                    function PuckerAndBloatModifier() {}

                    function RepeaterModifier() {}

                    function ShapeCollection() {
                        this._length = 0, this._maxLength = 4, this.shapes = createSizedArray(this._maxLength)
                    }

                    function DashProperty(t, e, n, i) {
                        this.elem = t, this.frameId = -1, this.dataProps = createSizedArray(e.length), this.renderer = n, this.k = !1, this.dashStr = "", this.dashArray = createTypedArray("float32", e.length ? e.length - 1 : 0), this.dashoffset = createTypedArray("float32", 1), this.initDynamicPropertyContainer(i);
                        var r, a, s = e.length || 0;
                        for (r = 0; r < s; r += 1) a = PropertyFactory.getProp(t, e[r].v, 0, 0, this), this.k = a.k || this.k, this.dataProps[r] = {
                            n: e[r].n,
                            p: a
                        };
                        this.k || this.getValue(!0), this._isAnimated = this.k
                    }

                    function GradientProperty(t, e, n) {
                        this.data = e, this.c = createTypedArray("uint8c", 4 * e.p);
                        var i = e.k.k[0].s ? e.k.k[0].s.length - 4 * e.p : e.k.k.length - 4 * e.p;
                        this.o = createTypedArray("float32", i), this._cmdf = !1, this._omdf = !1, this._collapsable = this.checkCollapsable(), this._hasOpacity = i, this.initDynamicPropertyContainer(n), this.prop = PropertyFactory.getProp(t, e.k, 1, null, this), this.k = this.prop.k, this.getValue(!0)
                    }
                    ShapeModifier.prototype.initModifierProperties = function() {}, ShapeModifier.prototype.addShapeToModifier = function() {}, ShapeModifier.prototype.addShape = function(t) {
                        if (!this.closed) {
                            t.sh.container.addDynamicProperty(t.sh);
                            var e = {
                                shape: t.sh,
                                data: t,
                                localShapeCollection: shapeCollection_pool.newShapeCollection()
                            };
                            this.shapes.push(e), this.addShapeToModifier(e), this._isAnimated && t.setAsAnimated()
                        }
                    }, ShapeModifier.prototype.init = function(t, e) {
                        this.shapes = [], this.elem = t, this.initDynamicPropertyContainer(t), this.initModifierProperties(t, e), this.frameId = initialDefaultFrame, this.closed = !1, this.k = !1, this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
                    }, ShapeModifier.prototype.processKeys = function() {
                        this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties())
                    }, extendPrototype([DynamicPropertyContainer], ShapeModifier), extendPrototype([ShapeModifier], TrimModifier), TrimModifier.prototype.initModifierProperties = function(t, e) {
                        this.s = PropertyFactory.getProp(t, e.s, 0, .01, this), this.e = PropertyFactory.getProp(t, e.e, 0, .01, this), this.o = PropertyFactory.getProp(t, e.o, 0, 0, this), this.sValue = 0, this.eValue = 0, this.getValue = this.processKeys, this.m = e.m, this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length
                    }, TrimModifier.prototype.addShapeToModifier = function(t) {
                        t.pathsData = []
                    }, TrimModifier.prototype.calculateShapeEdges = function(t, e, n, i, r) {
                        var a = [];
                        e <= 1 ? a.push({
                            s: t,
                            e: e
                        }) : t >= 1 ? a.push({
                            s: t - 1,
                            e: e - 1
                        }) : (a.push({
                            s: t,
                            e: 1
                        }), a.push({
                            s: 0,
                            e: e - 1
                        }));
                        var s, o, l = [],
                            h = a.length;
                        for (s = 0; s < h; s += 1) {
                            var u, c;
                            if ((o = a[s]).e * r < i || o.s * r > i + n);
                            else u = o.s * r <= i ? 0 : (o.s * r - i) / n, c = o.e * r >= i + n ? 1 : (o.e * r - i) / n, l.push([u, c])
                        }
                        return l.length || l.push([0, 0]), l
                    }, TrimModifier.prototype.releasePathsData = function(t) {
                        var e, n = t.length;
                        for (e = 0; e < n; e += 1) segments_length_pool.release(t[e]);
                        return t.length = 0, t
                    }, TrimModifier.prototype.processShapes = function(t) {
                        var e, n, i;
                        if (this._mdf || t) {
                            var r = this.o.v % 360 / 360;
                            if (r < 0 && (r += 1), (e = (this.s.v > 1 ? 1 : this.s.v < 0 ? 0 : this.s.v) + r) > (n = (this.e.v > 1 ? 1 : this.e.v < 0 ? 0 : this.e.v) + r)) {
                                var a = e;
                                e = n, n = a
                            }
                            e = 1e-4 * Math.round(1e4 * e), n = 1e-4 * Math.round(1e4 * n), this.sValue = e, this.eValue = n
                        } else e = this.sValue, n = this.eValue;
                        var s, o, l, h, u, c, p = this.shapes.length,
                            f = 0;
                        if (n === e)
                            for (s = 0; s < p; s += 1) this.shapes[s].localShapeCollection.releaseShapes(), this.shapes[s].shape._mdf = !0, this.shapes[s].shape.paths = this.shapes[s].localShapeCollection, this._mdf && (this.shapes[s].pathsData.length = 0);
                        else if (1 === n && 0 === e || 0 === n && 1 === e) {
                            if (this._mdf)
                                for (s = 0; s < p; s += 1) this.shapes[s].pathsData.length = 0, this.shapes[s].shape._mdf = !0
                        } else {
                            var d, m, g = [];
                            for (s = 0; s < p; s += 1)
                                if ((d = this.shapes[s]).shape._mdf || this._mdf || t || 2 === this.m) {
                                    if (l = (i = d.shape.paths)._length, c = 0, !d.shape._mdf && d.pathsData.length) c = d.totalShapeLength;
                                    else {
                                        for (h = this.releasePathsData(d.pathsData), o = 0; o < l; o += 1) u = bez.getSegmentsLength(i.shapes[o]), h.push(u), c += u.totalLength;
                                        d.totalShapeLength = c, d.pathsData = h
                                    }
                                    f += c, d.shape._mdf = !0
                                } else d.shape.paths = d.localShapeCollection;
                            var v, y = e,
                                _ = n,
                                x = 0;
                            for (s = p - 1; s >= 0; s -= 1)
                                if ((d = this.shapes[s]).shape._mdf) {
                                    for ((m = d.localShapeCollection).releaseShapes(), 2 === this.m && p > 1 ? (v = this.calculateShapeEdges(e, n, d.totalShapeLength, x, f), x += d.totalShapeLength) : v = [
                                            [y, _]
                                        ], l = v.length, o = 0; o < l; o += 1) {
                                        y = v[o][0], _ = v[o][1], g.length = 0, _ <= 1 ? g.push({
                                            s: d.totalShapeLength * y,
                                            e: d.totalShapeLength * _
                                        }) : y >= 1 ? g.push({
                                            s: d.totalShapeLength * (y - 1),
                                            e: d.totalShapeLength * (_ - 1)
                                        }) : (g.push({
                                            s: d.totalShapeLength * y,
                                            e: d.totalShapeLength
                                        }), g.push({
                                            s: 0,
                                            e: d.totalShapeLength * (_ - 1)
                                        }));
                                        var b = this.addShapes(d, g[0]);
                                        if (g[0].s !== g[0].e) {
                                            if (g.length > 1)
                                                if (d.shape.paths.shapes[d.shape.paths._length - 1].c) {
                                                    var E = b.pop();
                                                    this.addPaths(b, m), b = this.addShapes(d, g[1], E)
                                                } else this.addPaths(b, m), b = this.addShapes(d, g[1]);
                                            this.addPaths(b, m)
                                        }
                                    }
                                    d.shape.paths = m
                                }
                        }
                    }, TrimModifier.prototype.addPaths = function(t, e) {
                        var n, i = t.length;
                        for (n = 0; n < i; n += 1) e.addShape(t[n])
                    }, TrimModifier.prototype.addSegment = function(t, e, n, i, r, a, s) {
                        r.setXYAt(e[0], e[1], "o", a), r.setXYAt(n[0], n[1], "i", a + 1), s && r.setXYAt(t[0], t[1], "v", a), r.setXYAt(i[0], i[1], "v", a + 1)
                    }, TrimModifier.prototype.addSegmentFromArray = function(t, e, n, i) {
                        e.setXYAt(t[1], t[5], "o", n), e.setXYAt(t[2], t[6], "i", n + 1), i && e.setXYAt(t[0], t[4], "v", n), e.setXYAt(t[3], t[7], "v", n + 1)
                    }, TrimModifier.prototype.addShapes = function(t, e, n) {
                        var i, r, a, s, o, l, h, u, c = t.pathsData,
                            p = t.shape.paths.shapes,
                            f = t.shape.paths._length,
                            d = 0,
                            m = [],
                            g = !0;
                        for (n ? (o = n._length, u = n._length) : (n = shape_pool.newElement(), o = 0, u = 0), m.push(n), i = 0; i < f; i += 1) {
                            for (l = c[i].lengths, n.c = p[i].c, a = p[i].c ? l.length : l.length + 1, r = 1; r < a; r += 1)
                                if (d + (s = l[r - 1]).addedLength < e.s) d += s.addedLength, n.c = !1;
                                else {
                                    if (d > e.e) {
                                        n.c = !1;
                                        break
                                    }
                                    e.s <= d && e.e >= d + s.addedLength ? (this.addSegment(p[i].v[r - 1], p[i].o[r - 1], p[i].i[r], p[i].v[r], n, o, g), g = !1) : (h = bez.getNewSegment(p[i].v[r - 1], p[i].v[r], p[i].o[r - 1], p[i].i[r], (e.s - d) / s.addedLength, (e.e - d) / s.addedLength, l[r - 1]), this.addSegmentFromArray(h, n, o, g), g = !1, n.c = !1), d += s.addedLength, o += 1
                                }
                            if (p[i].c && l.length) {
                                if (s = l[r - 1], d <= e.e) {
                                    var v = l[r - 1].addedLength;
                                    e.s <= d && e.e >= d + v ? (this.addSegment(p[i].v[r - 1], p[i].o[r - 1], p[i].i[0], p[i].v[0], n, o, g), g = !1) : (h = bez.getNewSegment(p[i].v[r - 1], p[i].v[0], p[i].o[r - 1], p[i].i[0], (e.s - d) / v, (e.e - d) / v, l[r - 1]), this.addSegmentFromArray(h, n, o, g), g = !1, n.c = !1)
                                } else n.c = !1;
                                d += s.addedLength, o += 1
                            }
                            if (n._length && (n.setXYAt(n.v[u][0], n.v[u][1], "i", u), n.setXYAt(n.v[n._length - 1][0], n.v[n._length - 1][1], "o", n._length - 1)), d > e.e) break;
                            i < f - 1 && (n = shape_pool.newElement(), g = !0, m.push(n), o = 0)
                        }
                        return m
                    }, ShapeModifiers.registerModifier("tm", TrimModifier), extendPrototype([ShapeModifier], RoundCornersModifier), RoundCornersModifier.prototype.initModifierProperties = function(t, e) {
                        this.getValue = this.processKeys, this.rd = PropertyFactory.getProp(t, e.r, 0, null, this), this._isAnimated = !!this.rd.effectsSequence.length
                    }, RoundCornersModifier.prototype.processPath = function(t, e) {
                        var n = shape_pool.newElement();
                        n.c = t.c;
                        var i, r, a, s, o, l, h, u, c, p, f, d, m, g = t._length,
                            v = 0;
                        for (i = 0; i < g; i += 1) r = t.v[i], s = t.o[i], a = t.i[i], r[0] === s[0] && r[1] === s[1] && r[0] === a[0] && r[1] === a[1] ? 0 !== i && i !== g - 1 || t.c ? (o = 0 === i ? t.v[g - 1] : t.v[i - 1], h = (l = Math.sqrt(Math.pow(r[0] - o[0], 2) + Math.pow(r[1] - o[1], 2))) ? Math.min(l / 2, e) / l : 0, u = d = r[0] + (o[0] - r[0]) * h, c = m = r[1] - (r[1] - o[1]) * h, p = u - (u - r[0]) * roundCorner, f = c - (c - r[1]) * roundCorner, n.setTripleAt(u, c, p, f, d, m, v), v += 1, o = i === g - 1 ? t.v[0] : t.v[i + 1], h = (l = Math.sqrt(Math.pow(r[0] - o[0], 2) + Math.pow(r[1] - o[1], 2))) ? Math.min(l / 2, e) / l : 0, u = p = r[0] + (o[0] - r[0]) * h, c = f = r[1] + (o[1] - r[1]) * h, d = u - (u - r[0]) * roundCorner, m = c - (c - r[1]) * roundCorner, n.setTripleAt(u, c, p, f, d, m, v), v += 1) : (n.setTripleAt(r[0], r[1], s[0], s[1], a[0], a[1], v), v += 1) : (n.setTripleAt(t.v[i][0], t.v[i][1], t.o[i][0], t.o[i][1], t.i[i][0], t.i[i][1], v), v += 1);
                        return n
                    }, RoundCornersModifier.prototype.processShapes = function(t) {
                        var e, n, i, r, a, s, o = this.shapes.length,
                            l = this.rd.v;
                        if (0 !== l)
                            for (n = 0; n < o; n += 1) {
                                if ((a = this.shapes[n]).shape.paths, s = a.localShapeCollection, a.shape._mdf || this._mdf || t)
                                    for (s.releaseShapes(), a.shape._mdf = !0, e = a.shape.paths.shapes, r = a.shape.paths._length, i = 0; i < r; i += 1) s.addShape(this.processPath(e[i], l));
                                a.shape.paths = a.localShapeCollection
                            }
                        this.dynamicProperties.length || (this._mdf = !1)
                    }, ShapeModifiers.registerModifier("rd", RoundCornersModifier), extendPrototype([ShapeModifier], PuckerAndBloatModifier), PuckerAndBloatModifier.prototype.initModifierProperties = function(t, e) {
                        this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(t, e.a, 0, null, this), this._isAnimated = !!this.amount.effectsSequence.length
                    }, PuckerAndBloatModifier.prototype.processPath = function(t, e) {
                        var n = e / 100,
                            i = [0, 0],
                            r = t._length,
                            a = 0;
                        for (a = 0; a < r; a += 1) i[0] += t.v[a][0], i[1] += t.v[a][1];
                        i[0] /= r, i[1] /= r;
                        var s, o, l, h, u, c, p = shape_pool.newElement();
                        for (p.c = t.c, a = 0; a < r; a += 1) s = t.v[a][0] + (i[0] - t.v[a][0]) * n, o = t.v[a][1] + (i[1] - t.v[a][1]) * n, l = t.o[a][0] + (i[0] - t.o[a][0]) * -n, h = t.o[a][1] + (i[1] - t.o[a][1]) * -n, u = t.i[a][0] + (i[0] - t.i[a][0]) * -n, c = t.i[a][1] + (i[1] - t.i[a][1]) * -n, p.setTripleAt(s, o, l, h, u, c, a);
                        return p
                    }, PuckerAndBloatModifier.prototype.processShapes = function(t) {
                        var e, n, i, r, a, s, o = this.shapes.length,
                            l = this.amount.v;
                        if (0 !== l)
                            for (n = 0; n < o; n += 1) {
                                if ((a = this.shapes[n]).shape.paths, s = a.localShapeCollection, a.shape._mdf || this._mdf || t)
                                    for (s.releaseShapes(), a.shape._mdf = !0, e = a.shape.paths.shapes, r = a.shape.paths._length, i = 0; i < r; i += 1) s.addShape(this.processPath(e[i], l));
                                a.shape.paths = a.localShapeCollection
                            }
                        this.dynamicProperties.length || (this._mdf = !1)
                    }, ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier), extendPrototype([ShapeModifier], RepeaterModifier), RepeaterModifier.prototype.initModifierProperties = function(t, e) {
                        this.getValue = this.processKeys, this.c = PropertyFactory.getProp(t, e.c, 0, null, this), this.o = PropertyFactory.getProp(t, e.o, 0, null, this), this.tr = TransformPropertyFactory.getTransformProperty(t, e.tr, this), this.so = PropertyFactory.getProp(t, e.tr.so, 0, .01, this), this.eo = PropertyFactory.getProp(t, e.tr.eo, 0, .01, this), this.data = e, this.dynamicProperties.length || this.getValue(!0), this._isAnimated = !!this.dynamicProperties.length, this.pMatrix = new Matrix, this.rMatrix = new Matrix, this.sMatrix = new Matrix, this.tMatrix = new Matrix, this.matrix = new Matrix
                    }, RepeaterModifier.prototype.applyTransforms = function(t, e, n, i, r, a) {
                        var s = a ? -1 : 1,
                            o = i.s.v[0] + (1 - i.s.v[0]) * (1 - r),
                            l = i.s.v[1] + (1 - i.s.v[1]) * (1 - r);
                        t.translate(i.p.v[0] * s * r, i.p.v[1] * s * r, i.p.v[2]), e.translate(-i.a.v[0], -i.a.v[1], i.a.v[2]), e.rotate(-i.r.v * s * r), e.translate(i.a.v[0], i.a.v[1], i.a.v[2]), n.translate(-i.a.v[0], -i.a.v[1], i.a.v[2]), n.scale(a ? 1 / o : o, a ? 1 / l : l), n.translate(i.a.v[0], i.a.v[1], i.a.v[2])
                    }, RepeaterModifier.prototype.init = function(t, e, n, i) {
                        this.elem = t, this.arr = e, this.pos = n, this.elemsData = i, this._currentCopies = 0, this._elements = [], this._groups = [], this.frameId = -1, this.initDynamicPropertyContainer(t), this.initModifierProperties(t, e[n]);
                        for (; n > 0;) n -= 1, this._elements.unshift(e[n]), 1;
                        this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
                    }, RepeaterModifier.prototype.resetElements = function(t) {
                        var e, n = t.length;
                        for (e = 0; e < n; e += 1) t[e]._processed = !1, "gr" === t[e].ty && this.resetElements(t[e].it)
                    }, RepeaterModifier.prototype.cloneElements = function(t) {
                        t.length;
                        var e = JSON.parse(JSON.stringify(t));
                        return this.resetElements(e), e
                    }, RepeaterModifier.prototype.changeGroupRender = function(t, e) {
                        var n, i = t.length;
                        for (n = 0; n < i; n += 1) t[n]._render = e, "gr" === t[n].ty && this.changeGroupRender(t[n].it, e)
                    }, RepeaterModifier.prototype.processShapes = function(t) {
                        var e, n, i, r, a;
                        if (this._mdf || t) {
                            var s, o = Math.ceil(this.c.v);
                            if (this._groups.length < o) {
                                for (; this._groups.length < o;) {
                                    var l = {
                                        it: this.cloneElements(this._elements),
                                        ty: "gr"
                                    };
                                    l.it.push({
                                        a: {
                                            a: 0,
                                            ix: 1,
                                            k: [0, 0]
                                        },
                                        nm: "Transform",
                                        o: {
                                            a: 0,
                                            ix: 7,
                                            k: 100
                                        },
                                        p: {
                                            a: 0,
                                            ix: 2,
                                            k: [0, 0]
                                        },
                                        r: {
                                            a: 1,
                                            ix: 6,
                                            k: [{
                                                s: 0,
                                                e: 0,
                                                t: 0
                                            }, {
                                                s: 0,
                                                e: 0,
                                                t: 1
                                            }]
                                        },
                                        s: {
                                            a: 0,
                                            ix: 3,
                                            k: [100, 100]
                                        },
                                        sa: {
                                            a: 0,
                                            ix: 5,
                                            k: 0
                                        },
                                        sk: {
                                            a: 0,
                                            ix: 4,
                                            k: 0
                                        },
                                        ty: "tr"
                                    }), this.arr.splice(0, 0, l), this._groups.splice(0, 0, l), this._currentCopies += 1
                                }
                                this.elem.reloadShapes()
                            }
                            for (a = 0, i = 0; i <= this._groups.length - 1; i += 1) s = a < o, this._groups[i]._render = s, this.changeGroupRender(this._groups[i].it, s), a += 1;
                            this._currentCopies = o;
                            var h = this.o.v,
                                u = h % 1,
                                c = h > 0 ? Math.floor(h) : Math.ceil(h),
                                p = (this.tr.v.props, this.pMatrix.props),
                                f = this.rMatrix.props,
                                d = this.sMatrix.props;
                            this.pMatrix.reset(), this.rMatrix.reset(), this.sMatrix.reset(), this.tMatrix.reset(), this.matrix.reset();
                            var m, g, v = 0;
                            if (h > 0) {
                                for (; v < c;) this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), v += 1;
                                u && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, u, !1), v += u)
                            } else if (h < 0) {
                                for (; v > c;) this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0), v -= 1;
                                u && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -u, !0), v -= u)
                            }
                            for (i = 1 === this.data.m ? 0 : this._currentCopies - 1, r = 1 === this.data.m ? 1 : -1, a = this._currentCopies; a;) {
                                if (g = (n = (e = this.elemsData[i].it)[e.length - 1].transform.mProps.v.props).length, e[e.length - 1].transform.mProps._mdf = !0, e[e.length - 1].transform.op._mdf = !0, e[e.length - 1].transform.op.v = this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1)), 0 !== v) {
                                    for ((0 !== i && 1 === r || i !== this._currentCopies - 1 && -1 === r) && this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), this.matrix.transform(f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8], f[9], f[10], f[11], f[12], f[13], f[14], f[15]), this.matrix.transform(d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], d[8], d[9], d[10], d[11], d[12], d[13], d[14], d[15]), this.matrix.transform(p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]), m = 0; m < g; m += 1) n[m] = this.matrix.props[m];
                                    this.matrix.reset()
                                } else
                                    for (this.matrix.reset(), m = 0; m < g; m += 1) n[m] = this.matrix.props[m];
                                v += 1, a -= 1, i += r
                            }
                        } else
                            for (a = this._currentCopies, i = 0, r = 1; a;) n = (e = this.elemsData[i].it)[e.length - 1].transform.mProps.v.props, e[e.length - 1].transform.mProps._mdf = !1, e[e.length - 1].transform.op._mdf = !1, a -= 1, i += r
                    }, RepeaterModifier.prototype.addShape = function() {}, ShapeModifiers.registerModifier("rp", RepeaterModifier), ShapeCollection.prototype.addShape = function(t) {
                        this._length === this._maxLength && (this.shapes = this.shapes.concat(createSizedArray(this._maxLength)), this._maxLength *= 2), this.shapes[this._length] = t, this._length += 1
                    }, ShapeCollection.prototype.releaseShapes = function() {
                        var t;
                        for (t = 0; t < this._length; t += 1) shape_pool.release(this.shapes[t]);
                        this._length = 0
                    }, DashProperty.prototype.getValue = function(t) {
                        if ((this.elem.globalData.frameId !== this.frameId || t) && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf = this._mdf || t, this._mdf)) {
                            var e = 0,
                                n = this.dataProps.length;
                            for ("svg" === this.renderer && (this.dashStr = ""), e = 0; e < n; e += 1) "o" != this.dataProps[e].n ? "svg" === this.renderer ? this.dashStr += " " + this.dataProps[e].p.v : this.dashArray[e] = this.dataProps[e].p.v : this.dashoffset[0] = this.dataProps[e].p.v
                        }
                    }, extendPrototype([DynamicPropertyContainer], DashProperty), GradientProperty.prototype.comparePoints = function(t, e) {
                        for (var n = 0, i = this.o.length / 2; n < i;) {
                            if (Math.abs(t[4 * n] - t[4 * e + 2 * n]) > .01) return !1;
                            n += 1
                        }
                        return !0
                    }, GradientProperty.prototype.checkCollapsable = function() {
                        if (this.o.length / 2 != this.c.length / 4) return !1;
                        if (this.data.k.k[0].s)
                            for (var t = 0, e = this.data.k.k.length; t < e;) {
                                if (!this.comparePoints(this.data.k.k[t].s, this.data.p)) return !1;
                                t += 1
                            } else if (!this.comparePoints(this.data.k.k, this.data.p)) return !1;
                        return !0
                    }, GradientProperty.prototype.getValue = function(t) {
                        if (this.prop.getValue(), this._mdf = !1, this._cmdf = !1, this._omdf = !1, this.prop._mdf || t) {
                            var e, n, i, r = 4 * this.data.p;
                            for (e = 0; e < r; e += 1) n = e % 4 == 0 ? 100 : 255, i = Math.round(this.prop.v[e] * n), this.c[e] !== i && (this.c[e] = i, this._cmdf = !t);
                            if (this.o.length)
                                for (r = this.prop.v.length, e = 4 * this.data.p; e < r; e += 1) n = e % 2 == 0 ? 100 : 1, i = e % 2 == 0 ? Math.round(100 * this.prop.v[e]) : this.prop.v[e], this.o[e - 4 * this.data.p] !== i && (this.o[e - 4 * this.data.p] = i, this._omdf = !t);
                            this._mdf = !t
                        }
                    }, extendPrototype([DynamicPropertyContainer], GradientProperty);
                    var buildShapeString = function(t, e, n, i) {
                            if (0 === e) return "";
                            var r, a = t.o,
                                s = t.i,
                                o = t.v,
                                l = " M" + i.applyToPointStringified(o[0][0], o[0][1]);
                            for (r = 1; r < e; r += 1) l += " C" + i.applyToPointStringified(a[r - 1][0], a[r - 1][1]) + " " + i.applyToPointStringified(s[r][0], s[r][1]) + " " + i.applyToPointStringified(o[r][0], o[r][1]);
                            return n && e && (l += " C" + i.applyToPointStringified(a[r - 1][0], a[r - 1][1]) + " " + i.applyToPointStringified(s[0][0], s[0][1]) + " " + i.applyToPointStringified(o[0][0], o[0][1]), l += "z"), l
                        },
                        audioControllerFactory = function() {
                            function t(t) {
                                this.audios = [], this.audioFactory = t, this._volume = 1, this._isMuted = !1
                            }
                            return t.prototype = {
                                    addAudio: function(t) {
                                        this.audios.push(t)
                                    },
                                    pause: function() {
                                        var t, e = this.audios.length;
                                        for (t = 0; t < e; t += 1) this.audios[t].pause()
                                    },
                                    resume: function() {
                                        var t, e = this.audios.length;
                                        for (t = 0; t < e; t += 1) this.audios[t].resume()
                                    },
                                    setRate: function(t) {
                                        var e, n = this.audios.length;
                                        for (e = 0; e < n; e += 1) this.audios[e].setRate(t)
                                    },
                                    createAudio: function(t) {
                                        return this.audioFactory ? this.audioFactory(t) : Howl ? new Howl({
                                            src: [t]
                                        }) : {
                                            isPlaying: !1,
                                            play: function() {
                                                this.isPlaying = !0
                                            },
                                            seek: function() {
                                                this.isPlaying = !1
                                            },
                                            playing: function() {},
                                            rate: function() {},
                                            setVolume: function() {}
                                        }
                                    },
                                    setAudioFactory: function(t) {
                                        this.audioFactory = t
                                    },
                                    setVolume: function(t) {
                                        this._volume = t, this._updateVolume()
                                    },
                                    mute: function() {
                                        this._isMuted = !0, this._updateVolume()
                                    },
                                    unmute: function() {
                                        this._isMuted = !1, this._updateVolume()
                                    },
                                    getVolume: function(t) {
                                        return this._volume
                                    },
                                    _updateVolume: function() {
                                        var t, e = this.audios.length;
                                        for (t = 0; t < e; t += 1) this.audios[t].volume(this._volume * (this._isMuted ? 0 : 1))
                                    }
                                },
                                function() {
                                    return new t
                                }
                        }(),
                        ImagePreloader = function() {
                            var t = function() {
                                var t = createTag("canvas");
                                t.width = 1, t.height = 1;
                                var e = t.getContext("2d");
                                return e.fillStyle = "rgba(0,0,0,0)", e.fillRect(0, 0, 1, 1), t
                            }();

                            function e() {
                                this.loadedAssets += 1, this.loadedAssets === this.totalImages && this.imagesLoadedCb && this.imagesLoadedCb(null)
                            }

                            function n(t, e, n) {
                                var i = "";
                                if (t.e) i = t.p;
                                else if (e) {
                                    var r = t.p; - 1 !== r.indexOf("images/") && (r = r.split("/")[1]), i = e + r
                                } else i = n, i += t.u ? t.u : "", i += t.p;
                                return i
                            }

                            function i(t) {
                                var e = 0,
                                    n = setInterval(function() {
                                        (t.getBBox().width || e > 500) && (this._imageLoaded(), clearInterval(n)), e += 1
                                    }.bind(this), 50)
                            }

                            function r(t) {
                                this._imageLoaded = e.bind(this), this.testImageLoaded = i.bind(this), this.assetsPath = "", this.path = "", this.totalImages = 0, this.loadedAssets = 0, this.imagesLoadedCb = null, this.images = []
                            }
                            return r.prototype = {
                                loadAssets: function(t, e) {
                                    this.imagesLoadedCb = e;
                                    var n, i = t.length;
                                    for (n = 0; n < i; n += 1) t[n].layers || (this.totalImages += 1, this.images.push(this._createImageData(t[n])))
                                },
                                setAssetsPath: function(t) {
                                    this.assetsPath = t || ""
                                },
                                setPath: function(t) {
                                    this.path = t || ""
                                },
                                loaded: function() {
                                    return this.totalImages === this.loadedAssets
                                },
                                destroy: function() {
                                    this.imagesLoadedCb = null, this.images.length = 0
                                },
                                getImage: function(t) {
                                    for (var e = 0, n = this.images.length; e < n;) {
                                        if (this.images[e].assetData === t) return this.images[e].img;
                                        e += 1
                                    }
                                },
                                createImgData: function(e) {
                                    var i = n(e, this.assetsPath, this.path),
                                        r = createTag("img");
                                    r.crossOrigin = "anonymous", r.addEventListener("load", this._imageLoaded, !1), r.addEventListener("error", function() {
                                        a.img = t, this._imageLoaded()
                                    }.bind(this), !1), r.src = i;
                                    var a = {
                                        img: r,
                                        assetData: e
                                    };
                                    return a
                                },
                                createImageData: function(e) {
                                    var i = n(e, this.assetsPath, this.path),
                                        r = createNS("image");
                                    isSafari ? this.testImageLoaded(r) : r.addEventListener("load", this._imageLoaded, !1), r.addEventListener("error", function() {
                                        a.img = t, this._imageLoaded()
                                    }.bind(this), !1), r.setAttributeNS("http://www.w3.org/1999/xlink", "href", i), this._elementHelper.append(r);
                                    var a = {
                                        img: r,
                                        assetData: e
                                    };
                                    return a
                                },
                                imageLoaded: e,
                                setCacheType: function(t, e) {
                                    "svg" === t ? (this._elementHelper = e, this._createImageData = this.createImageData.bind(this)) : this._createImageData = this.createImgData.bind(this)
                                }
                            }, r
                        }(),
                        featureSupport = function() {
                            var t = {
                                maskType: !0
                            };
                            return (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) && (t.maskType = !1), t
                        }(),
                        filtersFactory = function() {
                            var t = {};
                            return t.createFilter = function(t) {
                                var e = createNS("filter");
                                return e.setAttribute("id", t), e.setAttribute("filterUnits", "objectBoundingBox"), e.setAttribute("x", "0%"), e.setAttribute("y", "0%"), e.setAttribute("width", "100%"), e.setAttribute("height", "100%"), e
                            }, t.createAlphaToLuminanceFilter = function() {
                                var t = createNS("feColorMatrix");
                                return t.setAttribute("type", "matrix"), t.setAttribute("color-interpolation-filters", "sRGB"), t.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"), t
                            }, t
                        }(),
                        assetLoader = function() {
                            function t(t) {
                                return t.response && "object" == typeof t.response ? t.response : t.response && "string" == typeof t.response ? JSON.parse(t.response) : t.responseText ? JSON.parse(t.responseText) : void 0
                            }
                            return {
                                load: function(e, n, i) {
                                    var r, a = new XMLHttpRequest;
                                    a.open("GET", e, !0);
                                    try {
                                        a.responseType = "json"
                                    } catch (t) {}
                                    a.send(), a.onreadystatechange = function() {
                                        if (4 == a.readyState)
                                            if (200 == a.status) r = t(a), n(r);
                                            else try {
                                                r = t(a), n(r)
                                            } catch (t) {
                                                i && i(t)
                                            }
                                    }
                                }
                            }
                        }();

                    function TextAnimatorProperty(t, e, n) {
                        this._isFirstFrame = !0, this._hasMaskedPath = !1, this._frameId = -1, this._textData = t, this._renderType = e, this._elem = n, this._animatorsData = createSizedArray(this._textData.a.length), this._pathData = {}, this._moreOptions = {
                            alignment: {}
                        }, this.renderedLetters = [], this.lettersChangedFlag = !1, this.initDynamicPropertyContainer(n)
                    }

                    function TextAnimatorDataProperty(t, e, n) {
                        var i = {
                                propType: !1
                            },
                            r = PropertyFactory.getProp,
                            a = e.a;
                        this.a = {
                            r: a.r ? r(t, a.r, 0, degToRads, n) : i,
                            rx: a.rx ? r(t, a.rx, 0, degToRads, n) : i,
                            ry: a.ry ? r(t, a.ry, 0, degToRads, n) : i,
                            sk: a.sk ? r(t, a.sk, 0, degToRads, n) : i,
                            sa: a.sa ? r(t, a.sa, 0, degToRads, n) : i,
                            s: a.s ? r(t, a.s, 1, .01, n) : i,
                            a: a.a ? r(t, a.a, 1, 0, n) : i,
                            o: a.o ? r(t, a.o, 0, .01, n) : i,
                            p: a.p ? r(t, a.p, 1, 0, n) : i,
                            sw: a.sw ? r(t, a.sw, 0, 0, n) : i,
                            sc: a.sc ? r(t, a.sc, 1, 0, n) : i,
                            fc: a.fc ? r(t, a.fc, 1, 0, n) : i,
                            fh: a.fh ? r(t, a.fh, 0, 0, n) : i,
                            fs: a.fs ? r(t, a.fs, 0, .01, n) : i,
                            fb: a.fb ? r(t, a.fb, 0, .01, n) : i,
                            t: a.t ? r(t, a.t, 0, 0, n) : i
                        }, this.s = TextSelectorProp.getTextSelectorProp(t, e.s, n), this.s.t = e.s.t
                    }

                    function LetterProps(t, e, n, i, r, a) {
                        this.o = t, this.sw = e, this.sc = n, this.fc = i, this.m = r, this.p = a, this._mdf = {
                            o: !0,
                            sw: !!e,
                            sc: !!n,
                            fc: !!i,
                            m: !0,
                            p: !0
                        }
                    }

                    function TextProperty(t, e) {
                        this._frameId = initialDefaultFrame, this.pv = "", this.v = "", this.kf = !1, this._isFirstFrame = !0, this._mdf = !1, this.data = e, this.elem = t, this.comp = this.elem.comp, this.keysIndex = 0, this.canResize = !1, this.minimumFontSize = 1, this.effectsSequence = [], this.currentData = {
                            ascent: 0,
                            boxWidth: this.defaultBoxWidth,
                            f: "",
                            fStyle: "",
                            fWeight: "",
                            fc: "",
                            j: "",
                            justifyOffset: "",
                            l: [],
                            lh: 0,
                            lineWidths: [],
                            ls: "",
                            of: "",
                            s: "",
                            sc: "",
                            sw: 0,
                            t: 0,
                            tr: 0,
                            sz: 0,
                            ps: null,
                            fillColorAnim: !1,
                            strokeColorAnim: !1,
                            strokeWidthAnim: !1,
                            yOffset: 0,
                            finalSize: 0,
                            finalText: [],
                            finalLineHeight: 0,
                            __complete: !1
                        }, this.copyData(this.currentData, this.data.d.k[0].s), this.searchProperty() || this.completeTextData(this.currentData)
                    }
                    TextAnimatorProperty.prototype.searchProperties = function() {
                        var t, e, n = this._textData.a.length,
                            i = PropertyFactory.getProp;
                        for (t = 0; t < n; t += 1) e = this._textData.a[t], this._animatorsData[t] = new TextAnimatorDataProperty(this._elem, e, this);
                        this._textData.p && "m" in this._textData.p ? (this._pathData = {
                            f: i(this._elem, this._textData.p.f, 0, 0, this),
                            l: i(this._elem, this._textData.p.l, 0, 0, this),
                            r: this._textData.p.r,
                            m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
                        }, this._hasMaskedPath = !0) : this._hasMaskedPath = !1, this._moreOptions.alignment = i(this._elem, this._textData.m.a, 1, 0, this)
                    }, TextAnimatorProperty.prototype.getMeasures = function(t, e) {
                        if (this.lettersChangedFlag = e, this._mdf || this._isFirstFrame || e || this._hasMaskedPath && this._pathData.m._mdf) {
                            this._isFirstFrame = !1;
                            var n, i, r, a, s, o, l, h, u, c, p, f, d, m, g, v, y, _, x, b = this._moreOptions.alignment.v,
                                E = this._animatorsData,
                                w = this._textData,
                                D = this.mHelper,
                                S = this._renderType,
                                M = this.renderedLetters.length,
                                T = (this.data, t.l);
                            if (this._hasMaskedPath) {
                                if (x = this._pathData.m, !this._pathData.n || this._pathData._mdf) {
                                    var A, C = x.v;
                                    for (this._pathData.r && (C = C.reverse()), s = {
                                            tLength: 0,
                                            segments: []
                                        }, a = C._length - 1, v = 0, r = 0; r < a; r += 1) A = bez.buildBezierData(C.v[r], C.v[r + 1], [C.o[r][0] - C.v[r][0], C.o[r][1] - C.v[r][1]], [C.i[r + 1][0] - C.v[r + 1][0], C.i[r + 1][1] - C.v[r + 1][1]]), s.tLength += A.segmentLength, s.segments.push(A), v += A.segmentLength;
                                    r = a, x.v.c && (A = bez.buildBezierData(C.v[r], C.v[0], [C.o[r][0] - C.v[r][0], C.o[r][1] - C.v[r][1]], [C.i[0][0] - C.v[0][0], C.i[0][1] - C.v[0][1]]), s.tLength += A.segmentLength, s.segments.push(A), v += A.segmentLength), this._pathData.pi = s
                                }
                                if (s = this._pathData.pi, o = this._pathData.f.v, p = 0, c = 1, h = 0, u = !0, m = s.segments, o < 0 && x.v.c)
                                    for (s.tLength < Math.abs(o) && (o = -Math.abs(o) % s.tLength), c = (d = m[p = m.length - 1].points).length - 1; o < 0;) o += d[c].partialLength, (c -= 1) < 0 && (c = (d = m[p -= 1].points).length - 1);
                                f = (d = m[p].points)[c - 1], g = (l = d[c]).partialLength
                            }
                            a = T.length, n = 0, i = 0;
                            var P, F, L, R, I = 1.2 * t.finalSize * .714,
                                k = !0;
                            L = E.length;
                            var O, N, B, z, V, U, G, H, j, W, X, q, Y, Z = -1,
                                J = o,
                                K = p,
                                $ = c,
                                Q = -1,
                                tt = "",
                                et = this.defaultPropsArray;
                            if (2 === t.j || 1 === t.j) {
                                var nt = 0,
                                    it = 0,
                                    rt = 2 === t.j ? -.5 : -1,
                                    at = 0,
                                    st = !0;
                                for (r = 0; r < a; r += 1)
                                    if (T[r].n) {
                                        for (nt && (nt += it); at < r;) T[at].animatorJustifyOffset = nt, at += 1;
                                        nt = 0, st = !0
                                    } else {
                                        for (F = 0; F < L; F += 1)(P = E[F].a).t.propType && (st && 2 === t.j && (it += P.t.v * rt), (O = E[F].s.getMult(T[r].anIndexes[F], w.a[F].s.totalChars)).length ? nt += P.t.v * O[0] * rt : nt += P.t.v * O * rt);
                                        st = !1
                                    }
                                for (nt && (nt += it); at < r;) T[at].animatorJustifyOffset = nt, at += 1
                            }
                            for (r = 0; r < a; r += 1) {
                                if (D.reset(), V = 1, T[r].n) n = 0, i += t.yOffset, i += k ? 1 : 0, o = J, k = !1, 0, this._hasMaskedPath && (c = $, f = (d = m[p = K].points)[c - 1], g = (l = d[c]).partialLength, h = 0), Y = W = q = tt = "", et = this.defaultPropsArray;
                                else {
                                    if (this._hasMaskedPath) {
                                        if (Q !== T[r].line) {
                                            switch (t.j) {
                                                case 1:
                                                    o += v - t.lineWidths[T[r].line];
                                                    break;
                                                case 2:
                                                    o += (v - t.lineWidths[T[r].line]) / 2
                                            }
                                            Q = T[r].line
                                        }
                                        Z !== T[r].ind && (T[Z] && (o += T[Z].extra), o += T[r].an / 2, Z = T[r].ind), o += b[0] * T[r].an / 200;
                                        var ot = 0;
                                        for (F = 0; F < L; F += 1)(P = E[F].a).p.propType && ((O = E[F].s.getMult(T[r].anIndexes[F], w.a[F].s.totalChars)).length ? ot += P.p.v[0] * O[0] : ot += P.p.v[0] * O), P.a.propType && ((O = E[F].s.getMult(T[r].anIndexes[F], w.a[F].s.totalChars)).length ? ot += P.a.v[0] * O[0] : ot += P.a.v[0] * O);
                                        for (u = !0; u;) h + g >= o + ot || !d ? (y = (o + ot - h) / l.partialLength, B = f.point[0] + (l.point[0] - f.point[0]) * y, z = f.point[1] + (l.point[1] - f.point[1]) * y, D.translate(-b[0] * T[r].an / 200, -b[1] * I / 100), u = !1) : d && (h += l.partialLength, (c += 1) >= d.length && (c = 0, m[p += 1] ? d = m[p].points : x.v.c ? (c = 0, d = m[p = 0].points) : (h -= l.partialLength, d = null)), d && (f = l, g = (l = d[c]).partialLength));
                                        N = T[r].an / 2 - T[r].add, D.translate(-N, 0, 0)
                                    } else N = T[r].an / 2 - T[r].add, D.translate(-N, 0, 0), D.translate(-b[0] * T[r].an / 200, -b[1] * I / 100, 0);
                                    for (T[r].l / 2, F = 0; F < L; F += 1)(P = E[F].a).t.propType && (O = E[F].s.getMult(T[r].anIndexes[F], w.a[F].s.totalChars), 0 === n && 0 === t.j || (this._hasMaskedPath ? O.length ? o += P.t.v * O[0] : o += P.t.v * O : O.length ? n += P.t.v * O[0] : n += P.t.v * O));
                                    for (T[r].l / 2, t.strokeWidthAnim && (G = t.sw || 0), t.strokeColorAnim && (U = t.sc ? [t.sc[0], t.sc[1], t.sc[2]] : [0, 0, 0]), t.fillColorAnim && t.fc && (H = [t.fc[0], t.fc[1], t.fc[2]]), F = 0; F < L; F += 1)(P = E[F].a).a.propType && ((O = E[F].s.getMult(T[r].anIndexes[F], w.a[F].s.totalChars)).length ? D.translate(-P.a.v[0] * O[0], -P.a.v[1] * O[1], P.a.v[2] * O[2]) : D.translate(-P.a.v[0] * O, -P.a.v[1] * O, P.a.v[2] * O));
                                    for (F = 0; F < L; F += 1)(P = E[F].a).s.propType && ((O = E[F].s.getMult(T[r].anIndexes[F], w.a[F].s.totalChars)).length ? D.scale(1 + (P.s.v[0] - 1) * O[0], 1 + (P.s.v[1] - 1) * O[1], 1) : D.scale(1 + (P.s.v[0] - 1) * O, 1 + (P.s.v[1] - 1) * O, 1));
                                    for (F = 0; F < L; F += 1) {
                                        if (P = E[F].a, O = E[F].s.getMult(T[r].anIndexes[F], w.a[F].s.totalChars), P.sk.propType && (O.length ? D.skewFromAxis(-P.sk.v * O[0], P.sa.v * O[1]) : D.skewFromAxis(-P.sk.v * O, P.sa.v * O)), P.r.propType && (O.length ? D.rotateZ(-P.r.v * O[2]) : D.rotateZ(-P.r.v * O)), P.ry.propType && (O.length ? D.rotateY(P.ry.v * O[1]) : D.rotateY(P.ry.v * O)), P.rx.propType && (O.length ? D.rotateX(P.rx.v * O[0]) : D.rotateX(P.rx.v * O)), P.o.propType && (O.length ? V += (P.o.v * O[0] - V) * O[0] : V += (P.o.v * O - V) * O), t.strokeWidthAnim && P.sw.propType && (O.length ? G += P.sw.v * O[0] : G += P.sw.v * O), t.strokeColorAnim && P.sc.propType)
                                            for (j = 0; j < 3; j += 1) O.length ? U[j] = U[j] + (P.sc.v[j] - U[j]) * O[0] : U[j] = U[j] + (P.sc.v[j] - U[j]) * O;
                                        if (t.fillColorAnim && t.fc) {
                                            if (P.fc.propType)
                                                for (j = 0; j < 3; j += 1) O.length ? H[j] = H[j] + (P.fc.v[j] - H[j]) * O[0] : H[j] = H[j] + (P.fc.v[j] - H[j]) * O;
                                            P.fh.propType && (H = O.length ? addHueToRGB(H, P.fh.v * O[0]) : addHueToRGB(H, P.fh.v * O)), P.fs.propType && (H = O.length ? addSaturationToRGB(H, P.fs.v * O[0]) : addSaturationToRGB(H, P.fs.v * O)), P.fb.propType && (H = O.length ? addBrightnessToRGB(H, P.fb.v * O[0]) : addBrightnessToRGB(H, P.fb.v * O))
                                        }
                                    }
                                    for (F = 0; F < L; F += 1)(P = E[F].a).p.propType && (O = E[F].s.getMult(T[r].anIndexes[F], w.a[F].s.totalChars), this._hasMaskedPath ? O.length ? D.translate(0, P.p.v[1] * O[0], -P.p.v[2] * O[1]) : D.translate(0, P.p.v[1] * O, -P.p.v[2] * O) : O.length ? D.translate(P.p.v[0] * O[0], P.p.v[1] * O[1], -P.p.v[2] * O[2]) : D.translate(P.p.v[0] * O, P.p.v[1] * O, -P.p.v[2] * O));
                                    if (t.strokeWidthAnim && (W = G < 0 ? 0 : G), t.strokeColorAnim && (X = "rgb(" + Math.round(255 * U[0]) + "," + Math.round(255 * U[1]) + "," + Math.round(255 * U[2]) + ")"), t.fillColorAnim && t.fc && (q = "rgb(" + Math.round(255 * H[0]) + "," + Math.round(255 * H[1]) + "," + Math.round(255 * H[2]) + ")"), this._hasMaskedPath) {
                                        if (D.translate(0, -t.ls), D.translate(0, b[1] * I / 100 + i, 0), w.p.p) {
                                            _ = (l.point[1] - f.point[1]) / (l.point[0] - f.point[0]);
                                            var lt = 180 * Math.atan(_) / Math.PI;
                                            l.point[0] < f.point[0] && (lt += 180), D.rotate(-lt * Math.PI / 180)
                                        }
                                        D.translate(B, z, 0), o -= b[0] * T[r].an / 200, T[r + 1] && Z !== T[r + 1].ind && (o += T[r].an / 2, o += t.tr / 1e3 * t.finalSize)
                                    } else {
                                        switch (D.translate(n, i, 0), t.ps && D.translate(t.ps[0], t.ps[1] + t.ascent, 0), t.j) {
                                            case 1:
                                                D.translate(T[r].animatorJustifyOffset + t.justifyOffset + (t.boxWidth - t.lineWidths[T[r].line]), 0, 0);
                                                break;
                                            case 2:
                                                D.translate(T[r].animatorJustifyOffset + t.justifyOffset + (t.boxWidth - t.lineWidths[T[r].line]) / 2, 0, 0)
                                        }
                                        D.translate(0, -t.ls), D.translate(N, 0, 0), D.translate(b[0] * T[r].an / 200, b[1] * I / 100, 0), n += T[r].l + t.tr / 1e3 * t.finalSize
                                    }
                                    "html" === S ? tt = D.toCSS() : "svg" === S ? tt = D.to2dCSS() : et = [D.props[0], D.props[1], D.props[2], D.props[3], D.props[4], D.props[5], D.props[6], D.props[7], D.props[8], D.props[9], D.props[10], D.props[11], D.props[12], D.props[13], D.props[14], D.props[15]], Y = V
                                }
                                M <= r ? (R = new LetterProps(Y, W, X, q, tt, et), this.renderedLetters.push(R), M += 1, this.lettersChangedFlag = !0) : (R = this.renderedLetters[r], this.lettersChangedFlag = R.update(Y, W, X, q, tt, et) || this.lettersChangedFlag)
                            }
                        }
                    }, TextAnimatorProperty.prototype.getValue = function() {
                        this._elem.globalData.frameId !== this._frameId && (this._frameId = this._elem.globalData.frameId, this.iterateDynamicProperties())
                    }, TextAnimatorProperty.prototype.mHelper = new Matrix, TextAnimatorProperty.prototype.defaultPropsArray = [], extendPrototype([DynamicPropertyContainer], TextAnimatorProperty), LetterProps.prototype.update = function(t, e, n, i, r, a) {
                        this._mdf.o = !1, this._mdf.sw = !1, this._mdf.sc = !1, this._mdf.fc = !1, this._mdf.m = !1, this._mdf.p = !1;
                        var s = !1;
                        return this.o !== t && (this.o = t, this._mdf.o = !0, s = !0), this.sw !== e && (this.sw = e, this._mdf.sw = !0, s = !0), this.sc !== n && (this.sc = n, this._mdf.sc = !0, s = !0), this.fc !== i && (this.fc = i, this._mdf.fc = !0, s = !0), this.m !== r && (this.m = r, this._mdf.m = !0, s = !0), !a.length || this.p[0] === a[0] && this.p[1] === a[1] && this.p[4] === a[4] && this.p[5] === a[5] && this.p[12] === a[12] && this.p[13] === a[13] || (this.p = a, this._mdf.p = !0, s = !0), s
                    }, TextProperty.prototype.defaultBoxWidth = [0, 0], TextProperty.prototype.copyData = function(t, e) {
                        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
                        return t
                    }, TextProperty.prototype.setCurrentData = function(t) {
                        t.__complete || this.completeTextData(t), this.currentData = t, this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth, this._mdf = !0
                    }, TextProperty.prototype.searchProperty = function() {
                        return this.searchKeyframes()
                    }, TextProperty.prototype.searchKeyframes = function() {
                        return this.kf = this.data.d.k.length > 1, this.kf && this.addEffect(this.getKeyframeValue.bind(this)), this.kf
                    }, TextProperty.prototype.addEffect = function(t) {
                        this.effectsSequence.push(t), this.elem.addDynamicProperty(this)
                    }, TextProperty.prototype.getValue = function(t) {
                        if (this.elem.globalData.frameId !== this.frameId && this.effectsSequence.length || t) {
                            this.currentData.t = this.data.d.k[this.keysIndex].s.t;
                            var e = this.currentData,
                                n = this.keysIndex;
                            if (this.lock) this.setCurrentData(this.currentData);
                            else {
                                this.lock = !0, this._mdf = !1;
                                var i, r = this.effectsSequence.length,
                                    a = t || this.data.d.k[this.keysIndex].s;
                                for (i = 0; i < r; i += 1) a = n !== this.keysIndex ? this.effectsSequence[i](a, a.t) : this.effectsSequence[i](this.currentData, a.t);
                                e !== a && this.setCurrentData(a), this.pv = this.v = this.currentData, this.lock = !1, this.frameId = this.elem.globalData.frameId
                            }
                        }
                    }, TextProperty.prototype.getKeyframeValue = function() {
                        for (var t = this.data.d.k, e = this.elem.comp.renderedFrame, n = 0, i = t.length; n <= i - 1 && (t[n].s, !(n === i - 1 || t[n + 1].t > e));) n += 1;
                        return this.keysIndex !== n && (this.keysIndex = n), this.data.d.k[this.keysIndex].s
                    }, TextProperty.prototype.buildFinalText = function(t) {
                        for (var e, n = FontManager.getCombinedCharacterCodes(), i = [], r = 0, a = t.length; r < a;) e = t.charCodeAt(r), -1 !== n.indexOf(e) ? i[i.length - 1] += t.charAt(r) : e >= 55296 && e <= 56319 && (e = t.charCodeAt(r + 1)) >= 56320 && e <= 57343 ? (i.push(t.substr(r, 2)), ++r) : i.push(t.charAt(r)), r += 1;
                        return i
                    }, TextProperty.prototype.completeTextData = function(t) {
                        t.__complete = !0;
                        var e, n, i, r, a, s, o, l = this.elem.globalData.fontManager,
                            h = this.data,
                            u = [],
                            c = 0,
                            p = h.m.g,
                            f = 0,
                            d = 0,
                            m = 0,
                            g = [],
                            v = 0,
                            y = 0,
                            _ = l.getFontByName(t.f),
                            x = 0,
                            b = _.fStyle ? _.fStyle.split(" ") : [],
                            E = "normal",
                            w = "normal";
                        for (n = b.length, e = 0; e < n; e += 1) switch (b[e].toLowerCase()) {
                            case "italic":
                                w = "italic";
                                break;
                            case "bold":
                                E = "700";
                                break;
                            case "black":
                                E = "900";
                                break;
                            case "medium":
                                E = "500";
                                break;
                            case "regular":
                            case "normal":
                                E = "400";
                                break;
                            case "light":
                            case "thin":
                                E = "200"
                        }
                        t.fWeight = _.fWeight || E, t.fStyle = w, t.finalSize = t.s, t.finalText = this.buildFinalText(t.t), n = t.finalText.length, t.finalLineHeight = t.lh;
                        var D, S = t.tr / 1e3 * t.finalSize;
                        if (t.sz)
                            for (var M, T, A = !0, C = t.sz[0], P = t.sz[1]; A;) {
                                M = 0, v = 0, n = (T = this.buildFinalText(t.t)).length, S = t.tr / 1e3 * t.finalSize;
                                var F = -1;
                                for (e = 0; e < n; e += 1) D = T[e].charCodeAt(0), i = !1, " " === T[e] ? F = e : 13 !== D && 3 !== D || (v = 0, i = !0, M += t.finalLineHeight || 1.2 * t.finalSize), l.chars ? (o = l.getCharData(T[e], _.fStyle, _.fFamily), x = i ? 0 : o.w * t.finalSize / 100) : x = l.measureText(T[e], t.f, t.finalSize), v + x > C && " " !== T[e] ? (-1 === F ? n += 1 : e = F, M += t.finalLineHeight || 1.2 * t.finalSize, T.splice(e, F === e ? 1 : 0, "\r"), F = -1, v = 0) : (v += x, v += S);
                                M += _.ascent * t.finalSize / 100, this.canResize && t.finalSize > this.minimumFontSize && P < M ? (t.finalSize -= 1, t.finalLineHeight = t.finalSize * t.lh / t.s) : (t.finalText = T, n = t.finalText.length, A = !1)
                            }
                        v = -S, x = 0;
                        var L, R = 0;
                        for (e = 0; e < n; e += 1)
                            if (i = !1, 13 === (D = (L = t.finalText[e]).charCodeAt(0)) || 3 === D ? (R = 0, g.push(v), y = v > y ? v : y, v = -2 * S, r = "", i = !0, m += 1) : r = L, l.chars ? (o = l.getCharData(L, _.fStyle, l.getFontByName(t.f).fFamily), x = i ? 0 : o.w * t.finalSize / 100) : x = l.measureText(r, t.f, t.finalSize), " " === L ? R += x + S : (v += x + S + R, R = 0), u.push({
                                    l: x,
                                    an: x,
                                    add: f,
                                    n: i,
                                    anIndexes: [],
                                    val: r,
                                    line: m,
                                    animatorJustifyOffset: 0
                                }), 2 == p) {
                                if (f += x, "" === r || " " === r || e === n - 1) {
                                    for ("" !== r && " " !== r || (f -= x); d <= e;) u[d].an = f, u[d].ind = c, u[d].extra = x, d += 1;
                                    c += 1, f = 0
                                }
                            } else if (3 == p) {
                            if (f += x, "" === r || e === n - 1) {
                                for ("" === r && (f -= x); d <= e;) u[d].an = f, u[d].ind = c, u[d].extra = x, d += 1;
                                f = 0, c += 1
                            }
                        } else u[c].ind = c, u[c].extra = 0, c += 1;
                        if (t.l = u, y = v > y ? v : y, g.push(v), t.sz) t.boxWidth = t.sz[0], t.justifyOffset = 0;
                        else switch (t.boxWidth = y, t.j) {
                            case 1:
                                t.justifyOffset = -t.boxWidth;
                                break;
                            case 2:
                                t.justifyOffset = -t.boxWidth / 2;
                                break;
                            default:
                                t.justifyOffset = 0
                        }
                        t.lineWidths = g;
                        var I, k, O = h.a;
                        s = O.length;
                        var N, B, z = [];
                        for (a = 0; a < s; a += 1) {
                            for ((I = O[a]).a.sc && (t.strokeColorAnim = !0), I.a.sw && (t.strokeWidthAnim = !0), (I.a.fc || I.a.fh || I.a.fs || I.a.fb) && (t.fillColorAnim = !0), B = 0, N = I.s.b, e = 0; e < n; e += 1)(k = u[e]).anIndexes[a] = B, (1 == N && "" !== k.val || 2 == N && "" !== k.val && " " !== k.val || 3 == N && (k.n || " " == k.val || e == n - 1) || 4 == N && (k.n || e == n - 1)) && (1 === I.s.rn && z.push(B), B += 1);
                            h.a[a].s.totalChars = B;
                            var V, U = -1;
                            if (1 === I.s.rn)
                                for (e = 0; e < n; e += 1) U != (k = u[e]).anIndexes[a] && (U = k.anIndexes[a], V = z.splice(Math.floor(Math.random() * z.length), 1)[0]), k.anIndexes[a] = V
                        }
                        t.yOffset = t.finalLineHeight || 1.2 * t.finalSize, t.ls = t.ls || 0, t.ascent = _.ascent * t.finalSize / 100
                    }, TextProperty.prototype.updateDocumentData = function(t, e) {
                        e = void 0 === e ? this.keysIndex : e;
                        var n = this.copyData({}, this.data.d.k[e].s);
                        n = this.copyData(n, t), this.data.d.k[e].s = n, this.recalculate(e), this.elem.addDynamicProperty(this)
                    }, TextProperty.prototype.recalculate = function(t) {
                        var e = this.data.d.k[t].s;
                        e.__complete = !1, this.keysIndex = 0, this._isFirstFrame = !0, this.getValue(e)
                    }, TextProperty.prototype.canResizeFont = function(t) {
                        this.canResize = t, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this)
                    }, TextProperty.prototype.setMinimumFontSize = function(t) {
                        this.minimumFontSize = Math.floor(t) || 1, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this)
                    };
                    var TextSelectorProp = function() {
                            var t = Math.max,
                                e = Math.min,
                                n = Math.floor;

                            function i(t, e) {
                                this._currentTextLength = -1, this.k = !1, this.data = e, this.elem = t, this.comp = t.comp, this.finalS = 0, this.finalE = 0, this.initDynamicPropertyContainer(t), this.s = PropertyFactory.getProp(t, e.s || {
                                    k: 0
                                }, 0, 0, this), this.e = "e" in e ? PropertyFactory.getProp(t, e.e, 0, 0, this) : {
                                    v: 100
                                }, this.o = PropertyFactory.getProp(t, e.o || {
                                    k: 0
                                }, 0, 0, this), this.xe = PropertyFactory.getProp(t, e.xe || {
                                    k: 0
                                }, 0, 0, this), this.ne = PropertyFactory.getProp(t, e.ne || {
                                    k: 0
                                }, 0, 0, this), this.a = PropertyFactory.getProp(t, e.a, 0, .01, this), this.dynamicProperties.length || this.getValue()
                            }
                            return i.prototype = {
                                getMult: function(i) {
                                    this._currentTextLength !== this.elem.textProperty.currentData.l.length && this.getValue();
                                    var r = 0,
                                        a = 0,
                                        s = 1,
                                        o = 1;
                                    this.ne.v > 0 ? r = this.ne.v / 100 : a = -this.ne.v / 100, this.xe.v > 0 ? s = 1 - this.xe.v / 100 : o = 1 + this.xe.v / 100;
                                    var l = BezierFactory.getBezierEasing(r, a, s, o).get,
                                        h = 0,
                                        u = this.finalS,
                                        c = this.finalE,
                                        p = this.data.sh;
                                    if (2 === p) h = l(h = c === u ? i >= c ? 1 : 0 : t(0, e(.5 / (c - u) + (i - u) / (c - u), 1)));
                                    else if (3 === p) h = l(h = c === u ? i >= c ? 0 : 1 : 1 - t(0, e(.5 / (c - u) + (i - u) / (c - u), 1)));
                                    else if (4 === p) c === u ? h = 0 : (h = t(0, e(.5 / (c - u) + (i - u) / (c - u), 1))) < .5 ? h *= 2 : h = 1 - 2 * (h - .5), h = l(h);
                                    else if (5 === p) {
                                        if (c === u) h = 0;
                                        else {
                                            var f = c - u,
                                                d = -f / 2 + (i = e(t(0, i + .5 - u), c - u)),
                                                m = f / 2;
                                            h = Math.sqrt(1 - d * d / (m * m))
                                        }
                                        h = l(h)
                                    } else 6 === p ? (c === u ? h = 0 : (i = e(t(0, i + .5 - u), c - u), h = (1 + Math.cos(Math.PI + 2 * Math.PI * i / (c - u))) / 2), h = l(h)) : (i >= n(u) && (h = t(0, e(i - u < 0 ? e(c, 1) - (u - i) : c - i, 1))), h = l(h));
                                    return h * this.a.v
                                },
                                getValue: function(t) {
                                    this.iterateDynamicProperties(), this._mdf = t || this._mdf, this._currentTextLength = this.elem.textProperty.currentData.l.length || 0, t && 2 === this.data.r && (this.e.v = this._currentTextLength);
                                    var e = 2 === this.data.r ? 1 : 100 / this.data.totalChars,
                                        n = this.o.v / e,
                                        i = this.s.v / e + n,
                                        r = this.e.v / e + n;
                                    if (i > r) {
                                        var a = i;
                                        i = r, r = a
                                    }
                                    this.finalS = i, this.finalE = r
                                }
                            }, extendPrototype([DynamicPropertyContainer], i), {
                                getTextSelectorProp: function(t, e, n) {
                                    return new i(t, e, n)
                                }
                            }
                        }(),
                        pool_factory = function(t, e, n, i) {
                            var r = 0,
                                a = t,
                                s = createSizedArray(a);

                            function o() {
                                return r ? s[r -= 1] : e()
                            }
                            return {
                                newElement: o,
                                release: function(t) {
                                    r === a && (s = pooling.double(s), a *= 2), n && n(t), s[r] = t, r += 1
                                }
                            }
                        },
                        pooling = {
                            double: function(t) {
                                return t.concat(createSizedArray(t.length))
                            }
                        },
                        point_pool = pool_factory(8, (function() {
                            return createTypedArray("float32", 2)
                        })),
                        shape_pool = (factory = pool_factory(4, (function() {
                            return new ShapePath
                        }), (function(t) {
                            var e, n = t._length;
                            for (e = 0; e < n; e += 1) point_pool.release(t.v[e]), point_pool.release(t.i[e]), point_pool.release(t.o[e]), t.v[e] = null, t.i[e] = null, t.o[e] = null;
                            t._length = 0, t.c = !1
                        })), factory.clone = function(t) {
                            var e, n = factory.newElement(),
                                i = void 0 === t._length ? t.v.length : t._length;
                            for (n.setLength(i), n.c = t.c, e = 0; e < i; e += 1) n.setTripleAt(t.v[e][0], t.v[e][1], t.o[e][0], t.o[e][1], t.i[e][0], t.i[e][1], e);
                            return n
                        }, factory),
                        factory, shapeCollection_pool = function() {
                            var t = {
                                    newShapeCollection: function() {
                                        var t;
                                        t = e ? i[e -= 1] : new ShapeCollection;
                                        return t
                                    },
                                    release: function(t) {
                                        var r, a = t._length;
                                        for (r = 0; r < a; r += 1) shape_pool.release(t.shapes[r]);
                                        t._length = 0, e === n && (i = pooling.double(i), n *= 2);
                                        i[e] = t, e += 1
                                    }
                                },
                                e = 0,
                                n = 4,
                                i = createSizedArray(n);
                            return t
                        }(),
                        segments_length_pool = pool_factory(8, (function() {
                            return {
                                lengths: [],
                                totalLength: 0
                            }
                        }), (function(t) {
                            var e, n = t.lengths.length;
                            for (e = 0; e < n; e += 1) bezier_length_pool.release(t.lengths[e]);
                            t.lengths.length = 0
                        })),
                        bezier_length_pool = pool_factory(8, (function() {
                            return {
                                addedLength: 0,
                                percents: createTypedArray("float32", defaultCurveSegments),
                                lengths: createTypedArray("float32", defaultCurveSegments)
                            }
                        }));

                    function BaseRenderer() {}

                    function SVGRenderer(t, e) {
                        this.animationItem = t, this.layers = null, this.renderedFrame = -1, this.svgElement = createNS("svg");
                        var n = "";
                        if (e && e.title) {
                            var i = createNS("title"),
                                r = createElementID();
                            i.setAttribute("id", r), i.textContent = e.title, this.svgElement.appendChild(i), n += r
                        }
                        if (e && e.description) {
                            var a = createNS("desc"),
                                s = createElementID();
                            a.setAttribute("id", s), a.textContent = e.description, this.svgElement.appendChild(a), n += " " + s
                        }
                        n && this.svgElement.setAttribute("aria-labelledby", n);
                        var o = createNS("defs");
                        this.svgElement.appendChild(o);
                        var l = createNS("g");
                        this.svgElement.appendChild(l), this.layerElement = l, this.renderConfig = {
                            preserveAspectRatio: e && e.preserveAspectRatio || "xMidYMid meet",
                            imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice",
                            progressiveLoad: e && e.progressiveLoad || !1,
                            hideOnTransparent: !e || !1 !== e.hideOnTransparent,
                            viewBoxOnly: e && e.viewBoxOnly || !1,
                            viewBoxSize: e && e.viewBoxSize || !1,
                            className: e && e.className || "",
                            id: e && e.id || "",
                            focusable: e && e.focusable,
                            filterSize: {
                                width: e && e.filterSize && e.filterSize.width || "100%",
                                height: e && e.filterSize && e.filterSize.height || "100%",
                                x: e && e.filterSize && e.filterSize.x || "0%",
                                y: e && e.filterSize && e.filterSize.y || "0%"
                            }
                        }, this.globalData = {
                            _mdf: !1,
                            frameNum: -1,
                            defs: o,
                            renderConfig: this.renderConfig
                        }, this.elements = [], this.pendingElements = [], this.destroyed = !1, this.rendererType = "svg"
                    }

                    function CanvasRenderer(t, e) {
                        this.animationItem = t, this.renderConfig = {
                            clearCanvas: !e || void 0 === e.clearCanvas || e.clearCanvas,
                            context: e && e.context || null,
                            progressiveLoad: e && e.progressiveLoad || !1,
                            preserveAspectRatio: e && e.preserveAspectRatio || "xMidYMid meet",
                            imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice",
                            className: e && e.className || "",
                            id: e && e.id || ""
                        }, this.renderConfig.dpr = e && e.dpr || 1, this.animationItem.wrapper && (this.renderConfig.dpr = e && e.dpr || window.devicePixelRatio || 1), this.renderedFrame = -1, this.globalData = {
                            frameNum: -1,
                            _mdf: !1,
                            renderConfig: this.renderConfig,
                            currentGlobalAlpha: -1
                        }, this.contextData = new CVContextData, this.elements = [], this.pendingElements = [], this.transformMat = new Matrix, this.completeLayers = !1, this.rendererType = "canvas"
                    }

                    function HybridRenderer(t, e) {
                        this.animationItem = t, this.layers = null, this.renderedFrame = -1, this.renderConfig = {
                            className: e && e.className || "",
                            imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice",
                            hideOnTransparent: !e || !1 !== e.hideOnTransparent,
                            filterSize: {
                                width: e && e.filterSize && e.filterSize.width || "400%",
                                height: e && e.filterSize && e.filterSize.height || "400%",
                                x: e && e.filterSize && e.filterSize.x || "-100%",
                                y: e && e.filterSize && e.filterSize.y || "-100%"
                            }
                        }, this.globalData = {
                            _mdf: !1,
                            frameNum: -1,
                            renderConfig: this.renderConfig
                        }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html"
                    }

                    function MaskElement(t, e, n) {
                        this.data = t, this.element = e, this.globalData = n, this.storedData = [], this.masksProperties = this.data.masksProperties || [], this.maskElement = null;
                        var i, r = this.globalData.defs,
                            a = this.masksProperties ? this.masksProperties.length : 0;
                        this.viewData = createSizedArray(a), this.solidPath = "";
                        var s, o, l, h, u, c, p, f = this.masksProperties,
                            d = 0,
                            m = [],
                            g = createElementID(),
                            v = "clipPath",
                            y = "clip-path";
                        for (i = 0; i < a; i++)
                            if (("a" !== f[i].mode && "n" !== f[i].mode || f[i].inv || 100 !== f[i].o.k || f[i].o.x) && (v = "mask", y = "mask"), "s" != f[i].mode && "i" != f[i].mode || 0 !== d ? h = null : ((h = createNS("rect")).setAttribute("fill", "#ffffff"), h.setAttribute("width", this.element.comp.data.w || 0), h.setAttribute("height", this.element.comp.data.h || 0), m.push(h)), s = createNS("path"), "n" != f[i].mode) {
                                var _;
                                if (d += 1, s.setAttribute("fill", "s" === f[i].mode ? "#000000" : "#ffffff"), s.setAttribute("clip-rule", "nonzero"), 0 !== f[i].x.k ? (v = "mask", y = "mask", p = PropertyFactory.getProp(this.element, f[i].x, 0, null, this.element), _ = createElementID(), (u = createNS("filter")).setAttribute("id", _), (c = createNS("feMorphology")).setAttribute("operator", "erode"), c.setAttribute("in", "SourceGraphic"), c.setAttribute("radius", "0"), u.appendChild(c), r.appendChild(u), s.setAttribute("stroke", "s" === f[i].mode ? "#000000" : "#ffffff")) : (c = null, p = null), this.storedData[i] = {
                                        elem: s,
                                        x: p,
                                        expan: c,
                                        lastPath: "",
                                        lastOperator: "",
                                        filterId: _,
                                        lastRadius: 0
                                    }, "i" == f[i].mode) {
                                    l = m.length;
                                    var x = createNS("g");
                                    for (o = 0; o < l; o += 1) x.appendChild(m[o]);
                                    var b = createNS("mask");
                                    b.setAttribute("mask-type", "alpha"), b.setAttribute("id", g + "_" + d), b.appendChild(s), r.appendChild(b), x.setAttribute("mask", "url(" + locationHref + "#" + g + "_" + d + ")"), m.length = 0, m.push(x)
                                } else m.push(s);
                                f[i].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()), this.viewData[i] = {
                                    elem: s,
                                    lastPath: "",
                                    op: PropertyFactory.getProp(this.element, f[i].o, 0, .01, this.element),
                                    prop: ShapePropertyFactory.getShapeProp(this.element, f[i], 3),
                                    invRect: h
                                }, this.viewData[i].prop.k || this.drawPath(f[i], this.viewData[i].prop.v, this.viewData[i])
                            } else this.viewData[i] = {
                                op: PropertyFactory.getProp(this.element, f[i].o, 0, .01, this.element),
                                prop: ShapePropertyFactory.getShapeProp(this.element, f[i], 3),
                                elem: s,
                                lastPath: ""
                            }, r.appendChild(s);
                        for (this.maskElement = createNS(v), a = m.length, i = 0; i < a; i += 1) this.maskElement.appendChild(m[i]);
                        d > 0 && (this.maskElement.setAttribute("id", g), this.element.maskedElement.setAttribute(y, "url(" + locationHref + "#" + g + ")"), r.appendChild(this.maskElement)), this.viewData.length && this.element.addRenderableComponent(this)
                    }

                    function HierarchyElement() {}

                    function FrameElement() {}

                    function TransformElement() {}

                    function RenderableElement() {}

                    function RenderableDOMElement() {}

                    function ProcessedElement(t, e) {
                        this.elem = t, this.pos = e
                    }

                    function SVGStyleData(t, e) {
                        this.data = t, this.type = t.ty, this.d = "", this.lvl = e, this._mdf = !1, this.closed = !0 === t.hd, this.pElem = createNS("path"), this.msElem = null
                    }

                    function SVGShapeData(t, e, n) {
                        this.caches = [], this.styles = [], this.transformers = t, this.lStr = "", this.sh = n, this.lvl = e, this._isAnimated = !!n.k;
                        for (var i = 0, r = t.length; i < r;) {
                            if (t[i].mProps.dynamicProperties.length) {
                                this._isAnimated = !0;
                                break
                            }
                            i += 1
                        }
                    }

                    function SVGTransformData(t, e, n) {
                        this.transform = {
                            mProps: t,
                            op: e,
                            container: n
                        }, this.elements = [], this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length
                    }

                    function SVGStrokeStyleData(t, e, n) {
                        this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(t, e.o, 0, .01, this), this.w = PropertyFactory.getProp(t, e.w, 0, null, this), this.d = new DashProperty(t, e.d || {}, "svg", this), this.c = PropertyFactory.getProp(t, e.c, 1, 255, this), this.style = n, this._isAnimated = !!this._isAnimated
                    }

                    function SVGFillStyleData(t, e, n) {
                        this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(t, e.o, 0, .01, this), this.c = PropertyFactory.getProp(t, e.c, 1, 255, this), this.style = n
                    }

                    function SVGGradientFillStyleData(t, e, n) {
                        this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.initGradientData(t, e, n)
                    }

                    function SVGGradientStrokeStyleData(t, e, n) {
                        this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.w = PropertyFactory.getProp(t, e.w, 0, null, this), this.d = new DashProperty(t, e.d || {}, "svg", this), this.initGradientData(t, e, n), this._isAnimated = !!this._isAnimated
                    }

                    function ShapeGroupData() {
                        this.it = [], this.prevViewData = [], this.gr = createNS("g")
                    }
                    BaseRenderer.prototype.checkLayers = function(t) {
                        var e, n, i = this.layers.length;
                        for (this.completeLayers = !0, e = i - 1; e >= 0; e--) this.elements[e] || (n = this.layers[e]).ip - n.st <= t - this.layers[e].st && n.op - n.st > t - this.layers[e].st && this.buildItem(e), this.completeLayers = !!this.elements[e] && this.completeLayers;
                        this.checkPendingElements()
                    }, BaseRenderer.prototype.createItem = function(t) {
                        switch (t.ty) {
                            case 2:
                                return this.createImage(t);
                            case 0:
                                return this.createComp(t);
                            case 1:
                                return this.createSolid(t);
                            case 3:
                                return this.createNull(t);
                            case 4:
                                return this.createShape(t);
                            case 5:
                                return this.createText(t);
                            case 6:
                                return this.createAudio(t);
                            case 13:
                                return this.createCamera(t)
                        }
                        return this.createNull(t)
                    }, BaseRenderer.prototype.createCamera = function() {
                        throw new Error("You're using a 3d camera. Try the html renderer.")
                    }, BaseRenderer.prototype.createAudio = function(t) {
                        return new AudioElement(t, this.globalData, this)
                    }, BaseRenderer.prototype.buildAllItems = function() {
                        var t, e = this.layers.length;
                        for (t = 0; t < e; t += 1) this.buildItem(t);
                        this.checkPendingElements()
                    }, BaseRenderer.prototype.includeLayers = function(t) {
                        this.completeLayers = !1;
                        var e, n, i = t.length,
                            r = this.layers.length;
                        for (e = 0; e < i; e += 1)
                            for (n = 0; n < r;) {
                                if (this.layers[n].id == t[e].id) {
                                    this.layers[n] = t[e];
                                    break
                                }
                                n += 1
                            }
                    }, BaseRenderer.prototype.setProjectInterface = function(t) {
                        this.globalData.projectInterface = t
                    }, BaseRenderer.prototype.initItems = function() {
                        this.globalData.progressiveLoad || this.buildAllItems()
                    }, BaseRenderer.prototype.buildElementParenting = function(t, e, n) {
                        for (var i = this.elements, r = this.layers, a = 0, s = r.length; a < s;) r[a].ind == e && (i[a] && !0 !== i[a] ? (n.push(i[a]), i[a].setAsParent(), void 0 !== r[a].parent ? this.buildElementParenting(t, r[a].parent, n) : t.setHierarchy(n)) : (this.buildItem(a), this.addPendingElement(t))), a += 1
                    }, BaseRenderer.prototype.addPendingElement = function(t) {
                        this.pendingElements.push(t)
                    }, BaseRenderer.prototype.searchExtraCompositions = function(t) {
                        var e, n = t.length;
                        for (e = 0; e < n; e += 1)
                            if (t[e].xt) {
                                var i = this.createComp(t[e]);
                                i.initExpressions(), this.globalData.projectInterface.registerComposition(i)
                            }
                    }, BaseRenderer.prototype.setupGlobalData = function(t, e) {
                        this.globalData.fontManager = new FontManager, this.globalData.fontManager.addChars(t.chars), this.globalData.fontManager.addFonts(t.fonts, e), this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem), this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem), this.globalData.imageLoader = this.animationItem.imagePreloader, this.globalData.audioController = this.animationItem.audioController, this.globalData.frameId = 0, this.globalData.frameRate = t.fr, this.globalData.nm = t.nm, this.globalData.compSize = {
                            w: t.w,
                            h: t.h
                        }
                    }, extendPrototype([BaseRenderer], SVGRenderer), SVGRenderer.prototype.createNull = function(t) {
                        return new NullElement(t, this.globalData, this)
                    }, SVGRenderer.prototype.createShape = function(t) {
                        return new SVGShapeElement(t, this.globalData, this)
                    }, SVGRenderer.prototype.createText = function(t) {
                        return new SVGTextElement(t, this.globalData, this)
                    }, SVGRenderer.prototype.createImage = function(t) {
                        return new IImageElement(t, this.globalData, this)
                    }, SVGRenderer.prototype.createComp = function(t) {
                        return new SVGCompElement(t, this.globalData, this)
                    }, SVGRenderer.prototype.createSolid = function(t) {
                        return new ISolidElement(t, this.globalData, this)
                    }, SVGRenderer.prototype.configAnimation = function(t) {
                        this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"), this.renderConfig.viewBoxSize ? this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize) : this.svgElement.setAttribute("viewBox", "0 0 " + t.w + " " + t.h), this.renderConfig.viewBoxOnly || (this.svgElement.setAttribute("width", t.w), this.svgElement.setAttribute("height", t.h), this.svgElement.style.width = "100%", this.svgElement.style.height = "100%", this.svgElement.style.transform = "translate3d(0,0,0)"), this.renderConfig.className && this.svgElement.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.svgElement.setAttribute("id", this.renderConfig.id), void 0 !== this.renderConfig.focusable && this.svgElement.setAttribute("focusable", this.renderConfig.focusable), this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio), this.animationItem.wrapper.appendChild(this.svgElement);
                        var e = this.globalData.defs;
                        this.setupGlobalData(t, e), this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.data = t;
                        var n = createNS("clipPath"),
                            i = createNS("rect");
                        i.setAttribute("width", t.w), i.setAttribute("height", t.h), i.setAttribute("x", 0), i.setAttribute("y", 0);
                        var r = createElementID();
                        n.setAttribute("id", r), n.appendChild(i), this.layerElement.setAttribute("clip-path", "url(" + locationHref + "#" + r + ")"), e.appendChild(n), this.layers = t.layers, this.elements = createSizedArray(t.layers.length)
                    }, SVGRenderer.prototype.destroy = function() {
                        this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.layerElement = null, this.globalData.defs = null;
                        var t, e = this.layers ? this.layers.length : 0;
                        for (t = 0; t < e; t++) this.elements[t] && this.elements[t].destroy();
                        this.elements.length = 0, this.destroyed = !0, this.animationItem = null
                    }, SVGRenderer.prototype.updateContainerSize = function() {}, SVGRenderer.prototype.buildItem = function(t) {
                        var e = this.elements;
                        if (!e[t] && 99 != this.layers[t].ty) {
                            e[t] = !0;
                            var n = this.createItem(this.layers[t]);
                            e[t] = n, expressionsPlugin && (0 === this.layers[t].ty && this.globalData.projectInterface.registerComposition(n), n.initExpressions()), this.appendElementInPos(n, t), this.layers[t].tt && (this.elements[t - 1] && !0 !== this.elements[t - 1] ? n.setMatte(e[t - 1].layerId) : (this.buildItem(t - 1), this.addPendingElement(n)))
                        }
                    }, SVGRenderer.prototype.checkPendingElements = function() {
                        for (; this.pendingElements.length;) {
                            var t = this.pendingElements.pop();
                            if (t.checkParenting(), t.data.tt)
                                for (var e = 0, n = this.elements.length; e < n;) {
                                    if (this.elements[e] === t) {
                                        t.setMatte(this.elements[e - 1].layerId);
                                        break
                                    }
                                    e += 1
                                }
                        }
                    }, SVGRenderer.prototype.renderFrame = function(t) {
                        if (this.renderedFrame !== t && !this.destroyed) {
                            null === t ? t = this.renderedFrame : this.renderedFrame = t, this.globalData.frameNum = t, this.globalData.frameId += 1, this.globalData.projectInterface.currentFrame = t, this.globalData._mdf = !1;
                            var e, n = this.layers.length;
                            for (this.completeLayers || this.checkLayers(t), e = n - 1; e >= 0; e--)(this.completeLayers || this.elements[e]) && this.elements[e].prepareFrame(t - this.layers[e].st);
                            if (this.globalData._mdf)
                                for (e = 0; e < n; e += 1)(this.completeLayers || this.elements[e]) && this.elements[e].renderFrame()
                        }
                    }, SVGRenderer.prototype.appendElementInPos = function(t, e) {
                        var n = t.getBaseElement();
                        if (n) {
                            for (var i, r = 0; r < e;) this.elements[r] && !0 !== this.elements[r] && this.elements[r].getBaseElement() && (i = this.elements[r].getBaseElement()), r += 1;
                            i ? this.layerElement.insertBefore(n, i) : this.layerElement.appendChild(n)
                        }
                    }, SVGRenderer.prototype.hide = function() {
                        this.layerElement.style.display = "none"
                    }, SVGRenderer.prototype.show = function() {
                        this.layerElement.style.display = "block"
                    }, extendPrototype([BaseRenderer], CanvasRenderer), CanvasRenderer.prototype.createShape = function(t) {
                        return new CVShapeElement(t, this.globalData, this)
                    }, CanvasRenderer.prototype.createText = function(t) {
                        return new CVTextElement(t, this.globalData, this)
                    }, CanvasRenderer.prototype.createImage = function(t) {
                        return new CVImageElement(t, this.globalData, this)
                    }, CanvasRenderer.prototype.createComp = function(t) {
                        return new CVCompElement(t, this.globalData, this)
                    }, CanvasRenderer.prototype.createSolid = function(t) {
                        return new CVSolidElement(t, this.globalData, this)
                    }, CanvasRenderer.prototype.createNull = SVGRenderer.prototype.createNull, CanvasRenderer.prototype.ctxTransform = function(t) {
                        if (1 !== t[0] || 0 !== t[1] || 0 !== t[4] || 1 !== t[5] || 0 !== t[12] || 0 !== t[13])
                            if (this.renderConfig.clearCanvas) {
                                this.transformMat.cloneFromProps(t);
                                var e = this.contextData.cTr.props;
                                this.transformMat.transform(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]), this.contextData.cTr.cloneFromProps(this.transformMat.props);
                                var n = this.contextData.cTr.props;
                                this.canvasContext.setTransform(n[0], n[1], n[4], n[5], n[12], n[13])
                            } else this.canvasContext.transform(t[0], t[1], t[4], t[5], t[12], t[13])
                    }, CanvasRenderer.prototype.ctxOpacity = function(t) {
                        if (!this.renderConfig.clearCanvas) return this.canvasContext.globalAlpha *= t < 0 ? 0 : t, void(this.globalData.currentGlobalAlpha = this.contextData.cO);
                        this.contextData.cO *= t < 0 ? 0 : t, this.globalData.currentGlobalAlpha !== this.contextData.cO && (this.canvasContext.globalAlpha = this.contextData.cO, this.globalData.currentGlobalAlpha = this.contextData.cO)
                    }, CanvasRenderer.prototype.reset = function() {
                        this.renderConfig.clearCanvas ? this.contextData.reset() : this.canvasContext.restore()
                    }, CanvasRenderer.prototype.save = function(t) {
                        if (this.renderConfig.clearCanvas) {
                            t && this.canvasContext.save();
                            var e = this.contextData.cTr.props;
                            this.contextData._length <= this.contextData.cArrPos && this.contextData.duplicate();
                            var n, i = this.contextData.saved[this.contextData.cArrPos];
                            for (n = 0; n < 16; n += 1) i[n] = e[n];
                            this.contextData.savedOp[this.contextData.cArrPos] = this.contextData.cO, this.contextData.cArrPos += 1
                        } else this.canvasContext.save()
                    }, CanvasRenderer.prototype.restore = function(t) {
                        if (this.renderConfig.clearCanvas) {
                            t && (this.canvasContext.restore(), this.globalData.blendMode = "source-over"), this.contextData.cArrPos -= 1;
                            var e, n = this.contextData.saved[this.contextData.cArrPos],
                                i = this.contextData.cTr.props;
                            for (e = 0; e < 16; e += 1) i[e] = n[e];
                            this.canvasContext.setTransform(n[0], n[1], n[4], n[5], n[12], n[13]), n = this.contextData.savedOp[this.contextData.cArrPos], this.contextData.cO = n, this.globalData.currentGlobalAlpha !== n && (this.canvasContext.globalAlpha = n, this.globalData.currentGlobalAlpha = n)
                        } else this.canvasContext.restore()
                    }, CanvasRenderer.prototype.configAnimation = function(t) {
                        this.animationItem.wrapper ? (this.animationItem.container = createTag("canvas"), this.animationItem.container.style.width = "100%", this.animationItem.container.style.height = "100%", this.animationItem.container.style.transformOrigin = this.animationItem.container.style.mozTransformOrigin = this.animationItem.container.style.webkitTransformOrigin = this.animationItem.container.style["-webkit-transform"] = "0px 0px 0px", this.animationItem.wrapper.appendChild(this.animationItem.container), this.canvasContext = this.animationItem.container.getContext("2d"), this.renderConfig.className && this.animationItem.container.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.animationItem.container.setAttribute("id", this.renderConfig.id)) : this.canvasContext = this.renderConfig.context, this.data = t, this.layers = t.layers, this.transformCanvas = {
                            w: t.w,
                            h: t.h,
                            sx: 0,
                            sy: 0,
                            tx: 0,
                            ty: 0
                        }, this.setupGlobalData(t, document.body), this.globalData.canvasContext = this.canvasContext, this.globalData.renderer = this, this.globalData.isDashed = !1, this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.globalData.transformCanvas = this.transformCanvas, this.elements = createSizedArray(t.layers.length), this.updateContainerSize()
                    }, CanvasRenderer.prototype.updateContainerSize = function() {
                        var t, e, n, i;
                        if (this.reset(), this.animationItem.wrapper && this.animationItem.container ? (t = this.animationItem.wrapper.offsetWidth, e = this.animationItem.wrapper.offsetHeight, this.animationItem.container.setAttribute("width", t * this.renderConfig.dpr), this.animationItem.container.setAttribute("height", e * this.renderConfig.dpr)) : (t = this.canvasContext.canvas.width * this.renderConfig.dpr, e = this.canvasContext.canvas.height * this.renderConfig.dpr), -1 !== this.renderConfig.preserveAspectRatio.indexOf("meet") || -1 !== this.renderConfig.preserveAspectRatio.indexOf("slice")) {
                            var r = this.renderConfig.preserveAspectRatio.split(" "),
                                a = r[1] || "meet",
                                s = r[0] || "xMidYMid",
                                o = s.substr(0, 4),
                                l = s.substr(4);
                            n = t / e, (i = this.transformCanvas.w / this.transformCanvas.h) > n && "meet" === a || i < n && "slice" === a ? (this.transformCanvas.sx = t / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = t / (this.transformCanvas.w / this.renderConfig.dpr)) : (this.transformCanvas.sx = e / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.sy = e / (this.transformCanvas.h / this.renderConfig.dpr)), this.transformCanvas.tx = "xMid" === o && (i < n && "meet" === a || i > n && "slice" === a) ? (t - this.transformCanvas.w * (e / this.transformCanvas.h)) / 2 * this.renderConfig.dpr : "xMax" === o && (i < n && "meet" === a || i > n && "slice" === a) ? (t - this.transformCanvas.w * (e / this.transformCanvas.h)) * this.renderConfig.dpr : 0, this.transformCanvas.ty = "YMid" === l && (i > n && "meet" === a || i < n && "slice" === a) ? (e - this.transformCanvas.h * (t / this.transformCanvas.w)) / 2 * this.renderConfig.dpr : "YMax" === l && (i > n && "meet" === a || i < n && "slice" === a) ? (e - this.transformCanvas.h * (t / this.transformCanvas.w)) * this.renderConfig.dpr : 0
                        } else "none" == this.renderConfig.preserveAspectRatio ? (this.transformCanvas.sx = t / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = e / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.tx = 0, this.transformCanvas.ty = 0) : (this.transformCanvas.sx = this.renderConfig.dpr, this.transformCanvas.sy = this.renderConfig.dpr, this.transformCanvas.tx = 0, this.transformCanvas.ty = 0);
                        this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1], this.ctxTransform(this.transformCanvas.props), this.canvasContext.beginPath(), this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h), this.canvasContext.closePath(), this.canvasContext.clip(), this.renderFrame(this.renderedFrame, !0)
                    }, CanvasRenderer.prototype.destroy = function() {
                        var t;
                        for (this.renderConfig.clearCanvas && this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), t = (this.layers ? this.layers.length : 0) - 1; t >= 0; t -= 1) this.elements[t] && this.elements[t].destroy();
                        this.elements.length = 0, this.globalData.canvasContext = null, this.animationItem.container = null, this.destroyed = !0
                    }, CanvasRenderer.prototype.renderFrame = function(t, e) {
                        if ((this.renderedFrame !== t || !0 !== this.renderConfig.clearCanvas || e) && !this.destroyed && -1 !== t) {
                            this.renderedFrame = t, this.globalData.frameNum = t - this.animationItem._isFirstFrame, this.globalData.frameId += 1, this.globalData._mdf = !this.renderConfig.clearCanvas || e, this.globalData.projectInterface.currentFrame = t;
                            var n, i = this.layers.length;
                            for (this.completeLayers || this.checkLayers(t), n = 0; n < i; n++)(this.completeLayers || this.elements[n]) && this.elements[n].prepareFrame(t - this.layers[n].st);
                            if (this.globalData._mdf) {
                                for (!0 === this.renderConfig.clearCanvas ? this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h) : this.save(), n = i - 1; n >= 0; n -= 1)(this.completeLayers || this.elements[n]) && this.elements[n].renderFrame();
                                !0 !== this.renderConfig.clearCanvas && this.restore()
                            }
                        }
                    }, CanvasRenderer.prototype.buildItem = function(t) {
                        var e = this.elements;
                        if (!e[t] && 99 != this.layers[t].ty) {
                            var n = this.createItem(this.layers[t], this, this.globalData);
                            e[t] = n, n.initExpressions()
                        }
                    }, CanvasRenderer.prototype.checkPendingElements = function() {
                        for (; this.pendingElements.length;) {
                            this.pendingElements.pop().checkParenting()
                        }
                    }, CanvasRenderer.prototype.hide = function() {
                        this.animationItem.container.style.display = "none"
                    }, CanvasRenderer.prototype.show = function() {
                        this.animationItem.container.style.display = "block"
                    }, extendPrototype([BaseRenderer], HybridRenderer), HybridRenderer.prototype.buildItem = SVGRenderer.prototype.buildItem, HybridRenderer.prototype.checkPendingElements = function() {
                        for (; this.pendingElements.length;) {
                            this.pendingElements.pop().checkParenting()
                        }
                    }, HybridRenderer.prototype.appendElementInPos = function(t, e) {
                        var n = t.getBaseElement();
                        if (n) {
                            var i = this.layers[e];
                            if (i.ddd && this.supports3d) this.addTo3dContainer(n, e);
                            else if (this.threeDElements) this.addTo3dContainer(n, e);
                            else {
                                for (var r, a, s = 0; s < e;) this.elements[s] && !0 !== this.elements[s] && this.elements[s].getBaseElement && (a = this.elements[s], r = (this.layers[s].ddd ? this.getThreeDContainerByPos(s) : a.getBaseElement()) || r), s += 1;
                                r ? i.ddd && this.supports3d || this.layerElement.insertBefore(n, r) : i.ddd && this.supports3d || this.layerElement.appendChild(n)
                            }
                        }
                    }, HybridRenderer.prototype.createShape = function(t) {
                        return this.supports3d ? new HShapeElement(t, this.globalData, this) : new SVGShapeElement(t, this.globalData, this)
                    }, HybridRenderer.prototype.createText = function(t) {
                        return this.supports3d ? new HTextElement(t, this.globalData, this) : new SVGTextElement(t, this.globalData, this)
                    }, HybridRenderer.prototype.createCamera = function(t) {
                        return this.camera = new HCameraElement(t, this.globalData, this), this.camera
                    }, HybridRenderer.prototype.createImage = function(t) {
                        return this.supports3d ? new HImageElement(t, this.globalData, this) : new IImageElement(t, this.globalData, this)
                    }, HybridRenderer.prototype.createComp = function(t) {
                        return this.supports3d ? new HCompElement(t, this.globalData, this) : new SVGCompElement(t, this.globalData, this)
                    }, HybridRenderer.prototype.createSolid = function(t) {
                        return this.supports3d ? new HSolidElement(t, this.globalData, this) : new ISolidElement(t, this.globalData, this)
                    }, HybridRenderer.prototype.createNull = SVGRenderer.prototype.createNull, HybridRenderer.prototype.getThreeDContainerByPos = function(t) {
                        for (var e = 0, n = this.threeDElements.length; e < n;) {
                            if (this.threeDElements[e].startPos <= t && this.threeDElements[e].endPos >= t) return this.threeDElements[e].perspectiveElem;
                            e += 1
                        }
                    }, HybridRenderer.prototype.createThreeDContainer = function(t, e) {
                        var n = createTag("div");
                        styleDiv(n);
                        var i = createTag("div");
                        styleDiv(i), "3d" === e && (n.style.width = this.globalData.compSize.w + "px", n.style.height = this.globalData.compSize.h + "px", n.style.transformOrigin = n.style.mozTransformOrigin = n.style.webkitTransformOrigin = "50% 50%", i.style.transform = i.style.webkitTransform = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)"), n.appendChild(i);
                        var r = {
                            container: i,
                            perspectiveElem: n,
                            startPos: t,
                            endPos: t,
                            type: e
                        };
                        return this.threeDElements.push(r), r
                    }, HybridRenderer.prototype.build3dContainers = function() {
                        var t, e, n = this.layers.length,
                            i = "";
                        for (t = 0; t < n; t += 1) this.layers[t].ddd && 3 !== this.layers[t].ty ? ("3d" !== i && (i = "3d", e = this.createThreeDContainer(t, "3d")), e.endPos = Math.max(e.endPos, t)) : ("2d" !== i && (i = "2d", e = this.createThreeDContainer(t, "2d")), e.endPos = Math.max(e.endPos, t));
                        for (t = (n = this.threeDElements.length) - 1; t >= 0; t--) this.resizerElem.appendChild(this.threeDElements[t].perspectiveElem)
                    }, HybridRenderer.prototype.addTo3dContainer = function(t, e) {
                        for (var n = 0, i = this.threeDElements.length; n < i;) {
                            if (e <= this.threeDElements[n].endPos) {
                                for (var r, a = this.threeDElements[n].startPos; a < e;) this.elements[a] && this.elements[a].getBaseElement && (r = this.elements[a].getBaseElement()), a += 1;
                                r ? this.threeDElements[n].container.insertBefore(t, r) : this.threeDElements[n].container.appendChild(t);
                                break
                            }
                            n += 1
                        }
                    }, HybridRenderer.prototype.configAnimation = function(t) {
                        var e = createTag("div"),
                            n = this.animationItem.wrapper;
                        e.style.width = t.w + "px", e.style.height = t.h + "px", this.resizerElem = e, styleDiv(e), e.style.transformStyle = e.style.webkitTransformStyle = e.style.mozTransformStyle = "flat", this.renderConfig.className && e.setAttribute("class", this.renderConfig.className), n.appendChild(e), e.style.overflow = "hidden";
                        var i = createNS("svg");
                        i.setAttribute("width", "1"), i.setAttribute("height", "1"), styleDiv(i), this.resizerElem.appendChild(i);
                        var r = createNS("defs");
                        i.appendChild(r), this.data = t, this.setupGlobalData(t, i), this.globalData.defs = r, this.layers = t.layers, this.layerElement = this.resizerElem, this.build3dContainers(), this.updateContainerSize()
                    }, HybridRenderer.prototype.destroy = function() {
                        this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.animationItem.container = null, this.globalData.defs = null;
                        var t, e = this.layers ? this.layers.length : 0;
                        for (t = 0; t < e; t++) this.elements[t].destroy();
                        this.elements.length = 0, this.destroyed = !0, this.animationItem = null
                    }, HybridRenderer.prototype.updateContainerSize = function() {
                        var t, e, n, i, r = this.animationItem.wrapper.offsetWidth,
                            a = this.animationItem.wrapper.offsetHeight,
                            s = r / a;
                        this.globalData.compSize.w / this.globalData.compSize.h > s ? (t = r / this.globalData.compSize.w, e = r / this.globalData.compSize.w, n = 0, i = (a - this.globalData.compSize.h * (r / this.globalData.compSize.w)) / 2) : (t = a / this.globalData.compSize.h, e = a / this.globalData.compSize.h, n = (r - this.globalData.compSize.w * (a / this.globalData.compSize.h)) / 2, i = 0), this.resizerElem.style.transform = this.resizerElem.style.webkitTransform = "matrix3d(" + t + ",0,0,0,0," + e + ",0,0,0,0,1,0," + n + "," + i + ",0,1)"
                    }, HybridRenderer.prototype.renderFrame = SVGRenderer.prototype.renderFrame, HybridRenderer.prototype.hide = function() {
                        this.resizerElem.style.display = "none"
                    }, HybridRenderer.prototype.show = function() {
                        this.resizerElem.style.display = "block"
                    }, HybridRenderer.prototype.initItems = function() {
                        if (this.buildAllItems(), this.camera) this.camera.setup();
                        else {
                            var t, e = this.globalData.compSize.w,
                                n = this.globalData.compSize.h,
                                i = this.threeDElements.length;
                            for (t = 0; t < i; t += 1) this.threeDElements[t].perspectiveElem.style.perspective = this.threeDElements[t].perspectiveElem.style.webkitPerspective = Math.sqrt(Math.pow(e, 2) + Math.pow(n, 2)) + "px"
                        }
                    }, HybridRenderer.prototype.searchExtraCompositions = function(t) {
                        var e, n = t.length,
                            i = createTag("div");
                        for (e = 0; e < n; e += 1)
                            if (t[e].xt) {
                                var r = this.createComp(t[e], i, this.globalData.comp, null);
                                r.initExpressions(), this.globalData.projectInterface.registerComposition(r)
                            }
                    }, MaskElement.prototype.getMaskProperty = function(t) {
                        return this.viewData[t].prop
                    }, MaskElement.prototype.renderFrame = function(t) {
                        var e, n = this.element.finalTransform.mat,
                            i = this.masksProperties.length;
                        for (e = 0; e < i; e++)
                            if ((this.viewData[e].prop._mdf || t) && this.drawPath(this.masksProperties[e], this.viewData[e].prop.v, this.viewData[e]), (this.viewData[e].op._mdf || t) && this.viewData[e].elem.setAttribute("fill-opacity", this.viewData[e].op.v), "n" !== this.masksProperties[e].mode && (this.viewData[e].invRect && (this.element.finalTransform.mProp._mdf || t) && this.viewData[e].invRect.setAttribute("transform", n.getInverseMatrix().to2dCSS()), this.storedData[e].x && (this.storedData[e].x._mdf || t))) {
                                var r = this.storedData[e].expan;
                                this.storedData[e].x.v < 0 ? ("erode" !== this.storedData[e].lastOperator && (this.storedData[e].lastOperator = "erode", this.storedData[e].elem.setAttribute("filter", "url(" + locationHref + "#" + this.storedData[e].filterId + ")")), r.setAttribute("radius", -this.storedData[e].x.v)) : ("dilate" !== this.storedData[e].lastOperator && (this.storedData[e].lastOperator = "dilate", this.storedData[e].elem.setAttribute("filter", null)), this.storedData[e].elem.setAttribute("stroke-width", 2 * this.storedData[e].x.v))
                            }
                    }, MaskElement.prototype.getMaskelement = function() {
                        return this.maskElement
                    }, MaskElement.prototype.createLayerSolidPath = function() {
                        var t = "M0,0 ";
                        return t += " h" + this.globalData.compSize.w, t += " v" + this.globalData.compSize.h, t += " h-" + this.globalData.compSize.w, t += " v-" + this.globalData.compSize.h + " "
                    }, MaskElement.prototype.drawPath = function(t, e, n) {
                        var i, r, a = " M" + e.v[0][0] + "," + e.v[0][1];
                        for (r = e._length, i = 1; i < r; i += 1) a += " C" + e.o[i - 1][0] + "," + e.o[i - 1][1] + " " + e.i[i][0] + "," + e.i[i][1] + " " + e.v[i][0] + "," + e.v[i][1];
                        if (e.c && r > 1 && (a += " C" + e.o[i - 1][0] + "," + e.o[i - 1][1] + " " + e.i[0][0] + "," + e.i[0][1] + " " + e.v[0][0] + "," + e.v[0][1]), n.lastPath !== a) {
                            var s = "";
                            n.elem && (e.c && (s = t.inv ? this.solidPath + a : a), n.elem.setAttribute("d", s)), n.lastPath = a
                        }
                    }, MaskElement.prototype.destroy = function() {
                        this.element = null, this.globalData = null, this.maskElement = null, this.data = null, this.masksProperties = null
                    }, HierarchyElement.prototype = {
                        initHierarchy: function() {
                            this.hierarchy = [], this._isParent = !1, this.checkParenting()
                        },
                        setHierarchy: function(t) {
                            this.hierarchy = t
                        },
                        setAsParent: function() {
                            this._isParent = !0
                        },
                        checkParenting: function() {
                            void 0 !== this.data.parent && this.comp.buildElementParenting(this, this.data.parent, [])
                        }
                    }, FrameElement.prototype = {
                        initFrame: function() {
                            this._isFirstFrame = !1, this.dynamicProperties = [], this._mdf = !1
                        },
                        prepareProperties: function(t, e) {
                            var n, i = this.dynamicProperties.length;
                            for (n = 0; n < i; n += 1)(e || this._isParent && "transform" === this.dynamicProperties[n].propType) && (this.dynamicProperties[n].getValue(), this.dynamicProperties[n]._mdf && (this.globalData._mdf = !0, this._mdf = !0))
                        },
                        addDynamicProperty: function(t) {
                            -1 === this.dynamicProperties.indexOf(t) && this.dynamicProperties.push(t)
                        }
                    }, TransformElement.prototype = {
                        initTransform: function() {
                            this.finalTransform = {
                                mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
                                    o: 0
                                },
                                _matMdf: !1,
                                _opMdf: !1,
                                mat: new Matrix
                            }, this.data.ao && (this.finalTransform.mProp.autoOriented = !0), this.data.ty
                        },
                        renderTransform: function() {
                            if (this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame, this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame, this.hierarchy) {
                                var t, e = this.finalTransform.mat,
                                    n = 0,
                                    i = this.hierarchy.length;
                                if (!this.finalTransform._matMdf)
                                    for (; n < i;) {
                                        if (this.hierarchy[n].finalTransform.mProp._mdf) {
                                            this.finalTransform._matMdf = !0;
                                            break
                                        }
                                        n += 1
                                    }
                                if (this.finalTransform._matMdf)
                                    for (t = this.finalTransform.mProp.v.props, e.cloneFromProps(t), n = 0; n < i; n += 1) t = this.hierarchy[n].finalTransform.mProp.v.props, e.transform(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15])
                            }
                        },
                        globalToLocal: function(t) {
                            var e = [];
                            e.push(this.finalTransform);
                            for (var n = !0, i = this.comp; n;) i.finalTransform ? (i.data.hasMask && e.splice(0, 0, i.finalTransform), i = i.comp) : n = !1;
                            var r, a, s = e.length;
                            for (r = 0; r < s; r += 1) a = e[r].mat.applyToPointArray(0, 0, 0), t = [t[0] - a[0], t[1] - a[1], 0];
                            return t
                        },
                        mHelper: new Matrix
                    }, RenderableElement.prototype = {
                        initRenderable: function() {
                            this.isInRange = !1, this.hidden = !1, this.isTransparent = !1, this.renderableComponents = []
                        },
                        addRenderableComponent: function(t) {
                            -1 === this.renderableComponents.indexOf(t) && this.renderableComponents.push(t)
                        },
                        removeRenderableComponent: function(t) {
                            -1 !== this.renderableComponents.indexOf(t) && this.renderableComponents.splice(this.renderableComponents.indexOf(t), 1)
                        },
                        prepareRenderableFrame: function(t) {
                            this.checkLayerLimits(t)
                        },
                        checkTransparency: function() {
                            this.finalTransform.mProp.o.v <= 0 ? !this.isTransparent && this.globalData.renderConfig.hideOnTransparent && (this.isTransparent = !0, this.hide()) : this.isTransparent && (this.isTransparent = !1, this.show())
                        },
                        checkLayerLimits: function(t) {
                            this.data.ip - this.data.st <= t && this.data.op - this.data.st > t ? !0 !== this.isInRange && (this.globalData._mdf = !0, this._mdf = !0, this.isInRange = !0, this.show()) : !1 !== this.isInRange && (this.globalData._mdf = !0, this.isInRange = !1, this.hide())
                        },
                        renderRenderable: function() {
                            var t, e = this.renderableComponents.length;
                            for (t = 0; t < e; t += 1) this.renderableComponents[t].renderFrame(this._isFirstFrame)
                        },
                        sourceRectAtTime: function() {
                            return {
                                top: 0,
                                left: 0,
                                width: 100,
                                height: 100
                            }
                        },
                        getLayerSize: function() {
                            return 5 === this.data.ty ? {
                                w: this.data.textData.width,
                                h: this.data.textData.height
                            } : {
                                w: this.data.width,
                                h: this.data.height
                            }
                        }
                    }, extendPrototype([RenderableElement, createProxyFunction({
                        initElement: function(t, e, n) {
                            this.initFrame(), this.initBaseData(t, e, n), this.initTransform(t, e, n), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide()
                        },
                        hide: function() {
                            this.hidden || this.isInRange && !this.isTransparent || ((this.baseElement || this.layerElement).style.display = "none", this.hidden = !0)
                        },
                        show: function() {
                            this.isInRange && !this.isTransparent && (this.data.hd || ((this.baseElement || this.layerElement).style.display = "block"), this.hidden = !1, this._isFirstFrame = !0)
                        },
                        renderFrame: function() {
                            this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1))
                        },
                        renderInnerContent: function() {},
                        prepareFrame: function(t) {
                            this._mdf = !1, this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange), this.checkTransparency()
                        },
                        destroy: function() {
                            this.innerElem = null, this.destroyBaseElement()
                        }
                    })], RenderableDOMElement), SVGStyleData.prototype.reset = function() {
                        this.d = "", this._mdf = !1
                    }, SVGShapeData.prototype.setAsAnimated = function() {
                        this._isAnimated = !0
                    }, extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData), extendPrototype([DynamicPropertyContainer], SVGFillStyleData), SVGGradientFillStyleData.prototype.initGradientData = function(t, e, n) {
                        this.o = PropertyFactory.getProp(t, e.o, 0, .01, this), this.s = PropertyFactory.getProp(t, e.s, 1, null, this), this.e = PropertyFactory.getProp(t, e.e, 1, null, this), this.h = PropertyFactory.getProp(t, e.h || {
                            k: 0
                        }, 0, .01, this), this.a = PropertyFactory.getProp(t, e.a || {
                            k: 0
                        }, 0, degToRads, this), this.g = new GradientProperty(t, e.g, this), this.style = n, this.stops = [], this.setGradientData(n.pElem, e), this.setGradientOpacity(e, n), this._isAnimated = !!this._isAnimated
                    }, SVGGradientFillStyleData.prototype.setGradientData = function(t, e) {
                        var n = createElementID(),
                            i = createNS(1 === e.t ? "linearGradient" : "radialGradient");
                        i.setAttribute("id", n), i.setAttribute("spreadMethod", "pad"), i.setAttribute("gradientUnits", "userSpaceOnUse");
                        var r, a, s, o = [];
                        for (s = 4 * e.g.p, a = 0; a < s; a += 4) r = createNS("stop"), i.appendChild(r), o.push(r);
                        t.setAttribute("gf" === e.ty ? "fill" : "stroke", "url(" + locationHref + "#" + n + ")"), this.gf = i, this.cst = o
                    }, SVGGradientFillStyleData.prototype.setGradientOpacity = function(t, e) {
                        if (this.g._hasOpacity && !this.g._collapsable) {
                            var n, i, r, a = createNS("mask"),
                                s = createNS("path");
                            a.appendChild(s);
                            var o = createElementID(),
                                l = createElementID();
                            a.setAttribute("id", l);
                            var h = createNS(1 === t.t ? "linearGradient" : "radialGradient");
                            h.setAttribute("id", o), h.setAttribute("spreadMethod", "pad"), h.setAttribute("gradientUnits", "userSpaceOnUse"), r = t.g.k.k[0].s ? t.g.k.k[0].s.length : t.g.k.k.length;
                            var u = this.stops;
                            for (i = 4 * t.g.p; i < r; i += 2)(n = createNS("stop")).setAttribute("stop-color", "rgb(255,255,255)"), h.appendChild(n), u.push(n);
                            s.setAttribute("gf" === t.ty ? "fill" : "stroke", "url(" + locationHref + "#" + o + ")"), this.of = h, this.ms = a, this.ost = u, this.maskId = l, e.msElem = s
                        }
                    }, extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData), extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
                    var SVGElementsRenderer = function() {
                        var t = new Matrix,
                            e = new Matrix;

                        function n(t, e, n) {
                            (n || e.transform.op._mdf) && e.transform.container.setAttribute("opacity", e.transform.op.v), (n || e.transform.mProps._mdf) && e.transform.container.setAttribute("transform", e.transform.mProps.v.to2dCSS())
                        }

                        function i(n, i, r) {
                            var a, s, o, l, h, u, c, p, f, d, m, g = i.styles.length,
                                v = i.lvl;
                            for (u = 0; u < g; u += 1) {
                                if (l = i.sh._mdf || r, i.styles[u].lvl < v) {
                                    for (p = e.reset(), d = v - i.styles[u].lvl, m = i.transformers.length - 1; !l && d > 0;) l = i.transformers[m].mProps._mdf || l, d--, m--;
                                    if (l)
                                        for (d = v - i.styles[u].lvl, m = i.transformers.length - 1; d > 0;) f = i.transformers[m].mProps.v.props, p.transform(f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8], f[9], f[10], f[11], f[12], f[13], f[14], f[15]), d--, m--
                                } else p = t;
                                if (s = (c = i.sh.paths)._length, l) {
                                    for (o = "", a = 0; a < s; a += 1)(h = c.shapes[a]) && h._length && (o += buildShapeString(h, h._length, h.c, p));
                                    i.caches[u] = o
                                } else o = i.caches[u];
                                i.styles[u].d += !0 === n.hd ? "" : o, i.styles[u]._mdf = l || i.styles[u]._mdf
                            }
                        }

                        function r(t, e, n) {
                            var i = e.style;
                            (e.c._mdf || n) && i.pElem.setAttribute("fill", "rgb(" + bm_floor(e.c.v[0]) + "," + bm_floor(e.c.v[1]) + "," + bm_floor(e.c.v[2]) + ")"), (e.o._mdf || n) && i.pElem.setAttribute("fill-opacity", e.o.v)
                        }

                        function a(t, e, n) {
                            s(t, e, n), o(t, e, n)
                        }

                        function s(t, e, n) {
                            var i, r, a, s, o, l = e.gf,
                                h = e.g._hasOpacity,
                                u = e.s.v,
                                c = e.e.v;
                            if (e.o._mdf || n) {
                                var p = "gf" === t.ty ? "fill-opacity" : "stroke-opacity";
                                e.style.pElem.setAttribute(p, e.o.v)
                            }
                            if (e.s._mdf || n) {
                                var f = 1 === t.t ? "x1" : "cx",
                                    d = "x1" === f ? "y1" : "cy";
                                l.setAttribute(f, u[0]), l.setAttribute(d, u[1]), h && !e.g._collapsable && (e.of.setAttribute(f, u[0]), e.of.setAttribute(d, u[1]))
                            }
                            if (e.g._cmdf || n) {
                                i = e.cst;
                                var m = e.g.c;
                                for (a = i.length, r = 0; r < a; r += 1)(s = i[r]).setAttribute("offset", m[4 * r] + "%"), s.setAttribute("stop-color", "rgb(" + m[4 * r + 1] + "," + m[4 * r + 2] + "," + m[4 * r + 3] + ")")
                            }
                            if (h && (e.g._omdf || n)) {
                                var g = e.g.o;
                                for (a = (i = e.g._collapsable ? e.cst : e.ost).length, r = 0; r < a; r += 1) s = i[r], e.g._collapsable || s.setAttribute("offset", g[2 * r] + "%"), s.setAttribute("stop-opacity", g[2 * r + 1])
                            }
                            if (1 === t.t)(e.e._mdf || n) && (l.setAttribute("x2", c[0]), l.setAttribute("y2", c[1]), h && !e.g._collapsable && (e.of.setAttribute("x2", c[0]), e.of.setAttribute("y2", c[1])));
                            else if ((e.s._mdf || e.e._mdf || n) && (o = Math.sqrt(Math.pow(u[0] - c[0], 2) + Math.pow(u[1] - c[1], 2)), l.setAttribute("r", o), h && !e.g._collapsable && e.of.setAttribute("r", o)), e.e._mdf || e.h._mdf || e.a._mdf || n) {
                                o || (o = Math.sqrt(Math.pow(u[0] - c[0], 2) + Math.pow(u[1] - c[1], 2)));
                                var v = Math.atan2(c[1] - u[1], c[0] - u[0]),
                                    y = o * (e.h.v >= 1 ? .99 : e.h.v <= -1 ? -.99 : e.h.v),
                                    _ = Math.cos(v + e.a.v) * y + u[0],
                                    x = Math.sin(v + e.a.v) * y + u[1];
                                l.setAttribute("fx", _), l.setAttribute("fy", x), h && !e.g._collapsable && (e.of.setAttribute("fx", _), e.of.setAttribute("fy", x))
                            }
                        }

                        function o(t, e, n) {
                            var i = e.style,
                                r = e.d;
                            r && (r._mdf || n) && r.dashStr && (i.pElem.setAttribute("stroke-dasharray", r.dashStr), i.pElem.setAttribute("stroke-dashoffset", r.dashoffset[0])), e.c && (e.c._mdf || n) && i.pElem.setAttribute("stroke", "rgb(" + bm_floor(e.c.v[0]) + "," + bm_floor(e.c.v[1]) + "," + bm_floor(e.c.v[2]) + ")"), (e.o._mdf || n) && i.pElem.setAttribute("stroke-opacity", e.o.v), (e.w._mdf || n) && (i.pElem.setAttribute("stroke-width", e.w.v), i.msElem && i.msElem.setAttribute("stroke-width", e.w.v))
                        }
                        return {
                            createRenderFunction: function(t) {
                                t.ty;
                                switch (t.ty) {
                                    case "fl":
                                        return r;
                                    case "gf":
                                        return s;
                                    case "gs":
                                        return a;
                                    case "st":
                                        return o;
                                    case "sh":
                                    case "el":
                                    case "rc":
                                    case "sr":
                                        return i;
                                    case "tr":
                                        return n
                                }
                            }
                        }
                    }();

                    function ShapeTransformManager() {
                        this.sequences = {}, this.sequenceList = [], this.transform_key_count = 0
                    }

                    function CVShapeData(t, e, n, i) {
                        this.styledShapes = [], this.tr = [0, 0, 0, 0, 0, 0];
                        var r = 4;
                        "rc" == e.ty ? r = 5 : "el" == e.ty ? r = 6 : "sr" == e.ty && (r = 7), this.sh = ShapePropertyFactory.getShapeProp(t, e, r, t);
                        var a, s, o = n.length;
                        for (a = 0; a < o; a += 1) n[a].closed || (s = {
                            transforms: i.addTransformSequence(n[a].transforms),
                            trNodes: []
                        }, this.styledShapes.push(s), n[a].elements.push(s))
                    }

                    function BaseElement() {}

                    function NullElement(t, e, n) {
                        this.initFrame(), this.initBaseData(t, e, n), this.initFrame(), this.initTransform(t, e, n), this.initHierarchy()
                    }

                    function SVGBaseElement() {}

                    function IShapeElement() {}

                    function ITextElement() {}

                    function ICompElement() {}

                    function IImageElement(t, e, n) {
                        this.assetData = e.getAssetData(t.refId), this.initElement(t, e, n), this.sourceRect = {
                            top: 0,
                            left: 0,
                            width: this.assetData.w,
                            height: this.assetData.h
                        }
                    }

                    function ISolidElement(t, e, n) {
                        this.initElement(t, e, n)
                    }

                    function AudioElement(t, e, n) {
                        this.initFrame(), this.initRenderable(), this.assetData = e.getAssetData(t.refId), this.initBaseData(t, e, n), this._isPlaying = !1, this._canPlay = !1;
                        var i = this.globalData.getAssetsPath(this.assetData);
                        this.audio = this.globalData.audioController.createAudio(i), this._currentTime = 0, this.globalData.audioController.addAudio(this), this.tm = t.tm ? PropertyFactory.getProp(this, t.tm, 0, e.frameRate, this) : {
                            _placeholder: !0
                        }
                    }

                    function SVGCompElement(t, e, n) {
                        this.layers = t.layers, this.supports3d = !0, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(t, e, n), this.tm = t.tm ? PropertyFactory.getProp(this, t.tm, 0, e.frameRate, this) : {
                            _placeholder: !0
                        }
                    }

                    function SVGTextElement(t, e, n) {
                        this.textSpans = [], this.renderType = "svg", this.initElement(t, e, n)
                    }

                    function SVGShapeElement(t, e, n) {
                        this.shapes = [], this.shapesData = t.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.initElement(t, e, n), this.prevViewData = []
                    }

                    function SVGTintFilter(t, e) {
                        this.filterManager = e;
                        var n = createNS("feColorMatrix");
                        if (n.setAttribute("type", "matrix"), n.setAttribute("color-interpolation-filters", "linearRGB"), n.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"), n.setAttribute("result", "f1"), t.appendChild(n), (n = createNS("feColorMatrix")).setAttribute("type", "matrix"), n.setAttribute("color-interpolation-filters", "sRGB"), n.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), n.setAttribute("result", "f2"), t.appendChild(n), this.matrixFilter = n, 100 !== e.effectElements[2].p.v || e.effectElements[2].p.k) {
                            var i, r = createNS("feMerge");
                            t.appendChild(r), (i = createNS("feMergeNode")).setAttribute("in", "SourceGraphic"), r.appendChild(i), (i = createNS("feMergeNode")).setAttribute("in", "f2"), r.appendChild(i)
                        }
                    }

                    function SVGFillFilter(t, e) {
                        this.filterManager = e;
                        var n = createNS("feColorMatrix");
                        n.setAttribute("type", "matrix"), n.setAttribute("color-interpolation-filters", "sRGB"), n.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), t.appendChild(n), this.matrixFilter = n
                    }

                    function SVGGaussianBlurEffect(t, e) {
                        t.setAttribute("x", "-100%"), t.setAttribute("y", "-100%"), t.setAttribute("width", "300%"), t.setAttribute("height", "300%"), this.filterManager = e;
                        var n = createNS("feGaussianBlur");
                        t.appendChild(n), this.feGaussianBlur = n
                    }

                    function SVGStrokeEffect(t, e) {
                        this.initialized = !1, this.filterManager = e, this.elem = t, this.paths = []
                    }

                    function SVGTritoneFilter(t, e) {
                        this.filterManager = e;
                        var n = createNS("feColorMatrix");
                        n.setAttribute("type", "matrix"), n.setAttribute("color-interpolation-filters", "linearRGB"), n.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"), n.setAttribute("result", "f1"), t.appendChild(n);
                        var i = createNS("feComponentTransfer");
                        i.setAttribute("color-interpolation-filters", "sRGB"), t.appendChild(i), this.matrixFilter = i;
                        var r = createNS("feFuncR");
                        r.setAttribute("type", "table"), i.appendChild(r), this.feFuncR = r;
                        var a = createNS("feFuncG");
                        a.setAttribute("type", "table"), i.appendChild(a), this.feFuncG = a;
                        var s = createNS("feFuncB");
                        s.setAttribute("type", "table"), i.appendChild(s), this.feFuncB = s
                    }

                    function SVGProLevelsFilter(t, e) {
                        this.filterManager = e;
                        var n = this.filterManager.effectElements,
                            i = createNS("feComponentTransfer");
                        (n[10].p.k || 0 !== n[10].p.v || n[11].p.k || 1 !== n[11].p.v || n[12].p.k || 1 !== n[12].p.v || n[13].p.k || 0 !== n[13].p.v || n[14].p.k || 1 !== n[14].p.v) && (this.feFuncR = this.createFeFunc("feFuncR", i)), (n[17].p.k || 0 !== n[17].p.v || n[18].p.k || 1 !== n[18].p.v || n[19].p.k || 1 !== n[19].p.v || n[20].p.k || 0 !== n[20].p.v || n[21].p.k || 1 !== n[21].p.v) && (this.feFuncG = this.createFeFunc("feFuncG", i)), (n[24].p.k || 0 !== n[24].p.v || n[25].p.k || 1 !== n[25].p.v || n[26].p.k || 1 !== n[26].p.v || n[27].p.k || 0 !== n[27].p.v || n[28].p.k || 1 !== n[28].p.v) && (this.feFuncB = this.createFeFunc("feFuncB", i)), (n[31].p.k || 0 !== n[31].p.v || n[32].p.k || 1 !== n[32].p.v || n[33].p.k || 1 !== n[33].p.v || n[34].p.k || 0 !== n[34].p.v || n[35].p.k || 1 !== n[35].p.v) && (this.feFuncA = this.createFeFunc("feFuncA", i)), (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) && (i.setAttribute("color-interpolation-filters", "sRGB"), t.appendChild(i), i = createNS("feComponentTransfer")), (n[3].p.k || 0 !== n[3].p.v || n[4].p.k || 1 !== n[4].p.v || n[5].p.k || 1 !== n[5].p.v || n[6].p.k || 0 !== n[6].p.v || n[7].p.k || 1 !== n[7].p.v) && (i.setAttribute("color-interpolation-filters", "sRGB"), t.appendChild(i), this.feFuncRComposed = this.createFeFunc("feFuncR", i), this.feFuncGComposed = this.createFeFunc("feFuncG", i), this.feFuncBComposed = this.createFeFunc("feFuncB", i))
                    }

                    function SVGDropShadowEffect(t, e) {
                        var n = e.container.globalData.renderConfig.filterSize;
                        t.setAttribute("x", n.x), t.setAttribute("y", n.y), t.setAttribute("width", n.width), t.setAttribute("height", n.height), this.filterManager = e;
                        var i = createNS("feGaussianBlur");
                        i.setAttribute("in", "SourceAlpha"), i.setAttribute("result", "drop_shadow_1"), i.setAttribute("stdDeviation", "0"), this.feGaussianBlur = i, t.appendChild(i);
                        var r = createNS("feOffset");
                        r.setAttribute("dx", "25"), r.setAttribute("dy", "0"), r.setAttribute("in", "drop_shadow_1"), r.setAttribute("result", "drop_shadow_2"), this.feOffset = r, t.appendChild(r);
                        var a = createNS("feFlood");
                        a.setAttribute("flood-color", "#00ff00"), a.setAttribute("flood-opacity", "1"), a.setAttribute("result", "drop_shadow_3"), this.feFlood = a, t.appendChild(a);
                        var s = createNS("feComposite");
                        s.setAttribute("in", "drop_shadow_3"), s.setAttribute("in2", "drop_shadow_2"), s.setAttribute("operator", "in"), s.setAttribute("result", "drop_shadow_4"), t.appendChild(s);
                        var o, l = createNS("feMerge");
                        t.appendChild(l), o = createNS("feMergeNode"), l.appendChild(o), (o = createNS("feMergeNode")).setAttribute("in", "SourceGraphic"), this.feMergeNode = o, this.feMerge = l, this.originalNodeAdded = !1, l.appendChild(o)
                    }
                    ShapeTransformManager.prototype = {
                        addTransformSequence: function(t) {
                            var e, n = t.length,
                                i = "_";
                            for (e = 0; e < n; e += 1) i += t[e].transform.key + "_";
                            var r = this.sequences[i];
                            return r || (r = {
                                transforms: [].concat(t),
                                finalTransform: new Matrix,
                                _mdf: !1
                            }, this.sequences[i] = r, this.sequenceList.push(r)), r
                        },
                        processSequence: function(t, e) {
                            for (var n, i = 0, r = t.transforms.length, a = e; i < r && !e;) {
                                if (t.transforms[i].transform.mProps._mdf) {
                                    a = !0;
                                    break
                                }
                                i += 1
                            }
                            if (a)
                                for (t.finalTransform.reset(), i = r - 1; i >= 0; i -= 1) n = t.transforms[i].transform.mProps.v.props, t.finalTransform.transform(n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], n[8], n[9], n[10], n[11], n[12], n[13], n[14], n[15]);
                            t._mdf = a
                        },
                        processSequences: function(t) {
                            var e, n = this.sequenceList.length;
                            for (e = 0; e < n; e += 1) this.processSequence(this.sequenceList[e], t)
                        },
                        getNewKey: function() {
                            return "_" + this.transform_key_count++
                        }
                    }, CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated, BaseElement.prototype = {
                        checkMasks: function() {
                            if (!this.data.hasMask) return !1;
                            for (var t = 0, e = this.data.masksProperties.length; t < e;) {
                                if ("n" !== this.data.masksProperties[t].mode && !1 !== this.data.masksProperties[t].cl) return !0;
                                t += 1
                            }
                            return !1
                        },
                        initExpressions: function() {
                            this.layerInterface = LayerExpressionInterface(this), this.data.hasMask && this.maskManager && this.layerInterface.registerMaskInterface(this.maskManager);
                            var t = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);
                            this.layerInterface.registerEffectsInterface(t), 0 === this.data.ty || this.data.xt ? this.compInterface = CompExpressionInterface(this) : 4 === this.data.ty ? (this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface), this.layerInterface.content = this.layerInterface.shapeInterface) : 5 === this.data.ty && (this.layerInterface.textInterface = TextExpressionInterface(this), this.layerInterface.text = this.layerInterface.textInterface)
                        },
                        setBlendMode: function() {
                            var t = getBlendMode(this.data.bm);
                            (this.baseElement || this.layerElement).style["mix-blend-mode"] = t
                        },
                        initBaseData: function(t, e, n) {
                            this.globalData = e, this.comp = n, this.data = t, this.layerId = createElementID(), this.data.sr || (this.data.sr = 1), this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties)
                        },
                        getType: function() {
                            return this.type
                        },
                        sourceRectAtTime: function() {}
                    }, NullElement.prototype.prepareFrame = function(t) {
                        this.prepareProperties(t, !0)
                    }, NullElement.prototype.renderFrame = function() {}, NullElement.prototype.getBaseElement = function() {
                        return null
                    }, NullElement.prototype.destroy = function() {}, NullElement.prototype.sourceRectAtTime = function() {}, NullElement.prototype.hide = function() {}, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement), SVGBaseElement.prototype = {
                        initRendererElement: function() {
                            this.layerElement = createNS("g")
                        },
                        createContainerElements: function() {
                            this.matteElement = createNS("g"), this.transformedElement = this.layerElement, this.maskedElement = this.layerElement, this._sizeChanged = !1;
                            var t, e, n, i = null;
                            if (this.data.td) {
                                if (3 == this.data.td || 1 == this.data.td) {
                                    var r = createNS("mask");
                                    r.setAttribute("id", this.layerId), r.setAttribute("mask-type", 3 == this.data.td ? "luminance" : "alpha"), r.appendChild(this.layerElement), i = r, this.globalData.defs.appendChild(r), featureSupport.maskType || 1 != this.data.td || (r.setAttribute("mask-type", "luminance"), t = createElementID(), e = filtersFactory.createFilter(t), this.globalData.defs.appendChild(e), e.appendChild(filtersFactory.createAlphaToLuminanceFilter()), (n = createNS("g")).appendChild(this.layerElement), i = n, r.appendChild(n), n.setAttribute("filter", "url(" + locationHref + "#" + t + ")"))
                                } else if (2 == this.data.td) {
                                    var a = createNS("mask");
                                    a.setAttribute("id", this.layerId), a.setAttribute("mask-type", "alpha");
                                    var s = createNS("g");
                                    a.appendChild(s), t = createElementID(), e = filtersFactory.createFilter(t);
                                    var o = createNS("feComponentTransfer");
                                    o.setAttribute("in", "SourceGraphic"), e.appendChild(o);
                                    var l = createNS("feFuncA");
                                    l.setAttribute("type", "table"), l.setAttribute("tableValues", "1.0 0.0"), o.appendChild(l), this.globalData.defs.appendChild(e);
                                    var h = createNS("rect");
                                    h.setAttribute("width", this.comp.data.w), h.setAttribute("height", this.comp.data.h), h.setAttribute("x", "0"), h.setAttribute("y", "0"), h.setAttribute("fill", "#ffffff"), h.setAttribute("opacity", "0"), s.setAttribute("filter", "url(" + locationHref + "#" + t + ")"), s.appendChild(h), s.appendChild(this.layerElement), i = s, featureSupport.maskType || (a.setAttribute("mask-type", "luminance"), e.appendChild(filtersFactory.createAlphaToLuminanceFilter()), n = createNS("g"), s.appendChild(h), n.appendChild(this.layerElement), i = n, s.appendChild(n)), this.globalData.defs.appendChild(a)
                                }
                            } else this.data.tt ? (this.matteElement.appendChild(this.layerElement), i = this.matteElement, this.baseElement = this.matteElement) : this.baseElement = this.layerElement;
                            if (this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), 0 === this.data.ty && !this.data.hd) {
                                var u = createNS("clipPath"),
                                    c = createNS("path");
                                c.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
                                var p = createElementID();
                                if (u.setAttribute("id", p), u.appendChild(c), this.globalData.defs.appendChild(u), this.checkMasks()) {
                                    var f = createNS("g");
                                    f.setAttribute("clip-path", "url(" + locationHref + "#" + p + ")"), f.appendChild(this.layerElement), this.transformedElement = f, i ? i.appendChild(this.transformedElement) : this.baseElement = this.transformedElement
                                } else this.layerElement.setAttribute("clip-path", "url(" + locationHref + "#" + p + ")")
                            }
                            0 !== this.data.bm && this.setBlendMode()
                        },
                        renderElement: function() {
                            this.finalTransform._matMdf && this.transformedElement.setAttribute("transform", this.finalTransform.mat.to2dCSS()), this.finalTransform._opMdf && this.transformedElement.setAttribute("opacity", this.finalTransform.mProp.o.v)
                        },
                        destroyBaseElement: function() {
                            this.layerElement = null, this.matteElement = null, this.maskManager.destroy()
                        },
                        getBaseElement: function() {
                            return this.data.hd ? null : this.baseElement
                        },
                        createRenderableComponents: function() {
                            this.maskManager = new MaskElement(this.data, this, this.globalData), this.renderableEffectsManager = new SVGEffects(this)
                        },
                        setMatte: function(t) {
                            this.matteElement && this.matteElement.setAttribute("mask", "url(" + locationHref + "#" + t + ")")
                        }
                    }, IShapeElement.prototype = {
                        addShapeToModifiers: function(t) {
                            var e, n = this.shapeModifiers.length;
                            for (e = 0; e < n; e += 1) this.shapeModifiers[e].addShape(t)
                        },
                        isShapeInAnimatedModifiers: function(t) {
                            for (var e = this.shapeModifiers.length; 0 < e;)
                                if (this.shapeModifiers[0].isAnimatedWithShape(t)) return !0;
                            return !1
                        },
                        renderModifiers: function() {
                            if (this.shapeModifiers.length) {
                                var t, e = this.shapes.length;
                                for (t = 0; t < e; t += 1) this.shapes[t].sh.reset();
                                for (t = (e = this.shapeModifiers.length) - 1; t >= 0; t -= 1) this.shapeModifiers[t].processShapes(this._isFirstFrame)
                            }
                        },
                        lcEnum: {
                            1: "butt",
                            2: "round",
                            3: "square"
                        },
                        ljEnum: {
                            1: "miter",
                            2: "round",
                            3: "bevel"
                        },
                        searchProcessedElement: function(t) {
                            for (var e = this.processedElements, n = 0, i = e.length; n < i;) {
                                if (e[n].elem === t) return e[n].pos;
                                n += 1
                            }
                            return 0
                        },
                        addProcessedElement: function(t, e) {
                            for (var n = this.processedElements, i = n.length; i;)
                                if (n[i -= 1].elem === t) return void(n[i].pos = e);
                            n.push(new ProcessedElement(t, e))
                        },
                        prepareFrame: function(t) {
                            this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange)
                        }
                    }, ITextElement.prototype.initElement = function(t, e, n) {
                        this.lettersChangedFlag = !0, this.initFrame(), this.initBaseData(t, e, n), this.textProperty = new TextProperty(this, t.t, this.dynamicProperties), this.textAnimator = new TextAnimatorProperty(t.t, this.renderType, this), this.initTransform(t, e, n), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide(), this.textAnimator.searchProperties(this.dynamicProperties)
                    }, ITextElement.prototype.prepareFrame = function(t) {
                        this._mdf = !1, this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange), (this.textProperty._mdf || this.textProperty._isFirstFrame) && (this.buildNewText(), this.textProperty._isFirstFrame = !1, this.textProperty._mdf = !1)
                    }, ITextElement.prototype.createPathShape = function(t, e) {
                        var n, i, r = e.length,
                            a = "";
                        for (n = 0; n < r; n += 1) i = e[n].ks.k, a += buildShapeString(i, i.i.length, !0, t);
                        return a
                    }, ITextElement.prototype.updateDocumentData = function(t, e) {
                        this.textProperty.updateDocumentData(t, e)
                    }, ITextElement.prototype.canResizeFont = function(t) {
                        this.textProperty.canResizeFont(t)
                    }, ITextElement.prototype.setMinimumFontSize = function(t) {
                        this.textProperty.setMinimumFontSize(t)
                    }, ITextElement.prototype.applyTextPropertiesToMatrix = function(t, e, n, i, r) {
                        switch (t.ps && e.translate(t.ps[0], t.ps[1] + t.ascent, 0), e.translate(0, -t.ls, 0), t.j) {
                            case 1:
                                e.translate(t.justifyOffset + (t.boxWidth - t.lineWidths[n]), 0, 0);
                                break;
                            case 2:
                                e.translate(t.justifyOffset + (t.boxWidth - t.lineWidths[n]) / 2, 0, 0)
                        }
                        e.translate(i, r, 0)
                    }, ITextElement.prototype.buildColor = function(t) {
                        return "rgb(" + Math.round(255 * t[0]) + "," + Math.round(255 * t[1]) + "," + Math.round(255 * t[2]) + ")"
                    }, ITextElement.prototype.emptyProp = new LetterProps, ITextElement.prototype.destroy = function() {}, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement), ICompElement.prototype.initElement = function(t, e, n) {
                        this.initFrame(), this.initBaseData(t, e, n), this.initTransform(t, e, n), this.initRenderable(), this.initHierarchy(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), !this.data.xt && e.progressiveLoad || this.buildAllItems(), this.hide()
                    }, ICompElement.prototype.prepareFrame = function(t) {
                        if (this._mdf = !1, this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange), this.isInRange || this.data.xt) {
                            if (this.tm._placeholder) this.renderedFrame = t / this.data.sr;
                            else {
                                var e = this.tm.v;
                                e === this.data.op && (e = this.data.op - 1), this.renderedFrame = e
                            }
                            var n, i = this.elements.length;
                            for (this.completeLayers || this.checkLayers(this.renderedFrame), n = i - 1; n >= 0; n -= 1)(this.completeLayers || this.elements[n]) && (this.elements[n].prepareFrame(this.renderedFrame - this.layers[n].st), this.elements[n]._mdf && (this._mdf = !0))
                        }
                    }, ICompElement.prototype.renderInnerContent = function() {
                        var t, e = this.layers.length;
                        for (t = 0; t < e; t += 1)(this.completeLayers || this.elements[t]) && this.elements[t].renderFrame()
                    }, ICompElement.prototype.setElements = function(t) {
                        this.elements = t
                    }, ICompElement.prototype.getElements = function() {
                        return this.elements
                    }, ICompElement.prototype.destroyElements = function() {
                        var t, e = this.layers.length;
                        for (t = 0; t < e; t += 1) this.elements[t] && this.elements[t].destroy()
                    }, ICompElement.prototype.destroy = function() {
                        this.destroyElements(), this.destroyBaseElement()
                    }, extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement), IImageElement.prototype.createContent = function() {
                        var t = this.globalData.getAssetsPath(this.assetData);
                        this.innerElem = createNS("image"), this.innerElem.setAttribute("width", this.assetData.w + "px"), this.innerElem.setAttribute("height", this.assetData.h + "px"), this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio), this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", t), this.layerElement.appendChild(this.innerElem)
                    }, IImageElement.prototype.sourceRectAtTime = function() {
                        return this.sourceRect
                    }, extendPrototype([IImageElement], ISolidElement), ISolidElement.prototype.createContent = function() {
                        var t = createNS("rect");
                        t.setAttribute("width", this.data.sw), t.setAttribute("height", this.data.sh), t.setAttribute("fill", this.data.sc), this.layerElement.appendChild(t)
                    }, AudioElement.prototype.prepareFrame = function(t) {
                        if (this.prepareRenderableFrame(t, !0), this.prepareProperties(t, !0), this.tm._placeholder) this._currentTime = t / this.data.sr;
                        else {
                            var e = this.tm.v;
                            this._currentTime = e
                        }
                    }, extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement), AudioElement.prototype.renderFrame = function() {
                        this.isInRange && this._canPlay && (this._isPlaying ? (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > .1) && this.audio.seek(this._currentTime / this.globalData.frameRate) : (this.audio.play(), this.audio.seek(this._currentTime / this.globalData.frameRate), this._isPlaying = !0))
                    }, AudioElement.prototype.show = function() {}, AudioElement.prototype.hide = function() {
                        this.audio.pause(), this._isPlaying = !1
                    }, AudioElement.prototype.pause = function() {
                        this.audio.pause(), this._isPlaying = !1, this._canPlay = !1
                    }, AudioElement.prototype.resume = function() {
                        this._canPlay = !0
                    }, AudioElement.prototype.setRate = function(t) {
                        this.audio.rate(t)
                    }, AudioElement.prototype.volume = function(t) {
                        this.audio.volume(t)
                    }, AudioElement.prototype.getBaseElement = function() {
                        return null
                    }, AudioElement.prototype.destroy = function() {}, AudioElement.prototype.sourceRectAtTime = function() {}, AudioElement.prototype.initExpressions = function() {}, extendPrototype([SVGRenderer, ICompElement, SVGBaseElement], SVGCompElement), extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextElement), SVGTextElement.prototype.createContent = function() {
                        this.data.singleShape && !this.globalData.fontManager.chars && (this.textContainer = createNS("text"))
                    }, SVGTextElement.prototype.buildTextContents = function(t) {
                        for (var e = 0, n = t.length, i = [], r = ""; e < n;) t[e] === String.fromCharCode(13) || t[e] === String.fromCharCode(3) ? (i.push(r), r = "") : r += t[e], e += 1;
                        return i.push(r), i
                    }, SVGTextElement.prototype.buildNewText = function() {
                        var t, e, n = this.textProperty.currentData;
                        this.renderedLetters = createSizedArray(n ? n.l.length : 0), n.fc ? this.layerElement.setAttribute("fill", this.buildColor(n.fc)) : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"), n.sc && (this.layerElement.setAttribute("stroke", this.buildColor(n.sc)), this.layerElement.setAttribute("stroke-width", n.sw)), this.layerElement.setAttribute("font-size", n.finalSize);
                        var i = this.globalData.fontManager.getFontByName(n.f);
                        if (i.fClass) this.layerElement.setAttribute("class", i.fClass);
                        else {
                            this.layerElement.setAttribute("font-family", i.fFamily);
                            var r = n.fWeight,
                                a = n.fStyle;
                            this.layerElement.setAttribute("font-style", a), this.layerElement.setAttribute("font-weight", r)
                        }
                        this.layerElement.setAttribute("aria-label", n.t);
                        var s, o = n.l || [],
                            l = !!this.globalData.fontManager.chars;
                        e = o.length;
                        var h, u = this.mHelper,
                            c = "",
                            p = this.data.singleShape,
                            f = 0,
                            d = 0,
                            m = !0,
                            g = n.tr / 1e3 * n.finalSize;
                        if (!p || l || n.sz) {
                            var v, y, _ = this.textSpans.length;
                            for (t = 0; t < e; t += 1) l && p && 0 !== t || (s = _ > t ? this.textSpans[t] : createNS(l ? "path" : "text"), _ <= t && (s.setAttribute("stroke-linecap", "butt"), s.setAttribute("stroke-linejoin", "round"), s.setAttribute("stroke-miterlimit", "4"), this.textSpans[t] = s, this.layerElement.appendChild(s)), s.style.display = "inherit"), u.reset(), u.scale(n.finalSize / 100, n.finalSize / 100), p && (o[t].n && (f = -g, d += n.yOffset, d += m ? 1 : 0, m = !1), this.applyTextPropertiesToMatrix(n, u, o[t].line, f, d), f += o[t].l || 0, f += g), l ? (h = (v = (y = this.globalData.fontManager.getCharData(n.finalText[t], i.fStyle, this.globalData.fontManager.getFontByName(n.f).fFamily)) && y.data || {}).shapes ? v.shapes[0].it : [], p ? c += this.createPathShape(u, h) : s.setAttribute("d", this.createPathShape(u, h))) : (p && s.setAttribute("transform", "translate(" + u.props[12] + "," + u.props[13] + ")"), s.textContent = o[t].val, s.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"));
                            p && s && s.setAttribute("d", c)
                        } else {
                            var x = this.textContainer,
                                b = "start";
                            switch (n.j) {
                                case 1:
                                    b = "end";
                                    break;
                                case 2:
                                    b = "middle"
                            }
                            x.setAttribute("text-anchor", b), x.setAttribute("letter-spacing", g);
                            var E = this.buildTextContents(n.finalText);
                            for (e = E.length, d = n.ps ? n.ps[1] + n.ascent : 0, t = 0; t < e; t += 1)(s = this.textSpans[t] || createNS("tspan")).textContent = E[t], s.setAttribute("x", 0), s.setAttribute("y", d), s.style.display = "inherit", x.appendChild(s), this.textSpans[t] = s, d += n.finalLineHeight;
                            this.layerElement.appendChild(x)
                        }
                        for (; t < this.textSpans.length;) this.textSpans[t].style.display = "none", t += 1;
                        this._sizeChanged = !0
                    }, SVGTextElement.prototype.sourceRectAtTime = function(t) {
                        if (this.prepareFrame(this.comp.renderedFrame - this.data.st), this.renderInnerContent(), this._sizeChanged) {
                            this._sizeChanged = !1;
                            var e = this.layerElement.getBBox();
                            this.bbox = {
                                top: e.y,
                                left: e.x,
                                width: e.width,
                                height: e.height
                            }
                        }
                        return this.bbox
                    }, SVGTextElement.prototype.renderInnerContent = function() {
                        if (!this.data.singleShape && (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)) {
                            var t, e;
                            this._sizeChanged = !0;
                            var n, i, r = this.textAnimator.renderedLetters,
                                a = this.textProperty.currentData.l;
                            for (e = a.length, t = 0; t < e; t += 1) a[t].n || (n = r[t], i = this.textSpans[t], n._mdf.m && i.setAttribute("transform", n.m), n._mdf.o && i.setAttribute("opacity", n.o), n._mdf.sw && i.setAttribute("stroke-width", n.sw), n._mdf.sc && i.setAttribute("stroke", n.sc), n._mdf.fc && i.setAttribute("fill", n.fc))
                        }
                    }, extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement), SVGShapeElement.prototype.initSecondaryElement = function() {}, SVGShapeElement.prototype.identityMatrix = new Matrix, SVGShapeElement.prototype.buildExpressionInterface = function() {}, SVGShapeElement.prototype.createContent = function() {
                        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes()
                    }, SVGShapeElement.prototype.filterUniqueShapes = function() {
                        var t, e, n, i, r = this.shapes.length,
                            a = this.stylesList.length,
                            s = [],
                            o = !1;
                        for (n = 0; n < a; n += 1) {
                            for (i = this.stylesList[n], o = !1, s.length = 0, t = 0; t < r; t += 1) - 1 !== (e = this.shapes[t]).styles.indexOf(i) && (s.push(e), o = e._isAnimated || o);
                            s.length > 1 && o && this.setShapesAsAnimated(s)
                        }
                    }, SVGShapeElement.prototype.setShapesAsAnimated = function(t) {
                        var e, n = t.length;
                        for (e = 0; e < n; e += 1) t[e].setAsAnimated()
                    }, SVGShapeElement.prototype.createStyleElement = function(t, e) {
                        var n, i = new SVGStyleData(t, e),
                            r = i.pElem;
                        if ("st" === t.ty) n = new SVGStrokeStyleData(this, t, i);
                        else if ("fl" === t.ty) n = new SVGFillStyleData(this, t, i);
                        else if ("gf" === t.ty || "gs" === t.ty) {
                            n = new("gf" === t.ty ? SVGGradientFillStyleData : SVGGradientStrokeStyleData)(this, t, i), this.globalData.defs.appendChild(n.gf), n.maskId && (this.globalData.defs.appendChild(n.ms), this.globalData.defs.appendChild(n.of), r.setAttribute("mask", "url(" + locationHref + "#" + n.maskId + ")"))
                        }
                        return "st" !== t.ty && "gs" !== t.ty || (r.setAttribute("stroke-linecap", this.lcEnum[t.lc] || "round"), r.setAttribute("stroke-linejoin", this.ljEnum[t.lj] || "round"), r.setAttribute("fill-opacity", "0"), 1 === t.lj && r.setAttribute("stroke-miterlimit", t.ml)), 2 === t.r && r.setAttribute("fill-rule", "evenodd"), t.ln && r.setAttribute("id", t.ln), t.cl && r.setAttribute("class", t.cl), t.bm && (r.style["mix-blend-mode"] = getBlendMode(t.bm)), this.stylesList.push(i), this.addToAnimatedContents(t, n), n
                    }, SVGShapeElement.prototype.createGroupElement = function(t) {
                        var e = new ShapeGroupData;
                        return t.ln && e.gr.setAttribute("id", t.ln), t.cl && e.gr.setAttribute("class", t.cl), t.bm && (e.gr.style["mix-blend-mode"] = getBlendMode(t.bm)), e
                    }, SVGShapeElement.prototype.createTransformElement = function(t, e) {
                        var n = TransformPropertyFactory.getTransformProperty(this, t, this),
                            i = new SVGTransformData(n, n.o, e);
                        return this.addToAnimatedContents(t, i), i
                    }, SVGShapeElement.prototype.createShapeElement = function(t, e, n) {
                        var i = 4;
                        "rc" === t.ty ? i = 5 : "el" === t.ty ? i = 6 : "sr" === t.ty && (i = 7);
                        var r = new SVGShapeData(e, n, ShapePropertyFactory.getShapeProp(this, t, i, this));
                        return this.shapes.push(r), this.addShapeToModifiers(r), this.addToAnimatedContents(t, r), r
                    }, SVGShapeElement.prototype.addToAnimatedContents = function(t, e) {
                        for (var n = 0, i = this.animatedContents.length; n < i;) {
                            if (this.animatedContents[n].element === e) return;
                            n += 1
                        }
                        this.animatedContents.push({
                            fn: SVGElementsRenderer.createRenderFunction(t),
                            element: e,
                            data: t
                        })
                    }, SVGShapeElement.prototype.setElementStyles = function(t) {
                        var e, n = t.styles,
                            i = this.stylesList.length;
                        for (e = 0; e < i; e += 1) this.stylesList[e].closed || n.push(this.stylesList[e])
                    }, SVGShapeElement.prototype.reloadShapes = function() {
                        this._isFirstFrame = !0;
                        var t, e = this.itemsData.length;
                        for (t = 0; t < e; t += 1) this.prevViewData[t] = this.itemsData[t];
                        for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes(), e = this.dynamicProperties.length, t = 0; t < e; t += 1) this.dynamicProperties[t].getValue();
                        this.renderModifiers()
                    }, SVGShapeElement.prototype.searchShapes = function(t, e, n, i, r, a, s) {
                        var o, l, h, u, c, p, f = [].concat(a),
                            d = t.length - 1,
                            m = [],
                            g = [];
                        for (o = d; o >= 0; o -= 1) {
                            if ((p = this.searchProcessedElement(t[o])) ? e[o] = n[p - 1] : t[o]._render = s, "fl" == t[o].ty || "st" == t[o].ty || "gf" == t[o].ty || "gs" == t[o].ty) p ? e[o].style.closed = !1 : e[o] = this.createStyleElement(t[o], r), t[o]._render && i.appendChild(e[o].style.pElem), m.push(e[o].style);
                            else if ("gr" == t[o].ty) {
                                if (p)
                                    for (h = e[o].it.length, l = 0; l < h; l += 1) e[o].prevViewData[l] = e[o].it[l];
                                else e[o] = this.createGroupElement(t[o]);
                                this.searchShapes(t[o].it, e[o].it, e[o].prevViewData, e[o].gr, r + 1, f, s), t[o]._render && i.appendChild(e[o].gr)
                            } else "tr" == t[o].ty ? (p || (e[o] = this.createTransformElement(t[o], i)), u = e[o].transform, f.push(u)) : "sh" == t[o].ty || "rc" == t[o].ty || "el" == t[o].ty || "sr" == t[o].ty ? (p || (e[o] = this.createShapeElement(t[o], f, r)), this.setElementStyles(e[o])) : "tm" == t[o].ty || "rd" == t[o].ty || "ms" == t[o].ty || "pb" == t[o].ty ? (p ? (c = e[o]).closed = !1 : ((c = ShapeModifiers.getModifier(t[o].ty)).init(this, t[o]), e[o] = c, this.shapeModifiers.push(c)), g.push(c)) : "rp" == t[o].ty && (p ? (c = e[o]).closed = !0 : (c = ShapeModifiers.getModifier(t[o].ty), e[o] = c, c.init(this, t, o, e), this.shapeModifiers.push(c), s = !1), g.push(c));
                            this.addProcessedElement(t[o], o + 1)
                        }
                        for (d = m.length, o = 0; o < d; o += 1) m[o].closed = !0;
                        for (d = g.length, o = 0; o < d; o += 1) g[o].closed = !0
                    }, SVGShapeElement.prototype.renderInnerContent = function() {
                        this.renderModifiers();
                        var t, e = this.stylesList.length;
                        for (t = 0; t < e; t += 1) this.stylesList[t].reset();
                        for (this.renderShape(), t = 0; t < e; t += 1)(this.stylesList[t]._mdf || this._isFirstFrame) && (this.stylesList[t].msElem && (this.stylesList[t].msElem.setAttribute("d", this.stylesList[t].d), this.stylesList[t].d = "M0 0" + this.stylesList[t].d), this.stylesList[t].pElem.setAttribute("d", this.stylesList[t].d || "M0 0"))
                    }, SVGShapeElement.prototype.renderShape = function() {
                        var t, e, n = this.animatedContents.length;
                        for (t = 0; t < n; t += 1) e = this.animatedContents[t], (this._isFirstFrame || e.element._isAnimated) && !0 !== e.data && e.fn(e.data, e.element, this._isFirstFrame)
                    }, SVGShapeElement.prototype.destroy = function() {
                        this.destroyBaseElement(), this.shapesData = null, this.itemsData = null
                    }, SVGTintFilter.prototype.renderFrame = function(t) {
                        if (t || this.filterManager._mdf) {
                            var e = this.filterManager.effectElements[0].p.v,
                                n = this.filterManager.effectElements[1].p.v,
                                i = this.filterManager.effectElements[2].p.v / 100;
                            this.matrixFilter.setAttribute("values", n[0] - e[0] + " 0 0 0 " + e[0] + " " + (n[1] - e[1]) + " 0 0 0 " + e[1] + " " + (n[2] - e[2]) + " 0 0 0 " + e[2] + " 0 0 0 " + i + " 0")
                        }
                    }, SVGFillFilter.prototype.renderFrame = function(t) {
                        if (t || this.filterManager._mdf) {
                            var e = this.filterManager.effectElements[2].p.v,
                                n = this.filterManager.effectElements[6].p.v;
                            this.matrixFilter.setAttribute("values", "0 0 0 0 " + e[0] + " 0 0 0 0 " + e[1] + " 0 0 0 0 " + e[2] + " 0 0 0 " + n + " 0")
                        }
                    }, SVGGaussianBlurEffect.prototype.renderFrame = function(t) {
                        if (t || this.filterManager._mdf) {
                            var e = .3 * this.filterManager.effectElements[0].p.v,
                                n = this.filterManager.effectElements[1].p.v,
                                i = 3 == n ? 0 : e,
                                r = 2 == n ? 0 : e;
                            this.feGaussianBlur.setAttribute("stdDeviation", i + " " + r);
                            var a = 1 == this.filterManager.effectElements[2].p.v ? "wrap" : "duplicate";
                            this.feGaussianBlur.setAttribute("edgeMode", a)
                        }
                    }, SVGStrokeEffect.prototype.initialize = function() {
                        var t, e, n, i, r = this.elem.layerElement.children || this.elem.layerElement.childNodes;
                        for (1 === this.filterManager.effectElements[1].p.v ? (i = this.elem.maskManager.masksProperties.length, n = 0) : i = (n = this.filterManager.effectElements[0].p.v - 1) + 1, (e = createNS("g")).setAttribute("fill", "none"), e.setAttribute("stroke-linecap", "round"), e.setAttribute("stroke-dashoffset", 1); n < i; n += 1) t = createNS("path"), e.appendChild(t), this.paths.push({
                            p: t,
                            m: n
                        });
                        if (3 === this.filterManager.effectElements[10].p.v) {
                            var a = createNS("mask"),
                                s = createElementID();
                            a.setAttribute("id", s), a.setAttribute("mask-type", "alpha"), a.appendChild(e), this.elem.globalData.defs.appendChild(a);
                            var o = createNS("g");
                            for (o.setAttribute("mask", "url(" + locationHref + "#" + s + ")"); r[0];) o.appendChild(r[0]);
                            this.elem.layerElement.appendChild(o), this.masker = a, e.setAttribute("stroke", "#fff")
                        } else if (1 === this.filterManager.effectElements[10].p.v || 2 === this.filterManager.effectElements[10].p.v) {
                            if (2 === this.filterManager.effectElements[10].p.v)
                                for (r = this.elem.layerElement.children || this.elem.layerElement.childNodes; r.length;) this.elem.layerElement.removeChild(r[0]);
                            this.elem.layerElement.appendChild(e), this.elem.layerElement.removeAttribute("mask"), e.setAttribute("stroke", "#fff")
                        }
                        this.initialized = !0, this.pathMasker = e
                    }, SVGStrokeEffect.prototype.renderFrame = function(t) {
                        this.initialized || this.initialize();
                        var e, n, i, r = this.paths.length;
                        for (e = 0; e < r; e += 1)
                            if (-1 !== this.paths[e].m && (n = this.elem.maskManager.viewData[this.paths[e].m], i = this.paths[e].p, (t || this.filterManager._mdf || n.prop._mdf) && i.setAttribute("d", n.lastPath), t || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || n.prop._mdf)) {
                                var a;
                                if (0 !== this.filterManager.effectElements[7].p.v || 100 !== this.filterManager.effectElements[8].p.v) {
                                    var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) / 100,
                                        o = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) / 100,
                                        l = i.getTotalLength();
                                    a = "0 0 0 " + l * s + " ";
                                    var h, u = l * (o - s),
                                        c = 1 + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v / 100,
                                        p = Math.floor(u / c);
                                    for (h = 0; h < p; h += 1) a += "1 " + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v / 100 + " ";
                                    a += "0 " + 10 * l + " 0 0"
                                } else a = "1 " + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v / 100;
                                i.setAttribute("stroke-dasharray", a)
                            }
                        if ((t || this.filterManager.effectElements[4].p._mdf) && this.pathMasker.setAttribute("stroke-width", 2 * this.filterManager.effectElements[4].p.v), (t || this.filterManager.effectElements[6].p._mdf) && this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v), (1 === this.filterManager.effectElements[10].p.v || 2 === this.filterManager.effectElements[10].p.v) && (t || this.filterManager.effectElements[3].p._mdf)) {
                            var f = this.filterManager.effectElements[3].p.v;
                            this.pathMasker.setAttribute("stroke", "rgb(" + bm_floor(255 * f[0]) + "," + bm_floor(255 * f[1]) + "," + bm_floor(255 * f[2]) + ")")
                        }
                    }, SVGTritoneFilter.prototype.renderFrame = function(t) {
                        if (t || this.filterManager._mdf) {
                            var e = this.filterManager.effectElements[0].p.v,
                                n = this.filterManager.effectElements[1].p.v,
                                i = this.filterManager.effectElements[2].p.v,
                                r = i[0] + " " + n[0] + " " + e[0],
                                a = i[1] + " " + n[1] + " " + e[1],
                                s = i[2] + " " + n[2] + " " + e[2];
                            this.feFuncR.setAttribute("tableValues", r), this.feFuncG.setAttribute("tableValues", a), this.feFuncB.setAttribute("tableValues", s)
                        }
                    }, SVGProLevelsFilter.prototype.createFeFunc = function(t, e) {
                        var n = createNS(t);
                        return n.setAttribute("type", "table"), e.appendChild(n), n
                    }, SVGProLevelsFilter.prototype.getTableValue = function(t, e, n, i, r) {
                        for (var a, s, o = 0, l = Math.min(t, e), h = Math.max(t, e), u = Array.call(null, {
                                length: 256
                            }), c = 0, p = r - i, f = e - t; o <= 256;) s = (a = o / 256) <= l ? f < 0 ? r : i : a >= h ? f < 0 ? i : r : i + p * Math.pow((a - t) / f, 1 / n), u[c++] = s, o += 256 / 255;
                        return u.join(" ")
                    }, SVGProLevelsFilter.prototype.renderFrame = function(t) {
                        if (t || this.filterManager._mdf) {
                            var e, n = this.filterManager.effectElements;
                            this.feFuncRComposed && (t || n[3].p._mdf || n[4].p._mdf || n[5].p._mdf || n[6].p._mdf || n[7].p._mdf) && (e = this.getTableValue(n[3].p.v, n[4].p.v, n[5].p.v, n[6].p.v, n[7].p.v), this.feFuncRComposed.setAttribute("tableValues", e), this.feFuncGComposed.setAttribute("tableValues", e), this.feFuncBComposed.setAttribute("tableValues", e)), this.feFuncR && (t || n[10].p._mdf || n[11].p._mdf || n[12].p._mdf || n[13].p._mdf || n[14].p._mdf) && (e = this.getTableValue(n[10].p.v, n[11].p.v, n[12].p.v, n[13].p.v, n[14].p.v), this.feFuncR.setAttribute("tableValues", e)), this.feFuncG && (t || n[17].p._mdf || n[18].p._mdf || n[19].p._mdf || n[20].p._mdf || n[21].p._mdf) && (e = this.getTableValue(n[17].p.v, n[18].p.v, n[19].p.v, n[20].p.v, n[21].p.v), this.feFuncG.setAttribute("tableValues", e)), this.feFuncB && (t || n[24].p._mdf || n[25].p._mdf || n[26].p._mdf || n[27].p._mdf || n[28].p._mdf) && (e = this.getTableValue(n[24].p.v, n[25].p.v, n[26].p.v, n[27].p.v, n[28].p.v), this.feFuncB.setAttribute("tableValues", e)), this.feFuncA && (t || n[31].p._mdf || n[32].p._mdf || n[33].p._mdf || n[34].p._mdf || n[35].p._mdf) && (e = this.getTableValue(n[31].p.v, n[32].p.v, n[33].p.v, n[34].p.v, n[35].p.v), this.feFuncA.setAttribute("tableValues", e))
                        }
                    }, SVGDropShadowEffect.prototype.renderFrame = function(t) {
                        if (t || this.filterManager._mdf) {
                            if ((t || this.filterManager.effectElements[4].p._mdf) && this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4), t || this.filterManager.effectElements[0].p._mdf) {
                                var e = this.filterManager.effectElements[0].p.v;
                                this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(255 * e[0]), Math.round(255 * e[1]), Math.round(255 * e[2])))
                            }
                            if ((t || this.filterManager.effectElements[1].p._mdf) && this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255), t || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
                                var n = this.filterManager.effectElements[3].p.v,
                                    i = (this.filterManager.effectElements[2].p.v - 90) * degToRads,
                                    r = n * Math.cos(i),
                                    a = n * Math.sin(i);
                                this.feOffset.setAttribute("dx", r), this.feOffset.setAttribute("dy", a)
                            }
                        }
                    };
                    var _svgMatteSymbols = [];

                    function SVGMatte3Effect(t, e, n) {
                        this.initialized = !1, this.filterManager = e, this.filterElem = t, this.elem = n, n.matteElement = createNS("g"), n.matteElement.appendChild(n.layerElement), n.matteElement.appendChild(n.transformedElement), n.baseElement = n.matteElement
                    }

                    function SVGEffects(t) {
                        var e, n, i = t.data.ef ? t.data.ef.length : 0,
                            r = createElementID(),
                            a = filtersFactory.createFilter(r),
                            s = 0;
                        for (this.filters = [], e = 0; e < i; e += 1) n = null, 20 === t.data.ef[e].ty ? (s += 1, n = new SVGTintFilter(a, t.effectsManager.effectElements[e])) : 21 === t.data.ef[e].ty ? (s += 1, n = new SVGFillFilter(a, t.effectsManager.effectElements[e])) : 22 === t.data.ef[e].ty ? n = new SVGStrokeEffect(t, t.effectsManager.effectElements[e]) : 23 === t.data.ef[e].ty ? (s += 1, n = new SVGTritoneFilter(a, t.effectsManager.effectElements[e])) : 24 === t.data.ef[e].ty ? (s += 1, n = new SVGProLevelsFilter(a, t.effectsManager.effectElements[e])) : 25 === t.data.ef[e].ty ? (s += 1, n = new SVGDropShadowEffect(a, t.effectsManager.effectElements[e])) : 28 === t.data.ef[e].ty ? n = new SVGMatte3Effect(a, t.effectsManager.effectElements[e], t) : 29 === t.data.ef[e].ty && (s += 1, n = new SVGGaussianBlurEffect(a, t.effectsManager.effectElements[e])), n && this.filters.push(n);
                        s && (t.globalData.defs.appendChild(a), t.layerElement.setAttribute("filter", "url(" + locationHref + "#" + r + ")")), this.filters.length && t.addRenderableComponent(this)
                    }

                    function CVContextData() {
                        this.saved = [], this.cArrPos = 0, this.cTr = new Matrix, this.cO = 1;
                        var t;
                        for (this.savedOp = createTypedArray("float32", 15), t = 0; t < 15; t += 1) this.saved[t] = createTypedArray("float32", 16);
                        this._length = 15
                    }

                    function CVBaseElement() {}

                    function CVImageElement(t, e, n) {
                        this.assetData = e.getAssetData(t.refId), this.img = e.imageLoader.getImage(this.assetData), this.initElement(t, e, n)
                    }

                    function CVCompElement(t, e, n) {
                        this.completeLayers = !1, this.layers = t.layers, this.pendingElements = [], this.elements = createSizedArray(this.layers.length), this.initElement(t, e, n), this.tm = t.tm ? PropertyFactory.getProp(this, t.tm, 0, e.frameRate, this) : {
                            _placeholder: !0
                        }
                    }

                    function CVMaskElement(t, e) {
                        this.data = t, this.element = e, this.masksProperties = this.data.masksProperties || [], this.viewData = createSizedArray(this.masksProperties.length);
                        var n, i = this.masksProperties.length,
                            r = !1;
                        for (n = 0; n < i; n++) "n" !== this.masksProperties[n].mode && (r = !0), this.viewData[n] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[n], 3);
                        this.hasMasks = r, r && this.element.addRenderableComponent(this)
                    }

                    function CVShapeElement(t, e, n) {
                        this.shapes = [], this.shapesData = t.shapes, this.stylesList = [], this.itemsData = [], this.prevViewData = [], this.shapeModifiers = [], this.processedElements = [], this.transformsManager = new ShapeTransformManager, this.initElement(t, e, n)
                    }

                    function CVSolidElement(t, e, n) {
                        this.initElement(t, e, n)
                    }

                    function CVTextElement(t, e, n) {
                        this.textSpans = [], this.yOffset = 0, this.fillColorAnim = !1, this.strokeColorAnim = !1, this.strokeWidthAnim = !1, this.stroke = !1, this.fill = !1, this.justifyOffset = 0, this.currentRender = null, this.renderType = "canvas", this.values = {
                            fill: "rgba(0,0,0,0)",
                            stroke: "rgba(0,0,0,0)",
                            sWidth: 0,
                            fValue: ""
                        }, this.initElement(t, e, n)
                    }

                    function CVEffects() {}

                    function HBaseElement(t, e, n) {}

                    function HSolidElement(t, e, n) {
                        this.initElement(t, e, n)
                    }

                    function HCompElement(t, e, n) {
                        this.layers = t.layers, this.supports3d = !t.hasMask, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(t, e, n), this.tm = t.tm ? PropertyFactory.getProp(this, t.tm, 0, e.frameRate, this) : {
                            _placeholder: !0
                        }
                    }

                    function HShapeElement(t, e, n) {
                        this.shapes = [], this.shapesData = t.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.shapesContainer = createNS("g"), this.initElement(t, e, n), this.prevViewData = [], this.currentBBox = {
                            x: 999999,
                            y: -999999,
                            h: 0,
                            w: 0
                        }
                    }

                    function HTextElement(t, e, n) {
                        this.textSpans = [], this.textPaths = [], this.currentBBox = {
                            x: 999999,
                            y: -999999,
                            h: 0,
                            w: 0
                        }, this.renderType = "svg", this.isMasked = !1, this.initElement(t, e, n)
                    }

                    function HImageElement(t, e, n) {
                        this.assetData = e.getAssetData(t.refId), this.initElement(t, e, n)
                    }

                    function HCameraElement(t, e, n) {
                        this.initFrame(), this.initBaseData(t, e, n), this.initHierarchy();
                        var i = PropertyFactory.getProp;
                        if (this.pe = i(this, t.pe, 0, 0, this), t.ks.p.s ? (this.px = i(this, t.ks.p.x, 1, 0, this), this.py = i(this, t.ks.p.y, 1, 0, this), this.pz = i(this, t.ks.p.z, 1, 0, this)) : this.p = i(this, t.ks.p, 1, 0, this), t.ks.a && (this.a = i(this, t.ks.a, 1, 0, this)), t.ks.or.k.length && t.ks.or.k[0].to) {
                            var r, a = t.ks.or.k.length;
                            for (r = 0; r < a; r += 1) t.ks.or.k[r].to = null, t.ks.or.k[r].ti = null
                        }
                        this.or = i(this, t.ks.or, 1, degToRads, this), this.or.sh = !0, this.rx = i(this, t.ks.rx, 0, degToRads, this), this.ry = i(this, t.ks.ry, 0, degToRads, this), this.rz = i(this, t.ks.rz, 0, degToRads, this), this.mat = new Matrix, this._prevMat = new Matrix, this._isFirstFrame = !0, this.finalTransform = {
                            mProp: this
                        }
                    }

                    function HEffects() {}
                    SVGMatte3Effect.prototype.findSymbol = function(t) {
                        for (var e = 0, n = _svgMatteSymbols.length; e < n;) {
                            if (_svgMatteSymbols[e] === t) return _svgMatteSymbols[e];
                            e += 1
                        }
                        return null
                    }, SVGMatte3Effect.prototype.replaceInParent = function(t, e) {
                        var n = t.layerElement.parentNode;
                        if (n) {
                            for (var i, r = n.children, a = 0, s = r.length; a < s && r[a] !== t.layerElement;) a += 1;
                            a <= s - 2 && (i = r[a + 1]);
                            var o = createNS("use");
                            o.setAttribute("href", "#" + e), i ? n.insertBefore(o, i) : n.appendChild(o)
                        }
                    }, SVGMatte3Effect.prototype.setElementAsMask = function(t, e) {
                        if (!this.findSymbol(e)) {
                            var n = createElementID(),
                                i = createNS("mask");
                            i.setAttribute("id", e.layerId), i.setAttribute("mask-type", "alpha"), _svgMatteSymbols.push(e);
                            var r = t.globalData.defs;
                            r.appendChild(i);
                            var a = createNS("symbol");
                            a.setAttribute("id", n), this.replaceInParent(e, n), a.appendChild(e.layerElement), r.appendChild(a);
                            var s = createNS("use");
                            s.setAttribute("href", "#" + n), i.appendChild(s), e.data.hd = !1, e.show()
                        }
                        t.setMatte(e.layerId)
                    }, SVGMatte3Effect.prototype.initialize = function() {
                        for (var t = this.filterManager.effectElements[0].p.v, e = this.elem.comp.elements, n = 0, i = e.length; n < i;) e[n] && e[n].data.ind === t && this.setElementAsMask(this.elem, e[n]), n += 1;
                        this.initialized = !0
                    }, SVGMatte3Effect.prototype.renderFrame = function() {
                        this.initialized || this.initialize()
                    }, SVGEffects.prototype.renderFrame = function(t) {
                        var e, n = this.filters.length;
                        for (e = 0; e < n; e += 1) this.filters[e].renderFrame(t)
                    }, CVContextData.prototype.duplicate = function() {
                        var t = 2 * this._length,
                            e = this.savedOp;
                        this.savedOp = createTypedArray("float32", t), this.savedOp.set(e);
                        var n = 0;
                        for (n = this._length; n < t; n += 1) this.saved[n] = createTypedArray("float32", 16);
                        this._length = t
                    }, CVContextData.prototype.reset = function() {
                        this.cArrPos = 0, this.cTr.reset(), this.cO = 1
                    }, CVBaseElement.prototype = {
                        createElements: function() {},
                        initRendererElement: function() {},
                        createContainerElements: function() {
                            this.canvasContext = this.globalData.canvasContext, this.renderableEffectsManager = new CVEffects(this)
                        },
                        createContent: function() {},
                        setBlendMode: function() {
                            var t = this.globalData;
                            if (t.blendMode !== this.data.bm) {
                                t.blendMode = this.data.bm;
                                var e = getBlendMode(this.data.bm);
                                t.canvasContext.globalCompositeOperation = e
                            }
                        },
                        createRenderableComponents: function() {
                            this.maskManager = new CVMaskElement(this.data, this)
                        },
                        hideElement: function() {
                            this.hidden || this.isInRange && !this.isTransparent || (this.hidden = !0)
                        },
                        showElement: function() {
                            this.isInRange && !this.isTransparent && (this.hidden = !1, this._isFirstFrame = !0, this.maskManager._isFirstFrame = !0)
                        },
                        renderFrame: function() {
                            if (!this.hidden && !this.data.hd) {
                                this.renderTransform(), this.renderRenderable(), this.setBlendMode();
                                var t = 0 === this.data.ty;
                                this.globalData.renderer.save(t), this.globalData.renderer.ctxTransform(this.finalTransform.mat.props), this.globalData.renderer.ctxOpacity(this.finalTransform.mProp.o.v), this.renderInnerContent(), this.globalData.renderer.restore(t), this.maskManager.hasMasks && this.globalData.renderer.restore(!0), this._isFirstFrame && (this._isFirstFrame = !1)
                            }
                        },
                        destroy: function() {
                            this.canvasContext = null, this.data = null, this.globalData = null, this.maskManager.destroy()
                        },
                        mHelper: new Matrix
                    }, CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement, CVBaseElement.prototype.show = CVBaseElement.prototype.showElement, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement), CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVImageElement.prototype.createContent = function() {
                        if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
                            var t = createTag("canvas");
                            t.width = this.assetData.w, t.height = this.assetData.h;
                            var e, n, i = t.getContext("2d"),
                                r = this.img.width,
                                a = this.img.height,
                                s = r / a,
                                o = this.assetData.w / this.assetData.h,
                                l = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
                            s > o && "xMidYMid slice" === l || s < o && "xMidYMid slice" !== l ? e = (n = a) * o : n = (e = r) / o, i.drawImage(this.img, (r - e) / 2, (a - n) / 2, e, n, 0, 0, this.assetData.w, this.assetData.h), this.img = t
                        }
                    }, CVImageElement.prototype.renderInnerContent = function(t) {
                        this.canvasContext.drawImage(this.img, 0, 0)
                    }, CVImageElement.prototype.destroy = function() {
                        this.img = null
                    }, extendPrototype([CanvasRenderer, ICompElement, CVBaseElement], CVCompElement), CVCompElement.prototype.renderInnerContent = function() {
                        var t, e = this.canvasContext;
                        for (e.beginPath(), e.moveTo(0, 0), e.lineTo(this.data.w, 0), e.lineTo(this.data.w, this.data.h), e.lineTo(0, this.data.h), e.lineTo(0, 0), e.clip(), t = this.layers.length - 1; t >= 0; t -= 1)(this.completeLayers || this.elements[t]) && this.elements[t].renderFrame()
                    }, CVCompElement.prototype.destroy = function() {
                        var t;
                        for (t = this.layers.length - 1; t >= 0; t -= 1) this.elements[t] && this.elements[t].destroy();
                        this.layers = null, this.elements = null
                    }, CVMaskElement.prototype.renderFrame = function() {
                        if (this.hasMasks) {
                            var t, e, n, i, r = this.element.finalTransform.mat,
                                a = this.element.canvasContext,
                                s = this.masksProperties.length;
                            for (a.beginPath(), t = 0; t < s; t++)
                                if ("n" !== this.masksProperties[t].mode) {
                                    this.masksProperties[t].inv && (a.moveTo(0, 0), a.lineTo(this.element.globalData.compSize.w, 0), a.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h), a.lineTo(0, this.element.globalData.compSize.h), a.lineTo(0, 0)), i = this.viewData[t].v, e = r.applyToPointArray(i.v[0][0], i.v[0][1], 0), a.moveTo(e[0], e[1]);
                                    var o, l = i._length;
                                    for (o = 1; o < l; o++) n = r.applyToTriplePoints(i.o[o - 1], i.i[o], i.v[o]), a.bezierCurveTo(n[0], n[1], n[2], n[3], n[4], n[5]);
                                    n = r.applyToTriplePoints(i.o[o - 1], i.i[0], i.v[0]), a.bezierCurveTo(n[0], n[1], n[2], n[3], n[4], n[5])
                                }
                            this.element.globalData.renderer.save(!0), a.clip()
                        }
                    }, CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty, CVMaskElement.prototype.destroy = function() {
                        this.element = null
                    }, extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement), CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement, CVShapeElement.prototype.transformHelper = {
                        opacity: 1,
                        _opMdf: !1
                    }, CVShapeElement.prototype.dashResetter = [], CVShapeElement.prototype.createContent = function() {
                        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, [])
                    }, CVShapeElement.prototype.createStyleElement = function(t, e) {
                        var n = {
                                data: t,
                                type: t.ty,
                                preTransforms: this.transformsManager.addTransformSequence(e),
                                transforms: [],
                                elements: [],
                                closed: !0 === t.hd
                            },
                            i = {};
                        if ("fl" == t.ty || "st" == t.ty ? (i.c = PropertyFactory.getProp(this, t.c, 1, 255, this), i.c.k || (n.co = "rgb(" + bm_floor(i.c.v[0]) + "," + bm_floor(i.c.v[1]) + "," + bm_floor(i.c.v[2]) + ")")) : "gf" !== t.ty && "gs" !== t.ty || (i.s = PropertyFactory.getProp(this, t.s, 1, null, this), i.e = PropertyFactory.getProp(this, t.e, 1, null, this), i.h = PropertyFactory.getProp(this, t.h || {
                                k: 0
                            }, 0, .01, this), i.a = PropertyFactory.getProp(this, t.a || {
                                k: 0
                            }, 0, degToRads, this), i.g = new GradientProperty(this, t.g, this)), i.o = PropertyFactory.getProp(this, t.o, 0, .01, this), "st" == t.ty || "gs" == t.ty) {
                            if (n.lc = this.lcEnum[t.lc] || "round", n.lj = this.ljEnum[t.lj] || "round", 1 == t.lj && (n.ml = t.ml), i.w = PropertyFactory.getProp(this, t.w, 0, null, this), i.w.k || (n.wi = i.w.v), t.d) {
                                var r = new DashProperty(this, t.d, "canvas", this);
                                i.d = r, i.d.k || (n.da = i.d.dashArray, n.do = i.d.dashoffset[0])
                            }
                        } else n.r = 2 === t.r ? "evenodd" : "nonzero";
                        return this.stylesList.push(n), i.style = n, i
                    }, CVShapeElement.prototype.createGroupElement = function(t) {
                        return {
                            it: [],
                            prevViewData: []
                        }
                    }, CVShapeElement.prototype.createTransformElement = function(t) {
                        return {
                            transform: {
                                opacity: 1,
                                _opMdf: !1,
                                key: this.transformsManager.getNewKey(),
                                op: PropertyFactory.getProp(this, t.o, 0, .01, this),
                                mProps: TransformPropertyFactory.getTransformProperty(this, t, this)
                            }
                        }
                    }, CVShapeElement.prototype.createShapeElement = function(t) {
                        var e = new CVShapeData(this, t, this.stylesList, this.transformsManager);
                        return this.shapes.push(e), this.addShapeToModifiers(e), e
                    }, CVShapeElement.prototype.reloadShapes = function() {
                        this._isFirstFrame = !0;
                        var t, e = this.itemsData.length;
                        for (t = 0; t < e; t += 1) this.prevViewData[t] = this.itemsData[t];
                        for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []), e = this.dynamicProperties.length, t = 0; t < e; t += 1) this.dynamicProperties[t].getValue();
                        this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame)
                    }, CVShapeElement.prototype.addTransformToStyleList = function(t) {
                        var e, n = this.stylesList.length;
                        for (e = 0; e < n; e += 1) this.stylesList[e].closed || this.stylesList[e].transforms.push(t)
                    }, CVShapeElement.prototype.removeTransformFromStyleList = function() {
                        var t, e = this.stylesList.length;
                        for (t = 0; t < e; t += 1) this.stylesList[t].closed || this.stylesList[t].transforms.pop()
                    }, CVShapeElement.prototype.closeStyles = function(t) {
                        var e, n = t.length;
                        for (e = 0; e < n; e += 1) t[e].closed = !0
                    }, CVShapeElement.prototype.searchShapes = function(t, e, n, i, r) {
                        var a, s, o, l, h, u, c = t.length - 1,
                            p = [],
                            f = [],
                            d = [].concat(r);
                        for (a = c; a >= 0; a -= 1) {
                            if ((l = this.searchProcessedElement(t[a])) ? e[a] = n[l - 1] : t[a]._shouldRender = i, "fl" == t[a].ty || "st" == t[a].ty || "gf" == t[a].ty || "gs" == t[a].ty) l ? e[a].style.closed = !1 : e[a] = this.createStyleElement(t[a], d), p.push(e[a].style);
                            else if ("gr" == t[a].ty) {
                                if (l)
                                    for (o = e[a].it.length, s = 0; s < o; s += 1) e[a].prevViewData[s] = e[a].it[s];
                                else e[a] = this.createGroupElement(t[a]);
                                this.searchShapes(t[a].it, e[a].it, e[a].prevViewData, i, d)
                            } else "tr" == t[a].ty ? (l || (u = this.createTransformElement(t[a]), e[a] = u), d.push(e[a]), this.addTransformToStyleList(e[a])) : "sh" == t[a].ty || "rc" == t[a].ty || "el" == t[a].ty || "sr" == t[a].ty ? l || (e[a] = this.createShapeElement(t[a])) : "tm" == t[a].ty || "rd" == t[a].ty || "pb" == t[a].ty ? (l ? (h = e[a]).closed = !1 : ((h = ShapeModifiers.getModifier(t[a].ty)).init(this, t[a]), e[a] = h, this.shapeModifiers.push(h)), f.push(h)) : "rp" == t[a].ty && (l ? (h = e[a]).closed = !0 : (h = ShapeModifiers.getModifier(t[a].ty), e[a] = h, h.init(this, t, a, e), this.shapeModifiers.push(h), i = !1), f.push(h));
                            this.addProcessedElement(t[a], a + 1)
                        }
                        for (this.removeTransformFromStyleList(), this.closeStyles(p), c = f.length, a = 0; a < c; a += 1) f[a].closed = !0
                    }, CVShapeElement.prototype.renderInnerContent = function() {
                        this.transformHelper.opacity = 1, this.transformHelper._opMdf = !1, this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame), this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0)
                    }, CVShapeElement.prototype.renderShapeTransform = function(t, e) {
                        (t._opMdf || e.op._mdf || this._isFirstFrame) && (e.opacity = t.opacity, e.opacity *= e.op.v, e._opMdf = !0)
                    }, CVShapeElement.prototype.drawLayer = function() {
                        var t, e, n, i, r, a, s, o, l, h = this.stylesList.length,
                            u = this.globalData.renderer,
                            c = this.globalData.canvasContext;
                        for (t = 0; t < h; t += 1)
                            if (("st" !== (o = (l = this.stylesList[t]).type) && "gs" !== o || 0 !== l.wi) && l.data._shouldRender && 0 !== l.coOp && 0 !== this.globalData.currentGlobalAlpha) {
                                for (u.save(), a = l.elements, "st" === o || "gs" === o ? (c.strokeStyle = "st" === o ? l.co : l.grd, c.lineWidth = l.wi, c.lineCap = l.lc, c.lineJoin = l.lj, c.miterLimit = l.ml || 0) : c.fillStyle = "fl" === o ? l.co : l.grd, u.ctxOpacity(l.coOp), "st" !== o && "gs" !== o && c.beginPath(), u.ctxTransform(l.preTransforms.finalTransform.props), n = a.length, e = 0; e < n; e += 1) {
                                    for ("st" !== o && "gs" !== o || (c.beginPath(), l.da && (c.setLineDash(l.da), c.lineDashOffset = l.do)), r = (s = a[e].trNodes).length, i = 0; i < r; i += 1) "m" == s[i].t ? c.moveTo(s[i].p[0], s[i].p[1]) : "c" == s[i].t ? c.bezierCurveTo(s[i].pts[0], s[i].pts[1], s[i].pts[2], s[i].pts[3], s[i].pts[4], s[i].pts[5]) : c.closePath();
                                    "st" !== o && "gs" !== o || (c.stroke(), l.da && c.setLineDash(this.dashResetter))
                                }
                                "st" !== o && "gs" !== o && c.fill(l.r), u.restore()
                            }
                    }, CVShapeElement.prototype.renderShape = function(t, e, n, i) {
                        var r, a;
                        for (a = t, r = e.length - 1; r >= 0; r -= 1) "tr" == e[r].ty ? (a = n[r].transform, this.renderShapeTransform(t, a)) : "sh" == e[r].ty || "el" == e[r].ty || "rc" == e[r].ty || "sr" == e[r].ty ? this.renderPath(e[r], n[r]) : "fl" == e[r].ty ? this.renderFill(e[r], n[r], a) : "st" == e[r].ty ? this.renderStroke(e[r], n[r], a) : "gf" == e[r].ty || "gs" == e[r].ty ? this.renderGradientFill(e[r], n[r], a) : "gr" == e[r].ty ? this.renderShape(a, e[r].it, n[r].it) : e[r].ty;
                        i && this.drawLayer()
                    }, CVShapeElement.prototype.renderStyledShape = function(t, e) {
                        if (this._isFirstFrame || e._mdf || t.transforms._mdf) {
                            var n, i, r, a = t.trNodes,
                                s = e.paths,
                                o = s._length;
                            a.length = 0;
                            var l = t.transforms.finalTransform;
                            for (r = 0; r < o; r += 1) {
                                var h = s.shapes[r];
                                if (h && h.v) {
                                    for (i = h._length, n = 1; n < i; n += 1) 1 === n && a.push({
                                        t: "m",
                                        p: l.applyToPointArray(h.v[0][0], h.v[0][1], 0)
                                    }), a.push({
                                        t: "c",
                                        pts: l.applyToTriplePoints(h.o[n - 1], h.i[n], h.v[n])
                                    });
                                    1 === i && a.push({
                                        t: "m",
                                        p: l.applyToPointArray(h.v[0][0], h.v[0][1], 0)
                                    }), h.c && i && (a.push({
                                        t: "c",
                                        pts: l.applyToTriplePoints(h.o[n - 1], h.i[0], h.v[0])
                                    }), a.push({
                                        t: "z"
                                    }))
                                }
                            }
                            t.trNodes = a
                        }
                    }, CVShapeElement.prototype.renderPath = function(t, e) {
                        if (!0 !== t.hd && t._shouldRender) {
                            var n, i = e.styledShapes.length;
                            for (n = 0; n < i; n += 1) this.renderStyledShape(e.styledShapes[n], e.sh)
                        }
                    }, CVShapeElement.prototype.renderFill = function(t, e, n) {
                        var i = e.style;
                        (e.c._mdf || this._isFirstFrame) && (i.co = "rgb(" + bm_floor(e.c.v[0]) + "," + bm_floor(e.c.v[1]) + "," + bm_floor(e.c.v[2]) + ")"), (e.o._mdf || n._opMdf || this._isFirstFrame) && (i.coOp = e.o.v * n.opacity)
                    }, CVShapeElement.prototype.renderGradientFill = function(t, e, n) {
                        var i = e.style;
                        if (!i.grd || e.g._mdf || e.s._mdf || e.e._mdf || 1 !== t.t && (e.h._mdf || e.a._mdf)) {
                            var r = this.globalData.canvasContext,
                                a = e.s.v,
                                s = e.e.v;
                            if (1 === t.t) p = r.createLinearGradient(a[0], a[1], s[0], s[1]);
                            else var o = Math.sqrt(Math.pow(a[0] - s[0], 2) + Math.pow(a[1] - s[1], 2)),
                                l = Math.atan2(s[1] - a[1], s[0] - a[0]),
                                h = o * (e.h.v >= 1 ? .99 : e.h.v <= -1 ? -.99 : e.h.v),
                                u = Math.cos(l + e.a.v) * h + a[0],
                                c = Math.sin(l + e.a.v) * h + a[1],
                                p = r.createRadialGradient(u, c, 0, a[0], a[1], o);
                            var f, d = t.g.p,
                                m = e.g.c,
                                g = 1;
                            for (f = 0; f < d; f += 1) e.g._hasOpacity && e.g._collapsable && (g = e.g.o[2 * f + 1]), p.addColorStop(m[4 * f] / 100, "rgba(" + m[4 * f + 1] + "," + m[4 * f + 2] + "," + m[4 * f + 3] + "," + g + ")");
                            i.grd = p
                        }
                        i.coOp = e.o.v * n.opacity
                    }, CVShapeElement.prototype.renderStroke = function(t, e, n) {
                        var i = e.style,
                            r = e.d;
                        r && (r._mdf || this._isFirstFrame) && (i.da = r.dashArray, i.do = r.dashoffset[0]), (e.c._mdf || this._isFirstFrame) && (i.co = "rgb(" + bm_floor(e.c.v[0]) + "," + bm_floor(e.c.v[1]) + "," + bm_floor(e.c.v[2]) + ")"), (e.o._mdf || n._opMdf || this._isFirstFrame) && (i.coOp = e.o.v * n.opacity), (e.w._mdf || this._isFirstFrame) && (i.wi = e.w.v)
                    }, CVShapeElement.prototype.destroy = function() {
                        this.shapesData = null, this.globalData = null, this.canvasContext = null, this.stylesList.length = 0, this.itemsData.length = 0
                    }, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement), CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVSolidElement.prototype.renderInnerContent = function() {
                        var t = this.canvasContext;
                        t.fillStyle = this.data.sc, t.fillRect(0, 0, this.data.sw, this.data.sh)
                    }, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement), CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d"), CVTextElement.prototype.buildNewText = function() {
                        var t = this.textProperty.currentData;
                        this.renderedLetters = createSizedArray(t.l ? t.l.length : 0);
                        var e = !1;
                        t.fc ? (e = !0, this.values.fill = this.buildColor(t.fc)) : this.values.fill = "rgba(0,0,0,0)", this.fill = e;
                        var n = !1;
                        t.sc && (n = !0, this.values.stroke = this.buildColor(t.sc), this.values.sWidth = t.sw);
                        var i, r, a = this.globalData.fontManager.getFontByName(t.f),
                            s = t.l,
                            o = this.mHelper;
                        this.stroke = n, this.values.fValue = t.finalSize + "px " + this.globalData.fontManager.getFontByName(t.f).fFamily, r = t.finalText.length;
                        var l, h, u, c, p, f, d, m, g, v, y = this.data.singleShape,
                            _ = t.tr / 1e3 * t.finalSize,
                            x = 0,
                            b = 0,
                            E = !0,
                            w = 0;
                        for (i = 0; i < r; i += 1) {
                            for (h = (l = this.globalData.fontManager.getCharData(t.finalText[i], a.fStyle, this.globalData.fontManager.getFontByName(t.f).fFamily)) && l.data || {}, o.reset(), y && s[i].n && (x = -_, b += t.yOffset, b += E ? 1 : 0, E = !1), d = (p = h.shapes ? h.shapes[0].it : []).length, o.scale(t.finalSize / 100, t.finalSize / 100), y && this.applyTextPropertiesToMatrix(t, o, s[i].line, x, b), g = createSizedArray(d), f = 0; f < d; f += 1) {
                                for (c = p[f].ks.k.i.length, m = p[f].ks.k, v = [], u = 1; u < c; u += 1) 1 == u && v.push(o.applyToX(m.v[0][0], m.v[0][1], 0), o.applyToY(m.v[0][0], m.v[0][1], 0)), v.push(o.applyToX(m.o[u - 1][0], m.o[u - 1][1], 0), o.applyToY(m.o[u - 1][0], m.o[u - 1][1], 0), o.applyToX(m.i[u][0], m.i[u][1], 0), o.applyToY(m.i[u][0], m.i[u][1], 0), o.applyToX(m.v[u][0], m.v[u][1], 0), o.applyToY(m.v[u][0], m.v[u][1], 0));
                                v.push(o.applyToX(m.o[u - 1][0], m.o[u - 1][1], 0), o.applyToY(m.o[u - 1][0], m.o[u - 1][1], 0), o.applyToX(m.i[0][0], m.i[0][1], 0), o.applyToY(m.i[0][0], m.i[0][1], 0), o.applyToX(m.v[0][0], m.v[0][1], 0), o.applyToY(m.v[0][0], m.v[0][1], 0)), g[f] = v
                            }
                            y && (x += s[i].l, x += _), this.textSpans[w] ? this.textSpans[w].elem = g : this.textSpans[w] = {
                                elem: g
                            }, w += 1
                        }
                    }, CVTextElement.prototype.renderInnerContent = function() {
                        var t, e, n, i, r, a, s = this.canvasContext;
                        this.finalTransform.mat.props;
                        s.font = this.values.fValue, s.lineCap = "butt", s.lineJoin = "miter", s.miterLimit = 4, this.data.singleShape || this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
                        var o, l = this.textAnimator.renderedLetters,
                            h = this.textProperty.currentData.l;
                        e = h.length;
                        var u, c, p = null,
                            f = null,
                            d = null;
                        for (t = 0; t < e; t += 1)
                            if (!h[t].n) {
                                if ((o = l[t]) && (this.globalData.renderer.save(), this.globalData.renderer.ctxTransform(o.p), this.globalData.renderer.ctxOpacity(o.o)), this.fill) {
                                    for (o && o.fc ? p !== o.fc && (p = o.fc, s.fillStyle = o.fc) : p !== this.values.fill && (p = this.values.fill, s.fillStyle = this.values.fill), i = (u = this.textSpans[t].elem).length, this.globalData.canvasContext.beginPath(), n = 0; n < i; n += 1)
                                        for (a = (c = u[n]).length, this.globalData.canvasContext.moveTo(c[0], c[1]), r = 2; r < a; r += 6) this.globalData.canvasContext.bezierCurveTo(c[r], c[r + 1], c[r + 2], c[r + 3], c[r + 4], c[r + 5]);
                                    this.globalData.canvasContext.closePath(), this.globalData.canvasContext.fill()
                                }
                                if (this.stroke) {
                                    for (o && o.sw ? d !== o.sw && (d = o.sw, s.lineWidth = o.sw) : d !== this.values.sWidth && (d = this.values.sWidth, s.lineWidth = this.values.sWidth), o && o.sc ? f !== o.sc && (f = o.sc, s.strokeStyle = o.sc) : f !== this.values.stroke && (f = this.values.stroke, s.strokeStyle = this.values.stroke), i = (u = this.textSpans[t].elem).length, this.globalData.canvasContext.beginPath(), n = 0; n < i; n += 1)
                                        for (a = (c = u[n]).length, this.globalData.canvasContext.moveTo(c[0], c[1]), r = 2; r < a; r += 6) this.globalData.canvasContext.bezierCurveTo(c[r], c[r + 1], c[r + 2], c[r + 3], c[r + 4], c[r + 5]);
                                    this.globalData.canvasContext.closePath(), this.globalData.canvasContext.stroke()
                                }
                                o && this.globalData.renderer.restore()
                            }
                    }, CVEffects.prototype.renderFrame = function() {}, HBaseElement.prototype = {
                        checkBlendMode: function() {},
                        initRendererElement: function() {
                            this.baseElement = createTag(this.data.tg || "div"), this.data.hasMask ? (this.svgElement = createNS("svg"), this.layerElement = createNS("g"), this.maskedElement = this.layerElement, this.svgElement.appendChild(this.layerElement), this.baseElement.appendChild(this.svgElement)) : this.layerElement = this.baseElement, styleDiv(this.baseElement)
                        },
                        createContainerElements: function() {
                            this.renderableEffectsManager = new CVEffects(this), this.transformedElement = this.baseElement, this.maskedElement = this.layerElement, this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), 0 !== this.data.bm && this.setBlendMode()
                        },
                        renderElement: function() {
                            this.finalTransform._matMdf && (this.transformedElement.style.transform = this.transformedElement.style.webkitTransform = this.finalTransform.mat.toCSS()), this.finalTransform._opMdf && (this.transformedElement.style.opacity = this.finalTransform.mProp.o.v)
                        },
                        renderFrame: function() {
                            this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1))
                        },
                        destroy: function() {
                            this.layerElement = null, this.transformedElement = null, this.matteElement && (this.matteElement = null), this.maskManager && (this.maskManager.destroy(), this.maskManager = null)
                        },
                        createRenderableComponents: function() {
                            this.maskManager = new MaskElement(this.data, this, this.globalData)
                        },
                        addEffects: function() {},
                        setMatte: function() {}
                    }, HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement, HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy, HBaseElement.prototype.buildElementParenting = HybridRenderer.prototype.buildElementParenting, extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement), HSolidElement.prototype.createContent = function() {
                        var t;
                        this.data.hasMask ? ((t = createNS("rect")).setAttribute("width", this.data.sw), t.setAttribute("height", this.data.sh), t.setAttribute("fill", this.data.sc), this.svgElement.setAttribute("width", this.data.sw), this.svgElement.setAttribute("height", this.data.sh)) : ((t = createTag("div")).style.width = this.data.sw + "px", t.style.height = this.data.sh + "px", t.style.backgroundColor = this.data.sc), this.layerElement.appendChild(t)
                    }, extendPrototype([HybridRenderer, ICompElement, HBaseElement], HCompElement), HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements, HCompElement.prototype.createContainerElements = function() {
                        this._createBaseContainerElements(), this.data.hasMask ? (this.svgElement.setAttribute("width", this.data.w), this.svgElement.setAttribute("height", this.data.h), this.transformedElement = this.baseElement) : this.transformedElement = this.layerElement
                    }, HCompElement.prototype.addTo3dContainer = function(t, e) {
                        for (var n, i = 0; i < e;) this.elements[i] && this.elements[i].getBaseElement && (n = this.elements[i].getBaseElement()), i += 1;
                        n ? this.layerElement.insertBefore(t, n) : this.layerElement.appendChild(t)
                    }, extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement), HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent, HShapeElement.prototype.createContent = function() {
                        var t;
                        if (this.baseElement.style.fontSize = 0, this.data.hasMask) this.layerElement.appendChild(this.shapesContainer), t = this.svgElement;
                        else {
                            t = createNS("svg");
                            var e = this.comp.data ? this.comp.data : this.globalData.compSize;
                            t.setAttribute("width", e.w), t.setAttribute("height", e.h), t.appendChild(this.shapesContainer), this.layerElement.appendChild(t)
                        }
                        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], !0), this.filterUniqueShapes(), this.shapeCont = t
                    }, HShapeElement.prototype.getTransformedPoint = function(t, e) {
                        var n, i = t.length;
                        for (n = 0; n < i; n += 1) e = t[n].mProps.v.applyToPointArray(e[0], e[1], 0);
                        return e
                    }, HShapeElement.prototype.calculateShapeBoundingBox = function(t, e) {
                        var n, i, r, a, s, o = t.sh.v,
                            l = t.transformers,
                            h = o._length;
                        if (!(h <= 1)) {
                            for (n = 0; n < h - 1; n += 1) i = this.getTransformedPoint(l, o.v[n]), r = this.getTransformedPoint(l, o.o[n]), a = this.getTransformedPoint(l, o.i[n + 1]), s = this.getTransformedPoint(l, o.v[n + 1]), this.checkBounds(i, r, a, s, e);
                            o.c && (i = this.getTransformedPoint(l, o.v[n]), r = this.getTransformedPoint(l, o.o[n]), a = this.getTransformedPoint(l, o.i[0]), s = this.getTransformedPoint(l, o.v[0]), this.checkBounds(i, r, a, s, e))
                        }
                    }, HShapeElement.prototype.checkBounds = function(t, e, n, i, r) {
                        this.getBoundsOfCurve(t, e, n, i);
                        var a = this.shapeBoundingBox;
                        r.x = bm_min(a.left, r.x), r.xMax = bm_max(a.right, r.xMax), r.y = bm_min(a.top, r.y), r.yMax = bm_max(a.bottom, r.yMax)
                    }, HShapeElement.prototype.shapeBoundingBox = {
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    }, HShapeElement.prototype.tempBoundingBox = {
                        x: 0,
                        xMax: 0,
                        y: 0,
                        yMax: 0,
                        width: 0,
                        height: 0
                    }, HShapeElement.prototype.getBoundsOfCurve = function(t, e, n, i) {
                        for (var r, a, s, o, l, h, u, c = [
                                [t[0], i[0]],
                                [t[1], i[1]]
                            ], p = 0; p < 2; ++p)
                            if (a = 6 * t[p] - 12 * e[p] + 6 * n[p], r = -3 * t[p] + 9 * e[p] - 9 * n[p] + 3 * i[p], s = 3 * e[p] - 3 * t[p], a |= 0, s |= 0, 0 !== (r |= 0))(l = a * a - 4 * s * r) < 0 || (0 < (h = (-a + bm_sqrt(l)) / (2 * r)) && h < 1 && c[p].push(this.calculateF(h, t, e, n, i, p)), 0 < (u = (-a - bm_sqrt(l)) / (2 * r)) && u < 1 && c[p].push(this.calculateF(u, t, e, n, i, p)));
                            else {
                                if (0 === a) continue;
                                0 < (o = -s / a) && o < 1 && c[p].push(this.calculateF(o, t, e, n, i, p))
                            }
                        this.shapeBoundingBox.left = bm_min.apply(null, c[0]), this.shapeBoundingBox.top = bm_min.apply(null, c[1]), this.shapeBoundingBox.right = bm_max.apply(null, c[0]), this.shapeBoundingBox.bottom = bm_max.apply(null, c[1])
                    }, HShapeElement.prototype.calculateF = function(t, e, n, i, r, a) {
                        return bm_pow(1 - t, 3) * e[a] + 3 * bm_pow(1 - t, 2) * t * n[a] + 3 * (1 - t) * bm_pow(t, 2) * i[a] + bm_pow(t, 3) * r[a]
                    }, HShapeElement.prototype.calculateBoundingBox = function(t, e) {
                        var n, i = t.length;
                        for (n = 0; n < i; n += 1) t[n] && t[n].sh ? this.calculateShapeBoundingBox(t[n], e) : t[n] && t[n].it && this.calculateBoundingBox(t[n].it, e)
                    }, HShapeElement.prototype.currentBoxContains = function(t) {
                        return this.currentBBox.x <= t.x && this.currentBBox.y <= t.y && this.currentBBox.width + this.currentBBox.x >= t.x + t.width && this.currentBBox.height + this.currentBBox.y >= t.y + t.height
                    }, HShapeElement.prototype.renderInnerContent = function() {
                        if (this._renderShapeFrame(), !this.hidden && (this._isFirstFrame || this._mdf)) {
                            var t = this.tempBoundingBox,
                                e = 999999;
                            if (t.x = e, t.xMax = -e, t.y = e, t.yMax = -e, this.calculateBoundingBox(this.itemsData, t), t.width = t.xMax < t.x ? 0 : t.xMax - t.x, t.height = t.yMax < t.y ? 0 : t.yMax - t.y, this.currentBoxContains(t)) return;
                            var n = !1;
                            this.currentBBox.w !== t.width && (this.currentBBox.w = t.width, this.shapeCont.setAttribute("width", t.width), n = !0), this.currentBBox.h !== t.height && (this.currentBBox.h = t.height, this.shapeCont.setAttribute("height", t.height), n = !0), (n || this.currentBBox.x !== t.x || this.currentBBox.y !== t.y) && (this.currentBBox.w = t.width, this.currentBBox.h = t.height, this.currentBBox.x = t.x, this.currentBBox.y = t.y, this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h), this.shapeCont.style.transform = this.shapeCont.style.webkitTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)")
                        }
                    }, extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement), HTextElement.prototype.createContent = function() {
                        if (this.isMasked = this.checkMasks(), this.isMasked) {
                            this.renderType = "svg", this.compW = this.comp.data.w, this.compH = this.comp.data.h, this.svgElement.setAttribute("width", this.compW), this.svgElement.setAttribute("height", this.compH);
                            var t = createNS("g");
                            this.maskedElement.appendChild(t), this.innerElem = t
                        } else this.renderType = "html", this.innerElem = this.layerElement;
                        this.checkParenting()
                    }, HTextElement.prototype.buildNewText = function() {
                        var t = this.textProperty.currentData;
                        this.renderedLetters = createSizedArray(t.l ? t.l.length : 0);
                        var e = this.innerElem.style;
                        e.color = e.fill = t.fc ? this.buildColor(t.fc) : "rgba(0,0,0,0)", t.sc && (e.stroke = this.buildColor(t.sc), e.strokeWidth = t.sw + "px");
                        var n, i, r = this.globalData.fontManager.getFontByName(t.f);
                        if (!this.globalData.fontManager.chars)
                            if (e.fontSize = t.finalSize + "px", e.lineHeight = t.finalSize + "px", r.fClass) this.innerElem.className = r.fClass;
                            else {
                                e.fontFamily = r.fFamily;
                                var a = t.fWeight,
                                    s = t.fStyle;
                                e.fontStyle = s, e.fontWeight = a
                            }
                        var o, l, h, u = t.l;
                        i = u.length;
                        var c, p = this.mHelper,
                            f = "",
                            d = 0;
                        for (n = 0; n < i; n += 1) {
                            if (this.globalData.fontManager.chars ? (this.textPaths[d] ? o = this.textPaths[d] : ((o = createNS("path")).setAttribute("stroke-linecap", "butt"), o.setAttribute("stroke-linejoin", "round"), o.setAttribute("stroke-miterlimit", "4")), this.isMasked || (this.textSpans[d] ? h = (l = this.textSpans[d]).children[0] : ((l = createTag("div")).style.lineHeight = 0, (h = createNS("svg")).appendChild(o), styleDiv(l)))) : this.isMasked ? o = this.textPaths[d] ? this.textPaths[d] : createNS("text") : this.textSpans[d] ? (l = this.textSpans[d], o = this.textPaths[d]) : (styleDiv(l = createTag("span")), styleDiv(o = createTag("span")), l.appendChild(o)), this.globalData.fontManager.chars) {
                                var m, g = this.globalData.fontManager.getCharData(t.finalText[n], r.fStyle, this.globalData.fontManager.getFontByName(t.f).fFamily);
                                if (m = g ? g.data : null, p.reset(), m && m.shapes && (c = m.shapes[0].it, p.scale(t.finalSize / 100, t.finalSize / 100), f = this.createPathShape(p, c), o.setAttribute("d", f)), this.isMasked) this.innerElem.appendChild(o);
                                else {
                                    if (this.innerElem.appendChild(l), m && m.shapes) {
                                        document.body.appendChild(h);
                                        var v = h.getBBox();
                                        h.setAttribute("width", v.width + 2), h.setAttribute("height", v.height + 2), h.setAttribute("viewBox", v.x - 1 + " " + (v.y - 1) + " " + (v.width + 2) + " " + (v.height + 2)), h.style.transform = h.style.webkitTransform = "translate(" + (v.x - 1) + "px," + (v.y - 1) + "px)", u[n].yOffset = v.y - 1
                                    } else h.setAttribute("width", 1), h.setAttribute("height", 1);
                                    l.appendChild(h)
                                }
                            } else o.textContent = u[n].val, o.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), this.isMasked ? this.innerElem.appendChild(o) : (this.innerElem.appendChild(l), o.style.transform = o.style.webkitTransform = "translate3d(0," + -t.finalSize / 1.2 + "px,0)");
                            this.isMasked ? this.textSpans[d] = o : this.textSpans[d] = l, this.textSpans[d].style.display = "block", this.textPaths[d] = o, d += 1
                        }
                        for (; d < this.textSpans.length;) this.textSpans[d].style.display = "none", d += 1
                    }, HTextElement.prototype.renderInnerContent = function() {
                        if (this.data.singleShape) {
                            if (!this._isFirstFrame && !this.lettersChangedFlag) return;
                            this.isMasked && this.finalTransform._matMdf && (this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH), this.svgElement.style.transform = this.svgElement.style.webkitTransform = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)")
                        }
                        if (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
                            var t, e, n, i, r, a = 0,
                                s = this.textAnimator.renderedLetters,
                                o = this.textProperty.currentData.l;
                            for (e = o.length, t = 0; t < e; t += 1) o[t].n ? a += 1 : (i = this.textSpans[t], r = this.textPaths[t], n = s[a], a += 1, n._mdf.m && (this.isMasked ? i.setAttribute("transform", n.m) : i.style.transform = i.style.webkitTransform = n.m), i.style.opacity = n.o, n.sw && n._mdf.sw && r.setAttribute("stroke-width", n.sw), n.sc && n._mdf.sc && r.setAttribute("stroke", n.sc), n.fc && n._mdf.fc && (r.setAttribute("fill", n.fc), r.style.color = n.fc));
                            if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
                                var l = this.innerElem.getBBox();
                                this.currentBBox.w !== l.width && (this.currentBBox.w = l.width, this.svgElement.setAttribute("width", l.width)), this.currentBBox.h !== l.height && (this.currentBBox.h = l.height, this.svgElement.setAttribute("height", l.height));
                                this.currentBBox.w === l.width + 2 && this.currentBBox.h === l.height + 2 && this.currentBBox.x === l.x - 1 && this.currentBBox.y === l.y - 1 || (this.currentBBox.w = l.width + 2, this.currentBBox.h = l.height + 2, this.currentBBox.x = l.x - 1, this.currentBBox.y = l.y - 1, this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h), this.svgElement.style.transform = this.svgElement.style.webkitTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)")
                            }
                        }
                    }, extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement), HImageElement.prototype.createContent = function() {
                        var t = this.globalData.getAssetsPath(this.assetData),
                            e = new Image;
                        this.data.hasMask ? (this.imageElem = createNS("image"), this.imageElem.setAttribute("width", this.assetData.w + "px"), this.imageElem.setAttribute("height", this.assetData.h + "px"), this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", t), this.layerElement.appendChild(this.imageElem), this.baseElement.setAttribute("width", this.assetData.w), this.baseElement.setAttribute("height", this.assetData.h)) : this.layerElement.appendChild(e), e.crossOrigin = "anonymous", e.src = t, this.data.ln && this.baseElement.setAttribute("id", this.data.ln)
                    }, extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement), HCameraElement.prototype.setup = function() {
                        var t, e, n = this.comp.threeDElements.length;
                        for (t = 0; t < n; t += 1) "3d" === (e = this.comp.threeDElements[t]).type && (e.perspectiveElem.style.perspective = e.perspectiveElem.style.webkitPerspective = this.pe.v + "px", e.container.style.transformOrigin = e.container.style.mozTransformOrigin = e.container.style.webkitTransformOrigin = "0px 0px 0px", e.perspectiveElem.style.transform = e.perspectiveElem.style.webkitTransform = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)")
                    }, HCameraElement.prototype.createElements = function() {}, HCameraElement.prototype.hide = function() {}, HCameraElement.prototype.renderFrame = function() {
                        var t, e, n = this._isFirstFrame;
                        if (this.hierarchy)
                            for (e = this.hierarchy.length, t = 0; t < e; t += 1) n = this.hierarchy[t].finalTransform.mProp._mdf || n;
                        if (n || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
                            if (this.mat.reset(), this.hierarchy)
                                for (t = e = this.hierarchy.length - 1; t >= 0; t -= 1) {
                                    var i = this.hierarchy[t].finalTransform.mProp;
                                    this.mat.translate(-i.p.v[0], -i.p.v[1], i.p.v[2]), this.mat.rotateX(-i.or.v[0]).rotateY(-i.or.v[1]).rotateZ(i.or.v[2]), this.mat.rotateX(-i.rx.v).rotateY(-i.ry.v).rotateZ(i.rz.v), this.mat.scale(1 / i.s.v[0], 1 / i.s.v[1], 1 / i.s.v[2]), this.mat.translate(i.a.v[0], i.a.v[1], i.a.v[2])
                                }
                            if (this.p ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]) : this.mat.translate(-this.px.v, -this.py.v, this.pz.v), this.a) {
                                var r;
                                r = this.p ? [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]] : [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
                                var a = Math.sqrt(Math.pow(r[0], 2) + Math.pow(r[1], 2) + Math.pow(r[2], 2)),
                                    s = [r[0] / a, r[1] / a, r[2] / a],
                                    o = Math.sqrt(s[2] * s[2] + s[0] * s[0]),
                                    l = Math.atan2(s[1], o),
                                    h = Math.atan2(s[0], -s[2]);
                                this.mat.rotateY(h).rotateX(-l)
                            }
                            this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v), this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]), this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0), this.mat.translate(0, 0, this.pe.v);
                            var u = !this._prevMat.equals(this.mat);
                            if ((u || this.pe._mdf) && this.comp.threeDElements) {
                                var c;
                                for (e = this.comp.threeDElements.length, t = 0; t < e; t += 1) "3d" === (c = this.comp.threeDElements[t]).type && (u && (c.container.style.transform = c.container.style.webkitTransform = this.mat.toCSS()), this.pe._mdf && (c.perspectiveElem.style.perspective = c.perspectiveElem.style.webkitPerspective = this.pe.v + "px"));
                                this.mat.clone(this._prevMat)
                            }
                        }
                        this._isFirstFrame = !1
                    }, HCameraElement.prototype.prepareFrame = function(t) {
                        this.prepareProperties(t, !0)
                    }, HCameraElement.prototype.destroy = function() {}, HCameraElement.prototype.getBaseElement = function() {
                        return null
                    }, HEffects.prototype.renderFrame = function() {};
                    var animationManager = function() {
                            var t = {},
                                e = [],
                                n = 0,
                                i = 0,
                                r = 0,
                                a = !0,
                                s = !1;

                            function o(t) {
                                for (var n = 0, r = t.target; n < i;) e[n].animation === r && (e.splice(n, 1), n -= 1, i -= 1, r.isPaused || u()), n += 1
                            }

                            function l(t, n) {
                                if (!t) return null;
                                for (var r = 0; r < i;) {
                                    if (e[r].elem == t && null !== e[r].elem) return e[r].animation;
                                    r += 1
                                }
                                var a = new AnimationItem;
                                return c(a, t), a.setData(t, n), a
                            }

                            function h() {
                                r += 1, d()
                            }

                            function u() {
                                r -= 1
                            }

                            function c(t, n) {
                                t.addEventListener("destroy", o), t.addEventListener("_active", h), t.addEventListener("_idle", u), e.push({
                                    elem: n,
                                    animation: t
                                }), i += 1
                            }

                            function p(t) {
                                var o, l = t - n;
                                for (o = 0; o < i; o += 1) e[o].animation.advanceTime(l);
                                n = t, r && !s ? window.requestAnimationFrame(p) : a = !0
                            }

                            function f(t) {
                                n = t, window.requestAnimationFrame(p)
                            }

                            function d() {
                                !s && r && a && (window.requestAnimationFrame(f), a = !1)
                            }
                            return t.registerAnimation = l, t.loadAnimation = function(t) {
                                var e = new AnimationItem;
                                return c(e, null), e.setParams(t), e
                            }, t.setSpeed = function(t, n) {
                                var r;
                                for (r = 0; r < i; r += 1) e[r].animation.setSpeed(t, n)
                            }, t.setDirection = function(t, n) {
                                var r;
                                for (r = 0; r < i; r += 1) e[r].animation.setDirection(t, n)
                            }, t.play = function(t) {
                                var n;
                                for (n = 0; n < i; n += 1) e[n].animation.play(t)
                            }, t.pause = function(t) {
                                var n;
                                for (n = 0; n < i; n += 1) e[n].animation.pause(t)
                            }, t.stop = function(t) {
                                var n;
                                for (n = 0; n < i; n += 1) e[n].animation.stop(t)
                            }, t.togglePause = function(t) {
                                var n;
                                for (n = 0; n < i; n += 1) e[n].animation.togglePause(t)
                            }, t.searchAnimations = function(t, e, n) {
                                var i, r = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin"))),
                                    a = r.length;
                                for (i = 0; i < a; i += 1) n && r[i].setAttribute("data-bm-type", n), l(r[i], t);
                                if (e && 0 === a) {
                                    n || (n = "svg");
                                    var s = document.getElementsByTagName("body")[0];
                                    s.innerText = "";
                                    var o = createTag("div");
                                    o.style.width = "100%", o.style.height = "100%", o.setAttribute("data-bm-type", n), s.appendChild(o), l(o, t)
                                }
                            }, t.resize = function() {
                                var t;
                                for (t = 0; t < i; t += 1) e[t].animation.resize()
                            }, t.goToAndStop = function(t, n, r) {
                                var a;
                                for (a = 0; a < i; a += 1) e[a].animation.goToAndStop(t, n, r)
                            }, t.destroy = function(t) {
                                var n;
                                for (n = i - 1; n >= 0; n -= 1) e[n].animation.destroy(t)
                            }, t.freeze = function() {
                                s = !0
                            }, t.unfreeze = function() {
                                s = !1, d()
                            }, t.setVolume = function(t, n) {
                                var r;
                                for (r = 0; r < i; r += 1) e[r].animation.setVolume(t, n)
                            }, t.mute = function(t) {
                                var n;
                                for (n = 0; n < i; n += 1) e[n].animation.mute(t)
                            }, t.unmute = function(t) {
                                var n;
                                for (n = 0; n < i; n += 1) e[n].animation.unmute(t)
                            }, t.getRegisteredAnimations = function() {
                                var t, n = e.length,
                                    i = [];
                                for (t = 0; t < n; t += 1) i.push(e[t].animation);
                                return i
                            }, t
                        }(),
                        AnimationItem = function() {
                            this._cbs = [], this.name = "", this.path = "", this.isLoaded = !1, this.currentFrame = 0, this.currentRawFrame = 0, this.firstFrame = 0, this.totalFrames = 0, this.frameRate = 0, this.frameMult = 0, this.playSpeed = 1, this.playDirection = 1, this.playCount = 0, this.animationData = {}, this.assets = [], this.isPaused = !0, this.autoplay = !1, this.loop = !0, this.renderer = null, this.animationID = createElementID(), this.assetsPath = "", this.timeCompleted = 0, this.segmentPos = 0, this.isSubframeEnabled = subframeEnabled, this.segments = [], this._idle = !0, this._completedLoop = !1, this.projectInterface = ProjectInterface(), this.imagePreloader = new ImagePreloader, this.audioController = audioControllerFactory()
                        };
                    extendPrototype([BaseEvent], AnimationItem), AnimationItem.prototype.setParams = function(t) {
                        (t.wrapper || t.container) && (this.wrapper = t.wrapper || t.container);
                        var e = t.animType ? t.animType : t.renderer ? t.renderer : "svg";
                        switch (e) {
                            case "canvas":
                                this.renderer = new CanvasRenderer(this, t.rendererSettings);
                                break;
                            case "svg":
                                this.renderer = new SVGRenderer(this, t.rendererSettings);
                                break;
                            default:
                                this.renderer = new HybridRenderer(this, t.rendererSettings)
                        }
                        this.imagePreloader.setCacheType(e, this.renderer.globalData.defs), this.renderer.setProjectInterface(this.projectInterface), this.animType = e, "" === t.loop || null === t.loop || void 0 === t.loop || !0 === t.loop ? this.loop = !0 : !1 === t.loop ? this.loop = !1 : this.loop = parseInt(t.loop), this.autoplay = !("autoplay" in t) || t.autoplay, this.name = t.name ? t.name : "", this.autoloadSegments = !t.hasOwnProperty("autoloadSegments") || t.autoloadSegments, this.assetsPath = t.assetsPath, this.initialSegment = t.initialSegment, t.audioFactory && this.audioController.setAudioFactory(t.audioFactory), t.animationData ? this.configAnimation(t.animationData) : t.path && (-1 !== t.path.lastIndexOf("\\") ? this.path = t.path.substr(0, t.path.lastIndexOf("\\") + 1) : this.path = t.path.substr(0, t.path.lastIndexOf("/") + 1), this.fileName = t.path.substr(t.path.lastIndexOf("/") + 1), this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json")), assetLoader.load(t.path, this.configAnimation.bind(this), function() {
                            this.trigger("data_failed")
                        }.bind(this)))
                    }, AnimationItem.prototype.setData = function(t, e) {
                        var n = {
                                wrapper: t,
                                animationData: e ? "object" == typeof e ? e : JSON.parse(e) : null
                            },
                            i = t.attributes;
                        n.path = i.getNamedItem("data-animation-path") ? i.getNamedItem("data-animation-path").value : i.getNamedItem("data-bm-path") ? i.getNamedItem("data-bm-path").value : i.getNamedItem("bm-path") ? i.getNamedItem("bm-path").value : "", n.animType = i.getNamedItem("data-anim-type") ? i.getNamedItem("data-anim-type").value : i.getNamedItem("data-bm-type") ? i.getNamedItem("data-bm-type").value : i.getNamedItem("bm-type") ? i.getNamedItem("bm-type").value : i.getNamedItem("data-bm-renderer") ? i.getNamedItem("data-bm-renderer").value : i.getNamedItem("bm-renderer") ? i.getNamedItem("bm-renderer").value : "canvas";
                        var r = i.getNamedItem("data-anim-loop") ? i.getNamedItem("data-anim-loop").value : i.getNamedItem("data-bm-loop") ? i.getNamedItem("data-bm-loop").value : i.getNamedItem("bm-loop") ? i.getNamedItem("bm-loop").value : "";
                        "" === r || (n.loop = "false" !== r && ("true" === r || parseInt(r)));
                        var a = i.getNamedItem("data-anim-autoplay") ? i.getNamedItem("data-anim-autoplay").value : i.getNamedItem("data-bm-autoplay") ? i.getNamedItem("data-bm-autoplay").value : !i.getNamedItem("bm-autoplay") || i.getNamedItem("bm-autoplay").value;
                        n.autoplay = "false" !== a, n.name = i.getNamedItem("data-name") ? i.getNamedItem("data-name").value : i.getNamedItem("data-bm-name") ? i.getNamedItem("data-bm-name").value : i.getNamedItem("bm-name") ? i.getNamedItem("bm-name").value : "", "false" === (i.getNamedItem("data-anim-prerender") ? i.getNamedItem("data-anim-prerender").value : i.getNamedItem("data-bm-prerender") ? i.getNamedItem("data-bm-prerender").value : i.getNamedItem("bm-prerender") ? i.getNamedItem("bm-prerender").value : "") && (n.prerender = !1), this.setParams(n)
                    }, AnimationItem.prototype.includeLayers = function(t) {
                        t.op > this.animationData.op && (this.animationData.op = t.op, this.totalFrames = Math.floor(t.op - this.animationData.ip));
                        var e, n, i = this.animationData.layers,
                            r = i.length,
                            a = t.layers,
                            s = a.length;
                        for (n = 0; n < s; n += 1)
                            for (e = 0; e < r;) {
                                if (i[e].id == a[n].id) {
                                    i[e] = a[n];
                                    break
                                }
                                e += 1
                            }
                        if ((t.chars || t.fonts) && (this.renderer.globalData.fontManager.addChars(t.chars), this.renderer.globalData.fontManager.addFonts(t.fonts, this.renderer.globalData.defs)), t.assets)
                            for (r = t.assets.length, e = 0; e < r; e += 1) this.animationData.assets.push(t.assets[e]);
                        this.animationData.__complete = !1, dataManager.completeData(this.animationData, this.renderer.globalData.fontManager), this.renderer.includeLayers(t.layers), expressionsPlugin && expressionsPlugin.initExpressions(this), this.loadNextSegment()
                    }, AnimationItem.prototype.loadNextSegment = function() {
                        var t = this.animationData.segments;
                        if (!t || 0 === t.length || !this.autoloadSegments) return this.trigger("data_ready"), void(this.timeCompleted = this.totalFrames);
                        var e = t.shift();
                        this.timeCompleted = e.time * this.frameRate;
                        var n = this.path + this.fileName + "_" + this.segmentPos + ".json";
                        this.segmentPos += 1, assetLoader.load(n, this.includeLayers.bind(this), function() {
                            this.trigger("data_failed")
                        }.bind(this))
                    }, AnimationItem.prototype.loadSegments = function() {
                        this.animationData.segments || (this.timeCompleted = this.totalFrames), this.loadNextSegment()
                    }, AnimationItem.prototype.imagesLoaded = function() {
                        this.trigger("loaded_images"), this.checkLoaded()
                    }, AnimationItem.prototype.preloadImages = function() {
                        this.imagePreloader.setAssetsPath(this.assetsPath), this.imagePreloader.setPath(this.path), this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this))
                    }, AnimationItem.prototype.configAnimation = function(t) {
                        if (this.renderer) try {
                            this.animationData = t, this.initialSegment ? (this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]), this.firstFrame = Math.round(this.initialSegment[0])) : (this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip), this.firstFrame = Math.round(this.animationData.ip)), this.renderer.configAnimation(t), t.assets || (t.assets = []), this.assets = this.animationData.assets, this.frameRate = this.animationData.fr, this.frameMult = this.animationData.fr / 1e3, this.renderer.searchExtraCompositions(t.assets), this.trigger("config_ready"), this.preloadImages(), this.loadSegments(), this.updaFrameModifier(), this.waitForFontsLoaded(), this.isPaused && this.audioController.pause()
                        } catch (t) {
                            this.triggerConfigError(t)
                        }
                    }, AnimationItem.prototype.waitForFontsLoaded = function() {
                        this.renderer && (this.renderer.globalData.fontManager.isLoaded ? this.checkLoaded() : setTimeout(this.waitForFontsLoaded.bind(this), 20))
                    }, AnimationItem.prototype.checkLoaded = function() {
                        this.isLoaded || !this.renderer.globalData.fontManager.isLoaded || !this.imagePreloader.loaded() && "canvas" === this.renderer.rendererType || (this.isLoaded = !0, dataManager.completeData(this.animationData, this.renderer.globalData.fontManager), expressionsPlugin && expressionsPlugin.initExpressions(this), this.renderer.initItems(), setTimeout(function() {
                            this.trigger("DOMLoaded")
                        }.bind(this), 0), this.gotoFrame(), this.autoplay && this.play())
                    }, AnimationItem.prototype.resize = function() {
                        this.renderer.updateContainerSize()
                    }, AnimationItem.prototype.setSubframe = function(t) {
                        this.isSubframeEnabled = !!t
                    }, AnimationItem.prototype.gotoFrame = function() {
                        this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame, this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted && (this.currentFrame = this.timeCompleted), this.trigger("enterFrame"), this.renderFrame()
                    }, AnimationItem.prototype.renderFrame = function() {
                        if (!1 !== this.isLoaded) try {
                            this.renderer.renderFrame(this.currentFrame + this.firstFrame)
                        } catch (t) {
                            this.triggerRenderFrameError(t)
                        }
                    }, AnimationItem.prototype.play = function(t) {
                        t && this.name != t || !0 === this.isPaused && (this.isPaused = !1, this.audioController.resume(), this._idle && (this._idle = !1, this.trigger("_active")))
                    }, AnimationItem.prototype.pause = function(t) {
                        t && this.name != t || !1 === this.isPaused && (this.isPaused = !0, this._idle = !0, this.trigger("_idle"), this.audioController.pause())
                    }, AnimationItem.prototype.togglePause = function(t) {
                        t && this.name != t || (!0 === this.isPaused ? this.play() : this.pause())
                    }, AnimationItem.prototype.stop = function(t) {
                        t && this.name != t || (this.pause(), this.playCount = 0, this._completedLoop = !1, this.setCurrentRawFrameValue(0))
                    }, AnimationItem.prototype.goToAndStop = function(t, e, n) {
                        n && this.name != n || (e ? this.setCurrentRawFrameValue(t) : this.setCurrentRawFrameValue(t * this.frameModifier), this.pause())
                    }, AnimationItem.prototype.goToAndPlay = function(t, e, n) {
                        this.goToAndStop(t, e, n), this.play()
                    }, AnimationItem.prototype.advanceTime = function(t) {
                        if (!0 !== this.isPaused && !1 !== this.isLoaded) {
                            var e = this.currentRawFrame + t * this.frameModifier,
                                n = !1;
                            e >= this.totalFrames - 1 && this.frameModifier > 0 ? this.loop && this.playCount !== this.loop ? e >= this.totalFrames ? (this.playCount += 1, this.checkSegments(e % this.totalFrames) || (this.setCurrentRawFrameValue(e % this.totalFrames), this._completedLoop = !0, this.trigger("loopComplete"))) : this.setCurrentRawFrameValue(e) : this.checkSegments(e > this.totalFrames ? e % this.totalFrames : 0) || (n = !0, e = this.totalFrames - 1) : e < 0 ? this.checkSegments(e % this.totalFrames) || (!this.loop || this.playCount-- <= 0 && !0 !== this.loop ? (n = !0, e = 0) : (this.setCurrentRawFrameValue(this.totalFrames + e % this.totalFrames), this._completedLoop ? this.trigger("loopComplete") : this._completedLoop = !0)) : this.setCurrentRawFrameValue(e), n && (this.setCurrentRawFrameValue(e), this.pause(), this.trigger("complete"))
                        }
                    }, AnimationItem.prototype.adjustSegment = function(t, e) {
                        this.playCount = 0, t[1] < t[0] ? (this.frameModifier > 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)), this.timeCompleted = this.totalFrames = t[0] - t[1], this.firstFrame = t[1], this.setCurrentRawFrameValue(this.totalFrames - .001 - e)) : t[1] > t[0] && (this.frameModifier < 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)), this.timeCompleted = this.totalFrames = t[1] - t[0], this.firstFrame = t[0], this.setCurrentRawFrameValue(.001 + e)), this.trigger("segmentStart")
                    }, AnimationItem.prototype.setSegment = function(t, e) {
                        var n = -1;
                        this.isPaused && (this.currentRawFrame + this.firstFrame < t ? n = t : this.currentRawFrame + this.firstFrame > e && (n = e - t)), this.firstFrame = t, this.timeCompleted = this.totalFrames = e - t, -1 !== n && this.goToAndStop(n, !0)
                    }, AnimationItem.prototype.playSegments = function(t, e) {
                        if (e && (this.segments.length = 0), "object" == typeof t[0]) {
                            var n, i = t.length;
                            for (n = 0; n < i; n += 1) this.segments.push(t[n])
                        } else this.segments.push(t);
                        this.segments.length && e && this.adjustSegment(this.segments.shift(), 0), this.isPaused && this.play()
                    }, AnimationItem.prototype.resetSegments = function(t) {
                        this.segments.length = 0, this.segments.push([this.animationData.ip, this.animationData.op]), t && this.checkSegments(0)
                    }, AnimationItem.prototype.checkSegments = function(t) {
                        return !!this.segments.length && (this.adjustSegment(this.segments.shift(), t), !0)
                    }, AnimationItem.prototype.destroy = function(t) {
                        t && this.name != t || !this.renderer || (this.renderer.destroy(), this.imagePreloader.destroy(), this.trigger("destroy"), this._cbs = null, this.onEnterFrame = this.onLoopComplete = this.onComplete = this.onSegmentStart = this.onDestroy = null, this.renderer = null)
                    }, AnimationItem.prototype.setCurrentRawFrameValue = function(t) {
                        this.currentRawFrame = t, this.gotoFrame()
                    }, AnimationItem.prototype.setSpeed = function(t) {
                        this.playSpeed = t, this.updaFrameModifier()
                    }, AnimationItem.prototype.setDirection = function(t) {
                        this.playDirection = t < 0 ? -1 : 1, this.updaFrameModifier()
                    }, AnimationItem.prototype.setVolume = function(t, e) {
                        e && this.name !== e || this.audioController.setVolume(t)
                    }, AnimationItem.prototype.getVolume = function() {
                        return this.audioController.getVolume()
                    }, AnimationItem.prototype.mute = function(t) {
                        t && this.name !== t || this.audioController.mute()
                    }, AnimationItem.prototype.unmute = function(t) {
                        t && this.name !== t || this.audioController.unmute()
                    }, AnimationItem.prototype.updaFrameModifier = function() {
                        this.frameModifier = this.frameMult * this.playSpeed * this.playDirection, this.audioController.setRate(this.playSpeed * this.playDirection)
                    }, AnimationItem.prototype.getPath = function() {
                        return this.path
                    }, AnimationItem.prototype.getAssetsPath = function(t) {
                        var e = "";
                        if (t.e) e = t.p;
                        else if (this.assetsPath) {
                            var n = t.p; - 1 !== n.indexOf("images/") && (n = n.split("/")[1]), e = this.assetsPath + n
                        } else e = this.path, e += t.u ? t.u : "", e += t.p;
                        return e
                    }, AnimationItem.prototype.getAssetData = function(t) {
                        for (var e = 0, n = this.assets.length; e < n;) {
                            if (t == this.assets[e].id) return this.assets[e];
                            e += 1
                        }
                    }, AnimationItem.prototype.hide = function() {
                        this.renderer.hide()
                    }, AnimationItem.prototype.show = function() {
                        this.renderer.show()
                    }, AnimationItem.prototype.getDuration = function(t) {
                        return t ? this.totalFrames : this.totalFrames / this.frameRate
                    }, AnimationItem.prototype.trigger = function(t) {
                        if (this._cbs && this._cbs[t]) switch (t) {
                            case "enterFrame":
                                this.triggerEvent(t, new BMEnterFrameEvent(t, this.currentFrame, this.totalFrames, this.frameModifier));
                                break;
                            case "loopComplete":
                                this.triggerEvent(t, new BMCompleteLoopEvent(t, this.loop, this.playCount, this.frameMult));
                                break;
                            case "complete":
                                this.triggerEvent(t, new BMCompleteEvent(t, this.frameMult));
                                break;
                            case "segmentStart":
                                this.triggerEvent(t, new BMSegmentStartEvent(t, this.firstFrame, this.totalFrames));
                                break;
                            case "destroy":
                                this.triggerEvent(t, new BMDestroyEvent(t, this));
                                break;
                            default:
                                this.triggerEvent(t)
                        }
                        "enterFrame" === t && this.onEnterFrame && this.onEnterFrame.call(this, new BMEnterFrameEvent(t, this.currentFrame, this.totalFrames, this.frameMult)), "loopComplete" === t && this.onLoopComplete && this.onLoopComplete.call(this, new BMCompleteLoopEvent(t, this.loop, this.playCount, this.frameMult)), "complete" === t && this.onComplete && this.onComplete.call(this, new BMCompleteEvent(t, this.frameMult)), "segmentStart" === t && this.onSegmentStart && this.onSegmentStart.call(this, new BMSegmentStartEvent(t, this.firstFrame, this.totalFrames)), "destroy" === t && this.onDestroy && this.onDestroy.call(this, new BMDestroyEvent(t, this))
                    }, AnimationItem.prototype.triggerRenderFrameError = function(t) {
                        var e = new BMRenderFrameErrorEvent(t, this.currentFrame);
                        this.triggerEvent("error", e), this.onError && this.onError.call(this, e)
                    }, AnimationItem.prototype.triggerConfigError = function(t) {
                        var e = new BMConfigErrorEvent(t, this.currentFrame);
                        this.triggerEvent("error", e), this.onError && this.onError.call(this, e)
                    };
                    var Expressions = function() {
                        var t = {};
                        return t.initExpressions = function(t) {
                            var e = 0,
                                n = [];
                            t.renderer.compInterface = CompExpressionInterface(t.renderer), t.renderer.globalData.projectInterface.registerComposition(t.renderer), t.renderer.globalData.pushExpression = function() {
                                e += 1
                            }, t.renderer.globalData.popExpression = function() {
                                0 === (e -= 1) && function() {
                                    var t, e = n.length;
                                    for (t = 0; t < e; t += 1) n[t].release();
                                    n.length = 0
                                }()
                            }, t.renderer.globalData.registerExpressionProperty = function(t) {
                                -1 === n.indexOf(t) && n.push(t)
                            }
                        }, t
                    }();
                    expressionsPlugin = Expressions;
                    var ExpressionManager = function() {
                            var ob = {},
                                Math = BMMath,
                                window = null,
                                document = null;

                            function $bm_isInstanceOfArray(t) {
                                return t.constructor === Array || t.constructor === Float32Array
                            }

                            function isNumerable(t, e) {
                                return "number" === t || "boolean" === t || "string" === t || e instanceof Number
                            }

                            function $bm_neg(t) {
                                var e = typeof t;
                                if ("number" === e || "boolean" === e || t instanceof Number) return -t;
                                if ($bm_isInstanceOfArray(t)) {
                                    var n, i = t.length,
                                        r = [];
                                    for (n = 0; n < i; n += 1) r[n] = -t[n];
                                    return r
                                }
                                return t.propType ? t.v : void 0
                            }
                            var easeInBez = BezierFactory.getBezierEasing(.333, 0, .833, .833, "easeIn").get,
                                easeOutBez = BezierFactory.getBezierEasing(.167, .167, .667, 1, "easeOut").get,
                                easeInOutBez = BezierFactory.getBezierEasing(.33, 0, .667, 1, "easeInOut").get;

                            function sum(t, e) {
                                var n = typeof t,
                                    i = typeof e;
                                if ("string" === n || "string" === i) return t + e;
                                if (isNumerable(n, t) && isNumerable(i, e)) return t + e;
                                if ($bm_isInstanceOfArray(t) && isNumerable(i, e)) return (t = t.slice(0))[0] = t[0] + e, t;
                                if (isNumerable(n, t) && $bm_isInstanceOfArray(e)) return (e = e.slice(0))[0] = t + e[0], e;
                                if ($bm_isInstanceOfArray(t) && $bm_isInstanceOfArray(e)) {
                                    for (var r = 0, a = t.length, s = e.length, o = []; r < a || r < s;)("number" == typeof t[r] || t[r] instanceof Number) && ("number" == typeof e[r] || e[r] instanceof Number) ? o[r] = t[r] + e[r] : o[r] = void 0 === e[r] ? t[r] : t[r] || e[r], r += 1;
                                    return o
                                }
                                return 0
                            }
                            var add = sum;

                            function sub(t, e) {
                                var n = typeof t,
                                    i = typeof e;
                                if (isNumerable(n, t) && isNumerable(i, e)) return "string" === n && (t = parseInt(t)), "string" === i && (e = parseInt(e)), t - e;
                                if ($bm_isInstanceOfArray(t) && isNumerable(i, e)) return (t = t.slice(0))[0] = t[0] - e, t;
                                if (isNumerable(n, t) && $bm_isInstanceOfArray(e)) return (e = e.slice(0))[0] = t - e[0], e;
                                if ($bm_isInstanceOfArray(t) && $bm_isInstanceOfArray(e)) {
                                    for (var r = 0, a = t.length, s = e.length, o = []; r < a || r < s;)("number" == typeof t[r] || t[r] instanceof Number) && ("number" == typeof e[r] || e[r] instanceof Number) ? o[r] = t[r] - e[r] : o[r] = void 0 === e[r] ? t[r] : t[r] || e[r], r += 1;
                                    return o
                                }
                                return 0
                            }

                            function mul(t, e) {
                                var n, i, r, a = typeof t,
                                    s = typeof e;
                                if (isNumerable(a, t) && isNumerable(s, e)) return t * e;
                                if ($bm_isInstanceOfArray(t) && isNumerable(s, e)) {
                                    for (r = t.length, n = createTypedArray("float32", r), i = 0; i < r; i += 1) n[i] = t[i] * e;
                                    return n
                                }
                                if (isNumerable(a, t) && $bm_isInstanceOfArray(e)) {
                                    for (r = e.length, n = createTypedArray("float32", r), i = 0; i < r; i += 1) n[i] = t * e[i];
                                    return n
                                }
                                return 0
                            }

                            function div(t, e) {
                                var n, i, r, a = typeof t,
                                    s = typeof e;
                                if (isNumerable(a, t) && isNumerable(s, e)) return t / e;
                                if ($bm_isInstanceOfArray(t) && isNumerable(s, e)) {
                                    for (r = t.length, n = createTypedArray("float32", r), i = 0; i < r; i += 1) n[i] = t[i] / e;
                                    return n
                                }
                                if (isNumerable(a, t) && $bm_isInstanceOfArray(e)) {
                                    for (r = e.length, n = createTypedArray("float32", r), i = 0; i < r; i += 1) n[i] = t / e[i];
                                    return n
                                }
                                return 0
                            }

                            function mod(t, e) {
                                return "string" == typeof t && (t = parseInt(t)), "string" == typeof e && (e = parseInt(e)), t % e
                            }
                            var $bm_sum = sum,
                                $bm_sub = sub,
                                $bm_mul = mul,
                                $bm_div = div,
                                $bm_mod = mod;

                            function clamp(t, e, n) {
                                if (e > n) {
                                    var i = n;
                                    n = e, e = i
                                }
                                return Math.min(Math.max(t, e), n)
                            }

                            function radiansToDegrees(t) {
                                return t / degToRads
                            }
                            var radians_to_degrees = radiansToDegrees;

                            function degreesToRadians(t) {
                                return t * degToRads
                            }
                            var degrees_to_radians = radiansToDegrees,
                                helperLengthArray = [0, 0, 0, 0, 0, 0];

                            function length(t, e) {
                                if ("number" == typeof t || t instanceof Number) return e = e || 0, Math.abs(t - e);
                                e || (e = helperLengthArray);
                                var n, i = Math.min(t.length, e.length),
                                    r = 0;
                                for (n = 0; n < i; n += 1) r += Math.pow(e[n] - t[n], 2);
                                return Math.sqrt(r)
                            }

                            function normalize(t) {
                                return div(t, length(t))
                            }

                            function rgbToHsl(t) {
                                var e, n, i = t[0],
                                    r = t[1],
                                    a = t[2],
                                    s = Math.max(i, r, a),
                                    o = Math.min(i, r, a),
                                    l = (s + o) / 2;
                                if (s == o) e = n = 0;
                                else {
                                    var h = s - o;
                                    switch (n = l > .5 ? h / (2 - s - o) : h / (s + o), s) {
                                        case i:
                                            e = (r - a) / h + (r < a ? 6 : 0);
                                            break;
                                        case r:
                                            e = (a - i) / h + 2;
                                            break;
                                        case a:
                                            e = (i - r) / h + 4
                                    }
                                    e /= 6
                                }
                                return [e, n, l, t[3]]
                            }

                            function hue2rgb(t, e, n) {
                                return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t
                            }

                            function hslToRgb(t) {
                                var e, n, i, r = t[0],
                                    a = t[1],
                                    s = t[2];
                                if (0 === a) e = n = i = s;
                                else {
                                    var o = s < .5 ? s * (1 + a) : s + a - s * a,
                                        l = 2 * s - o;
                                    e = hue2rgb(l, o, r + 1 / 3), n = hue2rgb(l, o, r), i = hue2rgb(l, o, r - 1 / 3)
                                }
                                return [e, n, i, t[3]]
                            }

                            function linear(t, e, n, i, r) {
                                if (void 0 !== i && void 0 !== r || (i = e, r = n, e = 0, n = 1), n < e) {
                                    var a = n;
                                    n = e, e = a
                                }
                                if (t <= e) return i;
                                if (t >= n) return r;
                                var s = n === e ? 0 : (t - e) / (n - e);
                                if (!i.length) return i + (r - i) * s;
                                var o, l = i.length,
                                    h = createTypedArray("float32", l);
                                for (o = 0; o < l; o += 1) h[o] = i[o] + (r[o] - i[o]) * s;
                                return h
                            }

                            function random(t, e) {
                                if (void 0 === e && (void 0 === t ? (t = 0, e = 1) : (e = t, t = void 0)), e.length) {
                                    var n, i = e.length;
                                    t || (t = createTypedArray("float32", i));
                                    var r = createTypedArray("float32", i),
                                        a = BMMath.random();
                                    for (n = 0; n < i; n += 1) r[n] = t[n] + a * (e[n] - t[n]);
                                    return r
                                }
                                return void 0 === t && (t = 0), t + BMMath.random() * (e - t)
                            }

                            function createPath(t, e, n, i) {
                                var r, a = t.length,
                                    s = shape_pool.newElement();
                                s.setPathData(!!i, a);
                                var o, l, h = [0, 0];
                                for (r = 0; r < a; r += 1) o = e && e[r] ? e[r] : h, l = n && n[r] ? n[r] : h, s.setTripleAt(t[r][0], t[r][1], l[0] + t[r][0], l[1] + t[r][1], o[0] + t[r][0], o[1] + t[r][1], r, !0);
                                return s
                            }

                            function initiateExpression(elem, data, property) {
                                var val = data.x,
                                    needsVelocity = /velocity(?![\w\d])/.test(val),
                                    _needsRandom = -1 !== val.indexOf("random"),
                                    elemType = elem.data.ty,
                                    transform, $bm_transform, content, effect, thisProperty = property;
                                thisProperty.valueAtTime = thisProperty.getValueAtTime, Object.defineProperty(thisProperty, "value", {
                                    get: function() {
                                        return thisProperty.v
                                    }
                                }), elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate, elem.comp.displayStartTime = 0;
                                var inPoint = elem.data.ip / elem.comp.globalData.frameRate,
                                    outPoint = elem.data.op / elem.comp.globalData.frameRate,
                                    width = elem.data.sw ? elem.data.sw : 0,
                                    height = elem.data.sh ? elem.data.sh : 0,
                                    name = elem.data.nm,
                                    loopIn, loop_in, loopOut, loop_out, smooth, toWorld, fromWorld, fromComp, toComp, fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer, thisComp, mask, valueAtTime, velocityAtTime, __expression_functions = [],
                                    scoped_bm_rt;
                                if (data.xf) {
                                    var i, len = data.xf.length;
                                    for (i = 0; i < len; i += 1) __expression_functions[i] = eval("(function(){ return " + data.xf[i] + "}())")
                                }
                                var expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0],
                                    numKeys = property.kf ? data.k.length : 0,
                                    active = !this.data || !0 !== this.data.hd,
                                    wiggle = function(t, e) {
                                        var n, i, r = this.pv.length ? this.pv.length : 1,
                                            a = createTypedArray("float32", r);
                                        var s = Math.floor(5 * time);
                                        for (n = 0, i = 0; n < s;) {
                                            for (i = 0; i < r; i += 1) a[i] += -e + 2 * e * BMMath.random();
                                            n += 1
                                        }
                                        var o = 5 * time,
                                            l = o - Math.floor(o),
                                            h = createTypedArray("float32", r);
                                        if (r > 1) {
                                            for (i = 0; i < r; i += 1) h[i] = this.pv[i] + a[i] + (-e + 2 * e * BMMath.random()) * l;
                                            return h
                                        }
                                        return this.pv + a[0] + (-e + 2 * e * BMMath.random()) * l
                                    }.bind(this);

                                function loopInDuration(t, e) {
                                    return loopIn(t, e, !0)
                                }

                                function loopOutDuration(t, e) {
                                    return loopOut(t, e, !0)
                                }
                                thisProperty.loopIn && (loopIn = thisProperty.loopIn.bind(thisProperty), loop_in = loopIn), thisProperty.loopOut && (loopOut = thisProperty.loopOut.bind(thisProperty), loop_out = loopOut), thisProperty.smooth && (smooth = thisProperty.smooth.bind(thisProperty)), this.getValueAtTime && (valueAtTime = this.getValueAtTime.bind(this)), this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this));
                                var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface),
                                    time, velocity, value, text, textIndex, textTotal, selectorValue;

                                function lookAt(t, e) {
                                    var n = [e[0] - t[0], e[1] - t[1], e[2] - t[2]],
                                        i = Math.atan2(n[0], Math.sqrt(n[1] * n[1] + n[2] * n[2])) / degToRads;
                                    return [-Math.atan2(n[1], n[2]) / degToRads, i, 0]
                                }

                                function easeOut(t, e, n, i, r) {
                                    return applyEase(easeOutBez, t, e, n, i, r)
                                }

                                function easeIn(t, e, n, i, r) {
                                    return applyEase(easeInBez, t, e, n, i, r)
                                }

                                function ease(t, e, n, i, r) {
                                    return applyEase(easeInOutBez, t, e, n, i, r)
                                }

                                function applyEase(t, e, n, i, r, a) {
                                    void 0 === r ? (r = n, a = i) : e = (e - n) / (i - n);
                                    var s = t(e = e > 1 ? 1 : e < 0 ? 0 : e);
                                    if ($bm_isInstanceOfArray(r)) {
                                        var o, l = r.length,
                                            h = createTypedArray("float32", l);
                                        for (o = 0; o < l; o += 1) h[o] = (a[o] - r[o]) * s + r[o];
                                        return h
                                    }
                                    return (a - r) * s + r
                                }

                                function nearestKey(t) {
                                    var e, n, i, r = data.k.length;
                                    if (data.k.length && "number" != typeof data.k[0])
                                        if (n = -1, (t *= elem.comp.globalData.frameRate) < data.k[0].t) n = 1, i = data.k[0].t;
                                        else {
                                            for (e = 0; e < r - 1; e += 1) {
                                                if (t === data.k[e].t) {
                                                    n = e + 1, i = data.k[e].t;
                                                    break
                                                }
                                                if (t > data.k[e].t && t < data.k[e + 1].t) {
                                                    t - data.k[e].t > data.k[e + 1].t - t ? (n = e + 2, i = data.k[e + 1].t) : (n = e + 1, i = data.k[e].t);
                                                    break
                                                }
                                            } - 1 === n && (n = e + 1, i = data.k[e].t)
                                        }
                                    else n = 0, i = 0;
                                    var a = {};
                                    return a.index = n, a.time = i / elem.comp.globalData.frameRate, a
                                }

                                function key(t) {
                                    var e, n, i;
                                    if (!data.k.length || "number" == typeof data.k[0]) throw new Error("The property has no keyframe at index " + t);
                                    t -= 1, e = {
                                        time: data.k[t].t / elem.comp.globalData.frameRate,
                                        value: []
                                    };
                                    var r = data.k[t].hasOwnProperty("s") ? data.k[t].s : data.k[t - 1].e;
                                    for (i = r.length, n = 0; n < i; n += 1) e[n] = r[n], e.value[n] = r[n];
                                    return e
                                }

                                function framesToTime(t, e) {
                                    return e || (e = elem.comp.globalData.frameRate), t / e
                                }

                                function timeToFrames(t, e) {
                                    return t || 0 === t || (t = time), e || (e = elem.comp.globalData.frameRate), t * e
                                }

                                function seedRandom(t) {
                                    BMMath.seedrandom(randSeed + t)
                                }

                                function sourceRectAtTime() {
                                    return elem.sourceRectAtTime()
                                }

                                function substring(t, e) {
                                    return "string" == typeof value ? void 0 === e ? value.substring(t) : value.substring(t, e) : ""
                                }

                                function substr(t, e) {
                                    return "string" == typeof value ? void 0 === e ? value.substr(t) : value.substr(t, e) : ""
                                }

                                function posterizeTime(t) {
                                    time = 0 === t ? 0 : Math.floor(time * t) / t, value = valueAtTime(time)
                                }
                                var index = elem.data.ind,
                                    hasParent = !(!elem.hierarchy || !elem.hierarchy.length),
                                    parent, randSeed = Math.floor(1e6 * Math.random()),
                                    globalData = elem.globalData;

                                function executeExpression(t) {
                                    return value = t, _needsRandom && seedRandom(randSeed), this.frameExpressionId === elem.globalData.frameId && "textSelector" !== this.propType ? value : ("textSelector" === this.propType && (textIndex = this.textIndex, textTotal = this.textTotal, selectorValue = this.selectorValue), thisLayer || (text = elem.layerInterface.text, thisLayer = elem.layerInterface, thisComp = elem.comp.compInterface, toWorld = thisLayer.toWorld.bind(thisLayer), fromWorld = thisLayer.fromWorld.bind(thisLayer), fromComp = thisLayer.fromComp.bind(thisLayer), toComp = thisLayer.toComp.bind(thisLayer), mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null, fromCompToSurface = fromComp), transform || (transform = elem.layerInterface("ADBE Transform Group"), $bm_transform = transform, transform && (anchorPoint = transform.anchorPoint)), 4 !== elemType || content || (content = thisLayer("ADBE Root Vectors Group")), effect || (effect = thisLayer(4)), (hasParent = !(!elem.hierarchy || !elem.hierarchy.length)) && !parent && (parent = elem.hierarchy[0].layerInterface), time = this.comp.renderedFrame / this.comp.globalData.frameRate, needsVelocity && (velocity = velocityAtTime(time)), expression_function(), this.frameExpressionId = elem.globalData.frameId, "shape" === scoped_bm_rt.propType && (scoped_bm_rt = scoped_bm_rt.v), scoped_bm_rt)
                                }
                                return executeExpression
                            }
                            return ob.initiateExpression = initiateExpression, ob
                        }(),
                        expressionHelpers = {
                            searchExpressions: function(t, e, n) {
                                e.x && (n.k = !0, n.x = !0, n.initiateExpression = ExpressionManager.initiateExpression, n.effectsSequence.push(n.initiateExpression(t, e, n).bind(n)))
                            },
                            getSpeedAtTime: function(t) {
                                var e = this.getValueAtTime(t),
                                    n = this.getValueAtTime(t + -.01),
                                    i = 0;
                                if (e.length) {
                                    var r;
                                    for (r = 0; r < e.length; r += 1) i += Math.pow(n[r] - e[r], 2);
                                    i = 100 * Math.sqrt(i)
                                } else i = 0;
                                return i
                            },
                            getVelocityAtTime: function(t) {
                                if (void 0 !== this.vel) return this.vel;
                                var e, n, i = this.getValueAtTime(t),
                                    r = this.getValueAtTime(t + -.001);
                                if (i.length)
                                    for (e = createTypedArray("float32", i.length), n = 0; n < i.length; n += 1) e[n] = (r[n] - i[n]) / -.001;
                                else e = (r - i) / -.001;
                                return e
                            },
                            getValueAtTime: function(t) {
                                return t *= this.elem.globalData.frameRate, (t -= this.offsetTime) !== this._cachingAtTime.lastFrame && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < t ? this._cachingAtTime.lastIndex : 0, this._cachingAtTime.value = this.interpolateValue(t, this._cachingAtTime), this._cachingAtTime.lastFrame = t), this._cachingAtTime.value
                            },
                            getStaticValueAtTime: function() {
                                return this.pv
                            },
                            setGroupProperty: function(t) {
                                this.propertyGroup = t
                            }
                        };
                    ! function() {
                        function t(t, e, n) {
                            if (!this.k || !this.keyframes) return this.pv;
                            t = t ? t.toLowerCase() : "";
                            var i, r, a, s, o, l = this.comp.renderedFrame,
                                h = this.keyframes,
                                u = h[h.length - 1].t;
                            if (l <= u) return this.pv;
                            if (n ? r = u - (i = e ? Math.abs(u - elem.comp.globalData.frameRate * e) : Math.max(0, u - this.elem.data.ip)) : ((!e || e > h.length - 1) && (e = h.length - 1), i = u - (r = h[h.length - 1 - e].t)), "pingpong" === t) {
                                if (Math.floor((l - r) / i) % 2 != 0) return this.getValueAtTime((i - (l - r) % i + r) / this.comp.globalData.frameRate, 0)
                            } else {
                                if ("offset" === t) {
                                    var c = this.getValueAtTime(r / this.comp.globalData.frameRate, 0),
                                        p = this.getValueAtTime(u / this.comp.globalData.frameRate, 0),
                                        f = this.getValueAtTime(((l - r) % i + r) / this.comp.globalData.frameRate, 0),
                                        d = Math.floor((l - r) / i);
                                    if (this.pv.length) {
                                        for (s = (o = new Array(c.length)).length, a = 0; a < s; a += 1) o[a] = (p[a] - c[a]) * d + f[a];
                                        return o
                                    }
                                    return (p - c) * d + f
                                }
                                if ("continue" === t) {
                                    var m = this.getValueAtTime(u / this.comp.globalData.frameRate, 0),
                                        g = this.getValueAtTime((u - .001) / this.comp.globalData.frameRate, 0);
                                    if (this.pv.length) {
                                        for (s = (o = new Array(m.length)).length, a = 0; a < s; a += 1) o[a] = m[a] + (m[a] - g[a]) * ((l - u) / this.comp.globalData.frameRate) / 5e-4;
                                        return o
                                    }
                                    return m + (l - u) / .001 * (m - g)
                                }
                            }
                            return this.getValueAtTime(((l - r) % i + r) / this.comp.globalData.frameRate, 0)
                        }

                        function e(t, e, n) {
                            if (!this.k) return this.pv;
                            t = t ? t.toLowerCase() : "";
                            var i, r, a, s, o, l = this.comp.renderedFrame,
                                h = this.keyframes,
                                u = h[0].t;
                            if (l >= u) return this.pv;
                            if (n ? r = u + (i = e ? Math.abs(elem.comp.globalData.frameRate * e) : Math.max(0, this.elem.data.op - u)) : ((!e || e > h.length - 1) && (e = h.length - 1), i = (r = h[e].t) - u), "pingpong" === t) {
                                if (Math.floor((u - l) / i) % 2 == 0) return this.getValueAtTime(((u - l) % i + u) / this.comp.globalData.frameRate, 0)
                            } else {
                                if ("offset" === t) {
                                    var c = this.getValueAtTime(u / this.comp.globalData.frameRate, 0),
                                        p = this.getValueAtTime(r / this.comp.globalData.frameRate, 0),
                                        f = this.getValueAtTime((i - (u - l) % i + u) / this.comp.globalData.frameRate, 0),
                                        d = Math.floor((u - l) / i) + 1;
                                    if (this.pv.length) {
                                        for (s = (o = new Array(c.length)).length, a = 0; a < s; a += 1) o[a] = f[a] - (p[a] - c[a]) * d;
                                        return o
                                    }
                                    return f - (p - c) * d
                                }
                                if ("continue" === t) {
                                    var m = this.getValueAtTime(u / this.comp.globalData.frameRate, 0),
                                        g = this.getValueAtTime((u + .001) / this.comp.globalData.frameRate, 0);
                                    if (this.pv.length) {
                                        for (s = (o = new Array(m.length)).length, a = 0; a < s; a += 1) o[a] = m[a] + (m[a] - g[a]) * (u - l) / .001;
                                        return o
                                    }
                                    return m + (m - g) * (u - l) / .001
                                }
                            }
                            return this.getValueAtTime((i - (u - l) % i + u) / this.comp.globalData.frameRate, 0)
                        }

                        function n(t, e) {
                            if (!this.k) return this.pv;
                            if (t = .5 * (t || .4), (e = Math.floor(e || 5)) <= 1) return this.pv;
                            var n, i, r = this.comp.renderedFrame / this.comp.globalData.frameRate,
                                a = r - t,
                                s = e > 1 ? (r + t - a) / (e - 1) : 1,
                                o = 0,
                                l = 0;
                            for (n = this.pv.length ? createTypedArray("float32", this.pv.length) : 0; o < e;) {
                                if (i = this.getValueAtTime(a + o * s), this.pv.length)
                                    for (l = 0; l < this.pv.length; l += 1) n[l] += i[l];
                                else n += i;
                                o += 1
                            }
                            if (this.pv.length)
                                for (l = 0; l < this.pv.length; l += 1) n[l] /= e;
                            else n /= e;
                            return n
                        }

                        function i(t) {
                            this._transformCachingAtTime || (this._transformCachingAtTime = {
                                v: new Matrix
                            });
                            var e = this._transformCachingAtTime.v;
                            if (e.cloneFromProps(this.pre.props), this.appliedTransformations < 1) {
                                var n = this.a.getValueAtTime(t);
                                e.translate(-n[0] * this.a.mult, -n[1] * this.a.mult, n[2] * this.a.mult)
                            }
                            if (this.appliedTransformations < 2) {
                                var i = this.s.getValueAtTime(t);
                                e.scale(i[0] * this.s.mult, i[1] * this.s.mult, i[2] * this.s.mult)
                            }
                            if (this.sk && this.appliedTransformations < 3) {
                                var r = this.sk.getValueAtTime(t),
                                    a = this.sa.getValueAtTime(t);
                                e.skewFromAxis(-r * this.sk.mult, a * this.sa.mult)
                            }
                            if (this.r && this.appliedTransformations < 4) {
                                var s = this.r.getValueAtTime(t);
                                e.rotate(-s * this.r.mult)
                            } else if (!this.r && this.appliedTransformations < 4) {
                                var o = this.rz.getValueAtTime(t),
                                    l = this.ry.getValueAtTime(t),
                                    h = this.rx.getValueAtTime(t),
                                    u = this.or.getValueAtTime(t);
                                e.rotateZ(-o * this.rz.mult).rotateY(l * this.ry.mult).rotateX(h * this.rx.mult).rotateZ(-u[2] * this.or.mult).rotateY(u[1] * this.or.mult).rotateX(u[0] * this.or.mult)
                            }
                            if (this.data.p && this.data.p.s) {
                                var c = this.px.getValueAtTime(t),
                                    p = this.py.getValueAtTime(t);
                                if (this.data.p.z) {
                                    var f = this.pz.getValueAtTime(t);
                                    e.translate(c * this.px.mult, p * this.py.mult, -f * this.pz.mult)
                                } else e.translate(c * this.px.mult, p * this.py.mult, 0)
                            } else {
                                var d = this.p.getValueAtTime(t);
                                e.translate(d[0] * this.p.mult, d[1] * this.p.mult, -d[2] * this.p.mult)
                            }
                            return e
                        }

                        function r(t) {
                            return this.v.clone(new Matrix)
                        }
                        var a = TransformPropertyFactory.getTransformProperty;
                        TransformPropertyFactory.getTransformProperty = function(t, e, n) {
                            var s = a(t, e, n);
                            return s.dynamicProperties.length ? s.getValueAtTime = i.bind(s) : s.getValueAtTime = r.bind(s), s.setGroupProperty = expressionHelpers.setGroupProperty, s
                        };
                        var s = PropertyFactory.getProp;
                        PropertyFactory.getProp = function(i, r, a, o, l) {
                            var h = s(i, r, a, o, l);
                            h.kf ? h.getValueAtTime = expressionHelpers.getValueAtTime.bind(h) : h.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(h), h.setGroupProperty = expressionHelpers.setGroupProperty, h.loopOut = t, h.loopIn = e, h.smooth = n, h.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(h), h.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(h), h.numKeys = 1 === r.a ? r.k.length : 0, h.propertyIndex = r.ix;
                            var u = 0;
                            return 0 !== a && (u = createTypedArray("float32", 1 === r.a ? r.k[0].s.length : r.k.length)), h._cachingAtTime = {
                                lastFrame: initialDefaultFrame,
                                lastIndex: 0,
                                value: u
                            }, expressionHelpers.searchExpressions(i, r, h), h.k && l.addDynamicProperty(h), h
                        };
                        var o = ShapePropertyFactory.getConstructorFunction(),
                            l = ShapePropertyFactory.getKeyframedConstructorFunction();

                        function h() {}
                        h.prototype = {
                            vertices: function(t, e) {
                                this.k && this.getValue();
                                var n = this.v;
                                void 0 !== e && (n = this.getValueAtTime(e, 0));
                                var i, r = n._length,
                                    a = n[t],
                                    s = n.v,
                                    o = createSizedArray(r);
                                for (i = 0; i < r; i += 1) o[i] = "i" === t || "o" === t ? [a[i][0] - s[i][0], a[i][1] - s[i][1]] : [a[i][0], a[i][1]];
                                return o
                            },
                            points: function(t) {
                                return this.vertices("v", t)
                            },
                            inTangents: function(t) {
                                return this.vertices("i", t)
                            },
                            outTangents: function(t) {
                                return this.vertices("o", t)
                            },
                            isClosed: function() {
                                return this.v.c
                            },
                            pointOnPath: function(t, e) {
                                var n = this.v;
                                void 0 !== e && (n = this.getValueAtTime(e, 0)), this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(n));
                                for (var i, r = this._segmentsLength, a = r.lengths, s = r.totalLength * t, o = 0, l = a.length, h = 0; o < l;) {
                                    if (h + a[o].addedLength > s) {
                                        var u = o,
                                            c = n.c && o === l - 1 ? 0 : o + 1,
                                            p = (s - h) / a[o].addedLength;
                                        i = bez.getPointInSegment(n.v[u], n.v[c], n.o[u], n.i[c], p, a[o]);
                                        break
                                    }
                                    h += a[o].addedLength, o += 1
                                }
                                return i || (i = n.c ? [n.v[0][0], n.v[0][1]] : [n.v[n._length - 1][0], n.v[n._length - 1][1]]), i
                            },
                            vectorOnPath: function(t, e, n) {
                                t = 1 == t ? this.v.c ? 0 : .999 : t;
                                var i = this.pointOnPath(t, e),
                                    r = this.pointOnPath(t + .001, e),
                                    a = r[0] - i[0],
                                    s = r[1] - i[1],
                                    o = Math.sqrt(Math.pow(a, 2) + Math.pow(s, 2));
                                return 0 === o ? [0, 0] : "tangent" === n ? [a / o, s / o] : [-s / o, a / o]
                            },
                            tangentOnPath: function(t, e) {
                                return this.vectorOnPath(t, e, "tangent")
                            },
                            normalOnPath: function(t, e) {
                                return this.vectorOnPath(t, e, "normal")
                            },
                            setGroupProperty: expressionHelpers.setGroupProperty,
                            getValueAtTime: expressionHelpers.getStaticValueAtTime
                        }, extendPrototype([h], o), extendPrototype([h], l), l.prototype.getValueAtTime = function(t) {
                            return this._cachingAtTime || (this._cachingAtTime = {
                                shapeValue: shape_pool.clone(this.pv),
                                lastIndex: 0,
                                lastTime: initialDefaultFrame
                            }), t *= this.elem.globalData.frameRate, (t -= this.offsetTime) !== this._cachingAtTime.lastTime && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < t ? this._caching.lastIndex : 0, this._cachingAtTime.lastTime = t, this.interpolateShape(t, this._cachingAtTime.shapeValue, this._cachingAtTime)), this._cachingAtTime.shapeValue
                        }, l.prototype.initiateExpression = ExpressionManager.initiateExpression;
                        var u = ShapePropertyFactory.getShapeProp;
                        ShapePropertyFactory.getShapeProp = function(t, e, n, i, r) {
                            var a = u(t, e, n, i, r);
                            return a.propertyIndex = e.ix, a.lock = !1, 3 === n ? expressionHelpers.searchExpressions(t, e.pt, a) : 4 === n && expressionHelpers.searchExpressions(t, e.ks, a), a.k && t.addDynamicProperty(a), a
                        }
                    }(), TextProperty.prototype.getExpressionValue = function(t, e) {
                        var n = this.calculateExpression(e);
                        if (t.t !== n) {
                            var i = {};
                            return this.copyData(i, t), i.t = n.toString(), i.__complete = !1, i
                        }
                        return t
                    }, TextProperty.prototype.searchProperty = function() {
                        var t = this.searchKeyframes(),
                            e = this.searchExpressions();
                        return this.kf = t || e, this.kf
                    }, TextProperty.prototype.searchExpressions = function() {
                        if (this.data.d.x) return this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this), this.addEffect(this.getExpressionValue.bind(this)), !0
                    };
                    var ShapePathInterface = function(t, e, n) {
                            var i = e.sh;

                            function r(t) {
                                if ("Shape" === t || "shape" === t || "Path" === t || "path" === t || "ADBE Vector Shape" === t || 2 === t) return r.path
                            }
                            var a = propertyGroupFactory(r, n);
                            return i.setGroupProperty(PropertyInterface("Path", a)), Object.defineProperties(r, {
                                path: {
                                    get: function() {
                                        return i.k && i.getValue(), i
                                    }
                                },
                                shape: {
                                    get: function() {
                                        return i.k && i.getValue(), i
                                    }
                                },
                                _name: {
                                    value: t.nm
                                },
                                ix: {
                                    value: t.ix
                                },
                                propertyIndex: {
                                    value: t.ix
                                },
                                mn: {
                                    value: t.mn
                                },
                                propertyGroup: {
                                    value: n
                                }
                            }), r
                        },
                        propertyGroupFactory = function(t, e) {
                            return function(n) {
                                return (n = void 0 === n ? 1 : n) <= 0 ? t : e(n - 1)
                            }
                        },
                        PropertyInterface = function(t, e) {
                            var n = {
                                _name: t
                            };
                            return function(t) {
                                return (t = void 0 === t ? 1 : t) <= 0 ? n : e(--t)
                            }
                        },
                        ShapeExpressionInterface = function() {
                            function t(t, a, c) {
                                var p, f = [],
                                    d = t ? t.length : 0;
                                for (p = 0; p < d; p += 1) "gr" == t[p].ty ? f.push(e(t[p], a[p], c)) : "fl" == t[p].ty ? f.push(n(t[p], a[p], c)) : "st" == t[p].ty ? f.push(i(t[p], a[p], c)) : "tm" == t[p].ty ? f.push(r(t[p], a[p], c)) : "tr" == t[p].ty || ("el" == t[p].ty ? f.push(s(t[p], a[p], c)) : "sr" == t[p].ty ? f.push(o(t[p], a[p], c)) : "sh" == t[p].ty ? f.push(ShapePathInterface(t[p], a[p], c)) : "rc" == t[p].ty ? f.push(l(t[p], a[p], c)) : "rd" == t[p].ty ? f.push(h(t[p], a[p], c)) : "rp" == t[p].ty && f.push(u(t[p], a[p], c)));
                                return f
                            }

                            function e(e, n, i) {
                                var r = function(t) {
                                    switch (t) {
                                        case "ADBE Vectors Group":
                                        case "Contents":
                                        case 2:
                                            return r.content;
                                        default:
                                            return r.transform
                                    }
                                };
                                r.propertyGroup = propertyGroupFactory(r, i);
                                var s = function(e, n, i) {
                                        var r, s = function(t) {
                                            for (var e = 0, n = r.length; e < n;) {
                                                if (r[e]._name === t || r[e].mn === t || r[e].propertyIndex === t || r[e].ix === t || r[e].ind === t) return r[e];
                                                e += 1
                                            }
                                            if ("number" == typeof t) return r[t - 1]
                                        };
                                        s.propertyGroup = propertyGroupFactory(s, i), r = t(e.it, n.it, s.propertyGroup), s.numProperties = r.length;
                                        var o = a(e.it[e.it.length - 1], n.it[n.it.length - 1], s.propertyGroup);
                                        return s.transform = o, s.propertyIndex = e.cix, s._name = e.nm, s
                                    }(e, n, r.propertyGroup),
                                    o = a(e.it[e.it.length - 1], n.it[n.it.length - 1], r.propertyGroup);
                                return r.content = s, r.transform = o, Object.defineProperty(r, "_name", {
                                    get: function() {
                                        return e.nm
                                    }
                                }), r.numProperties = e.np, r.propertyIndex = e.ix, r.nm = e.nm, r.mn = e.mn, r
                            }

                            function n(t, e, n) {
                                function i(t) {
                                    return "Color" === t || "color" === t ? i.color : "Opacity" === t || "opacity" === t ? i.opacity : void 0
                                }
                                return Object.defineProperties(i, {
                                    color: {
                                        get: ExpressionPropertyInterface(e.c)
                                    },
                                    opacity: {
                                        get: ExpressionPropertyInterface(e.o)
                                    },
                                    _name: {
                                        value: t.nm
                                    },
                                    mn: {
                                        value: t.mn
                                    }
                                }), e.c.setGroupProperty(PropertyInterface("Color", n)), e.o.setGroupProperty(PropertyInterface("Opacity", n)), i
                            }

                            function i(t, e, n) {
                                var i = propertyGroupFactory(h, n),
                                    r = propertyGroupFactory(l, i);

                                function a(n) {
                                    Object.defineProperty(l, t.d[n].nm, {
                                        get: ExpressionPropertyInterface(e.d.dataProps[n].p)
                                    })
                                }
                                var s, o = t.d ? t.d.length : 0,
                                    l = {};
                                for (s = 0; s < o; s += 1) a(s), e.d.dataProps[s].p.setGroupProperty(r);

                                function h(t) {
                                    return "Color" === t || "color" === t ? h.color : "Opacity" === t || "opacity" === t ? h.opacity : "Stroke Width" === t || "stroke width" === t ? h.strokeWidth : void 0
                                }
                                return Object.defineProperties(h, {
                                    color: {
                                        get: ExpressionPropertyInterface(e.c)
                                    },
                                    opacity: {
                                        get: ExpressionPropertyInterface(e.o)
                                    },
                                    strokeWidth: {
                                        get: ExpressionPropertyInterface(e.w)
                                    },
                                    dash: {
                                        get: function() {
                                            return l
                                        }
                                    },
                                    _name: {
                                        value: t.nm
                                    },
                                    mn: {
                                        value: t.mn
                                    }
                                }), e.c.setGroupProperty(PropertyInterface("Color", i)), e.o.setGroupProperty(PropertyInterface("Opacity", i)), e.w.setGroupProperty(PropertyInterface("Stroke Width", i)), h
                            }

                            function r(t, e, n) {
                                function i(e) {
                                    return e === t.e.ix || "End" === e || "end" === e ? i.end : e === t.s.ix ? i.start : e === t.o.ix ? i.offset : void 0
                                }
                                var r = propertyGroupFactory(i, n);
                                return i.propertyIndex = t.ix, e.s.setGroupProperty(PropertyInterface("Start", r)), e.e.setGroupProperty(PropertyInterface("End", r)), e.o.setGroupProperty(PropertyInterface("Offset", r)), i.propertyIndex = t.ix, i.propertyGroup = n, Object.defineProperties(i, {
                                    start: {
                                        get: ExpressionPropertyInterface(e.s)
                                    },
                                    end: {
                                        get: ExpressionPropertyInterface(e.e)
                                    },
                                    offset: {
                                        get: ExpressionPropertyInterface(e.o)
                                    },
                                    _name: {
                                        value: t.nm
                                    }
                                }), i.mn = t.mn, i
                            }

                            function a(t, e, n) {
                                function i(e) {
                                    return t.a.ix === e || "Anchor Point" === e ? i.anchorPoint : t.o.ix === e || "Opacity" === e ? i.opacity : t.p.ix === e || "Position" === e ? i.position : t.r.ix === e || "Rotation" === e || "ADBE Vector Rotation" === e ? i.rotation : t.s.ix === e || "Scale" === e ? i.scale : t.sk && t.sk.ix === e || "Skew" === e ? i.skew : t.sa && t.sa.ix === e || "Skew Axis" === e ? i.skewAxis : void 0
                                }
                                var r = propertyGroupFactory(i, n);
                                return e.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", r)), e.transform.mProps.p.setGroupProperty(PropertyInterface("Position", r)), e.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", r)), e.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", r)), e.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", r)), e.transform.mProps.sk && (e.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", r)), e.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", r))), e.transform.op.setGroupProperty(PropertyInterface("Opacity", r)), Object.defineProperties(i, {
                                    opacity: {
                                        get: ExpressionPropertyInterface(e.transform.mProps.o)
                                    },
                                    position: {
                                        get: ExpressionPropertyInterface(e.transform.mProps.p)
                                    },
                                    anchorPoint: {
                                        get: ExpressionPropertyInterface(e.transform.mProps.a)
                                    },
                                    scale: {
                                        get: ExpressionPropertyInterface(e.transform.mProps.s)
                                    },
                                    rotation: {
                                        get: ExpressionPropertyInterface(e.transform.mProps.r)
                                    },
                                    skew: {
                                        get: ExpressionPropertyInterface(e.transform.mProps.sk)
                                    },
                                    skewAxis: {
                                        get: ExpressionPropertyInterface(e.transform.mProps.sa)
                                    },
                                    _name: {
                                        value: t.nm
                                    }
                                }), i.ty = "tr", i.mn = t.mn, i.propertyGroup = n, i
                            }

                            function s(t, e, n) {
                                function i(e) {
                                    return t.p.ix === e ? i.position : t.s.ix === e ? i.size : void 0
                                }
                                var r = propertyGroupFactory(i, n);
                                i.propertyIndex = t.ix;
                                var a = "tm" === e.sh.ty ? e.sh.prop : e.sh;
                                return a.s.setGroupProperty(PropertyInterface("Size", r)), a.p.setGroupProperty(PropertyInterface("Position", r)), Object.defineProperties(i, {
                                    size: {
                                        get: ExpressionPropertyInterface(a.s)
                                    },
                                    position: {
                                        get: ExpressionPropertyInterface(a.p)
                                    },
                                    _name: {
                                        value: t.nm
                                    }
                                }), i.mn = t.mn, i
                            }

                            function o(t, e, n) {
                                function i(e) {
                                    return t.p.ix === e ? i.position : t.r.ix === e ? i.rotation : t.pt.ix === e ? i.points : t.or.ix === e || "ADBE Vector Star Outer Radius" === e ? i.outerRadius : t.os.ix === e ? i.outerRoundness : !t.ir || t.ir.ix !== e && "ADBE Vector Star Inner Radius" !== e ? t.is && t.is.ix === e ? i.innerRoundness : void 0 : i.innerRadius
                                }
                                var r = propertyGroupFactory(i, n),
                                    a = "tm" === e.sh.ty ? e.sh.prop : e.sh;
                                return i.propertyIndex = t.ix, a.or.setGroupProperty(PropertyInterface("Outer Radius", r)), a.os.setGroupProperty(PropertyInterface("Outer Roundness", r)), a.pt.setGroupProperty(PropertyInterface("Points", r)), a.p.setGroupProperty(PropertyInterface("Position", r)), a.r.setGroupProperty(PropertyInterface("Rotation", r)), t.ir && (a.ir.setGroupProperty(PropertyInterface("Inner Radius", r)), a.is.setGroupProperty(PropertyInterface("Inner Roundness", r))), Object.defineProperties(i, {
                                    position: {
                                        get: ExpressionPropertyInterface(a.p)
                                    },
                                    rotation: {
                                        get: ExpressionPropertyInterface(a.r)
                                    },
                                    points: {
                                        get: ExpressionPropertyInterface(a.pt)
                                    },
                                    outerRadius: {
                                        get: ExpressionPropertyInterface(a.or)
                                    },
                                    outerRoundness: {
                                        get: ExpressionPropertyInterface(a.os)
                                    },
                                    innerRadius: {
                                        get: ExpressionPropertyInterface(a.ir)
                                    },
                                    innerRoundness: {
                                        get: ExpressionPropertyInterface(a.is)
                                    },
                                    _name: {
                                        value: t.nm
                                    }
                                }), i.mn = t.mn, i
                            }

                            function l(t, e, n) {
                                function i(e) {
                                    return t.p.ix === e ? i.position : t.r.ix === e ? i.roundness : t.s.ix === e || "Size" === e || "ADBE Vector Rect Size" === e ? i.size : void 0
                                }
                                var r = propertyGroupFactory(i, n),
                                    a = "tm" === e.sh.ty ? e.sh.prop : e.sh;
                                return i.propertyIndex = t.ix, a.p.setGroupProperty(PropertyInterface("Position", r)), a.s.setGroupProperty(PropertyInterface("Size", r)), a.r.setGroupProperty(PropertyInterface("Rotation", r)), Object.defineProperties(i, {
                                    position: {
                                        get: ExpressionPropertyInterface(a.p)
                                    },
                                    roundness: {
                                        get: ExpressionPropertyInterface(a.r)
                                    },
                                    size: {
                                        get: ExpressionPropertyInterface(a.s)
                                    },
                                    _name: {
                                        value: t.nm
                                    }
                                }), i.mn = t.mn, i
                            }

                            function h(t, e, n) {
                                function i(e) {
                                    if (t.r.ix === e || "Round Corners 1" === e) return i.radius
                                }
                                var r = propertyGroupFactory(i, n),
                                    a = e;
                                return i.propertyIndex = t.ix, a.rd.setGroupProperty(PropertyInterface("Radius", r)), Object.defineProperties(i, {
                                    radius: {
                                        get: ExpressionPropertyInterface(a.rd)
                                    },
                                    _name: {
                                        value: t.nm
                                    }
                                }), i.mn = t.mn, i
                            }

                            function u(t, e, n) {
                                function i(e) {
                                    return t.c.ix === e || "Copies" === e ? i.copies : t.o.ix === e || "Offset" === e ? i.offset : void 0
                                }
                                var r = propertyGroupFactory(i, n),
                                    a = e;
                                return i.propertyIndex = t.ix, a.c.setGroupProperty(PropertyInterface("Copies", r)), a.o.setGroupProperty(PropertyInterface("Offset", r)), Object.defineProperties(i, {
                                    copies: {
                                        get: ExpressionPropertyInterface(a.c)
                                    },
                                    offset: {
                                        get: ExpressionPropertyInterface(a.o)
                                    },
                                    _name: {
                                        value: t.nm
                                    }
                                }), i.mn = t.mn, i
                            }
                            return function(e, n, i) {
                                var r;

                                function a(t) {
                                    if ("number" == typeof t) return 0 === (t = void 0 === t ? 1 : t) ? i : r[t - 1];
                                    for (var e = 0, n = r.length; e < n;) {
                                        if (r[e]._name === t) return r[e];
                                        e += 1
                                    }
                                }
                                return a.propertyGroup = propertyGroupFactory(a, (function() {
                                    return i
                                })), r = t(e, n, a.propertyGroup), a.numProperties = r.length, a._name = "Contents", a
                            }
                        }(),
                        TextExpressionInterface = function(t) {
                            var e;

                            function n(t) {
                                switch (t) {
                                    case "ADBE Text Document":
                                        return n.sourceText
                                }
                            }
                            return Object.defineProperty(n, "sourceText", {
                                get: function() {
                                    t.textProperty.getValue();
                                    var n = t.textProperty.currentData.t;
                                    return void 0 !== n && (t.textProperty.currentData.t = void 0, (e = new String(n)).value = n || new String(n)), e
                                }
                            }), n
                        },
                        LayerExpressionInterface = function() {
                            function t(t) {
                                var e = new Matrix;
                                void 0 !== t ? this._elem.finalTransform.mProp.getValueAtTime(t).clone(e) : this._elem.finalTransform.mProp.applyToMatrix(e);
                                return e
                            }

                            function e(t, e) {
                                var n = this.getMatrix(e);
                                return n.props[12] = n.props[13] = n.props[14] = 0, this.applyPoint(n, t)
                            }

                            function n(t, e) {
                                var n = this.getMatrix(e);
                                return this.applyPoint(n, t)
                            }

                            function i(t, e) {
                                var n = this.getMatrix(e);
                                return n.props[12] = n.props[13] = n.props[14] = 0, this.invertPoint(n, t)
                            }

                            function r(t, e) {
                                var n = this.getMatrix(e);
                                return this.invertPoint(n, t)
                            }

                            function a(t, e) {
                                if (this._elem.hierarchy && this._elem.hierarchy.length) {
                                    var n, i = this._elem.hierarchy.length;
                                    for (n = 0; n < i; n += 1) this._elem.hierarchy[n].finalTransform.mProp.applyToMatrix(t)
                                }
                                return t.applyToPointArray(e[0], e[1], e[2] || 0)
                            }

                            function s(t, e) {
                                if (this._elem.hierarchy && this._elem.hierarchy.length) {
                                    var n, i = this._elem.hierarchy.length;
                                    for (n = 0; n < i; n += 1) this._elem.hierarchy[n].finalTransform.mProp.applyToMatrix(t)
                                }
                                return t.inversePoint(e)
                            }

                            function o(t) {
                                var e = new Matrix;
                                if (e.reset(), this._elem.finalTransform.mProp.applyToMatrix(e), this._elem.hierarchy && this._elem.hierarchy.length) {
                                    var n, i = this._elem.hierarchy.length;
                                    for (n = 0; n < i; n += 1) this._elem.hierarchy[n].finalTransform.mProp.applyToMatrix(e);
                                    return e.inversePoint(t)
                                }
                                return e.inversePoint(t)
                            }

                            function l() {
                                return [1, 1, 1, 1]
                            }
                            return function(h) {
                                var u;

                                function c(t) {
                                    switch (t) {
                                        case "ADBE Root Vectors Group":
                                        case "Contents":
                                        case 2:
                                            return c.shapeInterface;
                                        case 1:
                                        case 6:
                                        case "Transform":
                                        case "transform":
                                        case "ADBE Transform Group":
                                            return u;
                                        case 4:
                                        case "ADBE Effect Parade":
                                        case "effects":
                                        case "Effects":
                                            return c.effect;
                                        case "ADBE Text Properties":
                                            return c.textInterface
                                    }
                                }
                                c.getMatrix = t, c.invertPoint = s, c.applyPoint = a, c.toWorld = n, c.toWorldVec = e, c.fromWorld = r, c.fromWorldVec = i, c.toComp = n, c.fromComp = o, c.sampleImage = l, c.sourceRectAtTime = h.sourceRectAtTime.bind(h), c._elem = h;
                                var p = getDescriptor(u = TransformExpressionInterface(h.finalTransform.mProp), "anchorPoint");
                                return Object.defineProperties(c, {
                                    hasParent: {
                                        get: function() {
                                            return h.hierarchy.length
                                        }
                                    },
                                    parent: {
                                        get: function() {
                                            return h.hierarchy[0].layerInterface
                                        }
                                    },
                                    rotation: getDescriptor(u, "rotation"),
                                    scale: getDescriptor(u, "scale"),
                                    position: getDescriptor(u, "position"),
                                    opacity: getDescriptor(u, "opacity"),
                                    anchorPoint: p,
                                    anchor_point: p,
                                    transform: {
                                        get: function() {
                                            return u
                                        }
                                    },
                                    active: {
                                        get: function() {
                                            return h.isInRange
                                        }
                                    }
                                }), c.startTime = h.data.st, c.index = h.data.ind, c.source = h.data.refId, c.height = 0 === h.data.ty ? h.data.h : 100, c.width = 0 === h.data.ty ? h.data.w : 100, c.inPoint = h.data.ip / h.comp.globalData.frameRate, c.outPoint = h.data.op / h.comp.globalData.frameRate, c._name = h.data.nm, c.registerMaskInterface = function(t) {
                                    c.mask = new MaskManagerInterface(t, h)
                                }, c.registerEffectsInterface = function(t) {
                                    c.effect = t
                                }, c
                            }
                        }(),
                        CompExpressionInterface = function(t) {
                            function e(e) {
                                for (var n = 0, i = t.layers.length; n < i;) {
                                    if (t.layers[n].nm === e || t.layers[n].ind === e) return t.elements[n].layerInterface;
                                    n += 1
                                }
                                return null
                            }
                            return Object.defineProperty(e, "_name", {
                                value: t.data.nm
                            }), e.layer = e, e.pixelAspect = 1, e.height = t.data.h || t.globalData.compSize.h, e.width = t.data.w || t.globalData.compSize.w, e.pixelAspect = 1, e.frameDuration = 1 / t.globalData.frameRate, e.displayStartTime = 0, e.numLayers = t.layers.length, e
                        },
                        TransformExpressionInterface = function(t) {
                            function e(t) {
                                switch (t) {
                                    case "scale":
                                    case "Scale":
                                    case "ADBE Scale":
                                    case 6:
                                        return e.scale;
                                    case "rotation":
                                    case "Rotation":
                                    case "ADBE Rotation":
                                    case "ADBE Rotate Z":
                                    case 10:
                                        return e.rotation;
                                    case "ADBE Rotate X":
                                        return e.xRotation;
                                    case "ADBE Rotate Y":
                                        return e.yRotation;
                                    case "position":
                                    case "Position":
                                    case "ADBE Position":
                                    case 2:
                                        return e.position;
                                    case "ADBE Position_0":
                                        return e.xPosition;
                                    case "ADBE Position_1":
                                        return e.yPosition;
                                    case "ADBE Position_2":
                                        return e.zPosition;
                                    case "anchorPoint":
                                    case "AnchorPoint":
                                    case "Anchor Point":
                                    case "ADBE AnchorPoint":
                                    case 1:
                                        return e.anchorPoint;
                                    case "opacity":
                                    case "Opacity":
                                    case 11:
                                        return e.opacity
                                }
                            }
                            if (Object.defineProperty(e, "rotation", {
                                    get: ExpressionPropertyInterface(t.r || t.rz)
                                }), Object.defineProperty(e, "zRotation", {
                                    get: ExpressionPropertyInterface(t.rz || t.r)
                                }), Object.defineProperty(e, "xRotation", {
                                    get: ExpressionPropertyInterface(t.rx)
                                }), Object.defineProperty(e, "yRotation", {
                                    get: ExpressionPropertyInterface(t.ry)
                                }), Object.defineProperty(e, "scale", {
                                    get: ExpressionPropertyInterface(t.s)
                                }), t.p) var n = ExpressionPropertyInterface(t.p);
                            else {
                                var i, r = ExpressionPropertyInterface(t.px),
                                    a = ExpressionPropertyInterface(t.py);
                                t.pz && (i = ExpressionPropertyInterface(t.pz))
                            }
                            return Object.defineProperty(e, "position", {
                                get: function() {
                                    return t.p ? n() : [r(), a(), i ? i() : 0]
                                }
                            }), Object.defineProperty(e, "xPosition", {
                                get: ExpressionPropertyInterface(t.px)
                            }), Object.defineProperty(e, "yPosition", {
                                get: ExpressionPropertyInterface(t.py)
                            }), Object.defineProperty(e, "zPosition", {
                                get: ExpressionPropertyInterface(t.pz)
                            }), Object.defineProperty(e, "anchorPoint", {
                                get: ExpressionPropertyInterface(t.a)
                            }), Object.defineProperty(e, "opacity", {
                                get: ExpressionPropertyInterface(t.o)
                            }), Object.defineProperty(e, "skew", {
                                get: ExpressionPropertyInterface(t.sk)
                            }), Object.defineProperty(e, "skewAxis", {
                                get: ExpressionPropertyInterface(t.sa)
                            }), Object.defineProperty(e, "orientation", {
                                get: ExpressionPropertyInterface(t.or)
                            }), e
                        },
                        ProjectInterface = function() {
                            function t(t) {
                                this.compositions.push(t)
                            }
                            return function() {
                                function e(t) {
                                    for (var e = 0, n = this.compositions.length; e < n;) {
                                        if (this.compositions[e].data && this.compositions[e].data.nm === t) return this.compositions[e].prepareFrame && this.compositions[e].data.xt && this.compositions[e].prepareFrame(this.currentFrame), this.compositions[e].compInterface;
                                        e += 1
                                    }
                                }
                                return e.compositions = [], e.currentFrame = 0, e.registerComposition = t, e
                            }
                        }(),
                        EffectsExpressionInterface = function() {
                            function t(n, i, r, a) {
                                function s(t) {
                                    for (var e = n.ef, i = 0, r = e.length; i < r;) {
                                        if (t === e[i].nm || t === e[i].mn || t === e[i].ix) return 5 === e[i].ty ? h[i] : h[i]();
                                        i += 1
                                    }
                                    throw new Error
                                }
                                var o, l = propertyGroupFactory(s, r),
                                    h = [],
                                    u = n.ef.length;
                                for (o = 0; o < u; o += 1) 5 === n.ef[o].ty ? h.push(t(n.ef[o], i.effectElements[o], i.effectElements[o].propertyGroup, a)) : h.push(e(i.effectElements[o], n.ef[o].ty, a, l));
                                return "ADBE Color Control" === n.mn && Object.defineProperty(s, "color", {
                                    get: function() {
                                        return h[0]()
                                    }
                                }), Object.defineProperties(s, {
                                    numProperties: {
                                        get: function() {
                                            return n.np
                                        }
                                    },
                                    _name: {
                                        value: n.nm
                                    },
                                    propertyGroup: {
                                        value: l
                                    }
                                }), s.active = s.enabled = 0 !== n.en, s
                            }

                            function e(t, e, n, i) {
                                var r = ExpressionPropertyInterface(t.p);
                                return t.p.setGroupProperty && t.p.setGroupProperty(PropertyInterface("", i)),
                                    function() {
                                        return 10 === e ? n.comp.compInterface(t.p.v) : r()
                                    }
                            }
                            return {
                                createEffectsInterface: function(e, n) {
                                    if (e.effectsManager) {
                                        var i, r = [],
                                            a = e.data.ef,
                                            s = e.effectsManager.effectElements.length;
                                        for (i = 0; i < s; i += 1) r.push(t(a[i], e.effectsManager.effectElements[i], n, e));
                                        var o = e.data.ef || [],
                                            l = function(t) {
                                                for (i = 0, s = o.length; i < s;) {
                                                    if (t === o[i].nm || t === o[i].mn || t === o[i].ix) return r[i];
                                                    i += 1
                                                }
                                            };
                                        return Object.defineProperty(l, "numProperties", {
                                            get: function() {
                                                return o.length
                                            }
                                        }), l
                                    }
                                }
                            }
                        }(),
                        MaskManagerInterface = function() {
                            function t(t, e) {
                                this._mask = t, this._data = e
                            }
                            Object.defineProperty(t.prototype, "maskPath", {
                                get: function() {
                                    return this._mask.prop.k && this._mask.prop.getValue(), this._mask.prop
                                }
                            }), Object.defineProperty(t.prototype, "maskOpacity", {
                                get: function() {
                                    return this._mask.op.k && this._mask.op.getValue(), 100 * this._mask.op.v
                                }
                            });
                            return function(e, n) {
                                var i, r = createSizedArray(e.viewData.length),
                                    a = e.viewData.length;
                                for (i = 0; i < a; i += 1) r[i] = new t(e.viewData[i], e.masksProperties[i]);
                                return function(t) {
                                    for (i = 0; i < a;) {
                                        if (e.masksProperties[i].nm === t) return r[i];
                                        i += 1
                                    }
                                }
                            }
                        }(),
                        ExpressionPropertyInterface = function() {
                            var t = {
                                    pv: 0,
                                    v: 0,
                                    mult: 1
                                },
                                e = {
                                    pv: [0, 0, 0],
                                    v: [0, 0, 0],
                                    mult: 1
                                };

                            function n(t, e, n) {
                                Object.defineProperty(t, "velocity", {
                                    get: function() {
                                        return e.getVelocityAtTime(e.comp.currentFrame)
                                    }
                                }), t.numKeys = e.keyframes ? e.keyframes.length : 0, t.key = function(i) {
                                    if (t.numKeys) {
                                        var r = "";
                                        r = "s" in e.keyframes[i - 1] ? e.keyframes[i - 1].s : "e" in e.keyframes[i - 2] ? e.keyframes[i - 2].e : e.keyframes[i - 2].s;
                                        var a = "unidimensional" === n ? new Number(r) : Object.assign({}, r);
                                        return a.time = e.keyframes[i - 1].t / e.elem.comp.globalData.frameRate, a.value = "unidimensional" === n ? r[0] : r, a
                                    }
                                    return 0
                                }, t.valueAtTime = e.getValueAtTime, t.speedAtTime = e.getSpeedAtTime, t.velocityAtTime = e.getVelocityAtTime, t.propertyGroup = e.propertyGroup
                            }

                            function i() {
                                return t
                            }
                            return function(r) {
                                return r ? "unidimensional" === r.propType ? function(e) {
                                    e && "pv" in e || (e = t);
                                    var i = 1 / e.mult,
                                        r = e.pv * i,
                                        a = new Number(r);
                                    return a.value = r, n(a, e, "unidimensional"),
                                        function() {
                                            return e.k && e.getValue(), r = e.v * i, a.value !== r && ((a = new Number(r)).value = r, n(a, e, "unidimensional")), a
                                        }
                                }(r) : function(t) {
                                    t && "pv" in t || (t = e);
                                    var i = 1 / t.mult,
                                        r = t.data && t.data.l || t.pv.length,
                                        a = createTypedArray("float32", r),
                                        s = createTypedArray("float32", r);
                                    return a.value = s, n(a, t, "multidimensional"),
                                        function() {
                                            t.k && t.getValue();
                                            for (var e = 0; e < r; e += 1) a[e] = s[e] = t.v[e] * i;
                                            return a
                                        }
                                }(r) : i
                            }
                        }(),
                        TextExpressionSelectorProp, propertyGetTextProp;

                    function SliderEffect(t, e, n) {
                        this.p = PropertyFactory.getProp(e, t.v, 0, 0, n)
                    }

                    function AngleEffect(t, e, n) {
                        this.p = PropertyFactory.getProp(e, t.v, 0, 0, n)
                    }

                    function ColorEffect(t, e, n) {
                        this.p = PropertyFactory.getProp(e, t.v, 1, 0, n)
                    }

                    function PointEffect(t, e, n) {
                        this.p = PropertyFactory.getProp(e, t.v, 1, 0, n)
                    }

                    function LayerIndexEffect(t, e, n) {
                        this.p = PropertyFactory.getProp(e, t.v, 0, 0, n)
                    }

                    function MaskIndexEffect(t, e, n) {
                        this.p = PropertyFactory.getProp(e, t.v, 0, 0, n)
                    }

                    function CheckboxEffect(t, e, n) {
                        this.p = PropertyFactory.getProp(e, t.v, 0, 0, n)
                    }

                    function NoValueEffect() {
                        this.p = {}
                    }

                    function EffectsManager(t, e) {
                        var n = t.ef || [];
                        this.effectElements = [];
                        var i, r, a = n.length;
                        for (i = 0; i < a; i++) r = new GroupEffect(n[i], e), this.effectElements.push(r)
                    }

                    function GroupEffect(t, e) {
                        this.init(t, e)
                    }
                    TextExpressionSelectorProp = function() {
                        function t(t, e) {
                            return this.textIndex = t + 1, this.textTotal = e, this.v = this.getValue() * this.mult, this.v
                        }
                        return function(e, n) {
                            this.pv = 1, this.comp = e.comp, this.elem = e, this.mult = .01, this.propType = "textSelector", this.textTotal = n.totalChars, this.selectorValue = 100, this.lastValue = [1, 1, 1], this.k = !0, this.x = !0, this.getValue = ExpressionManager.initiateExpression.bind(this)(e, n, this), this.getMult = t, this.getVelocityAtTime = expressionHelpers.getVelocityAtTime, this.kf ? this.getValueAtTime = expressionHelpers.getValueAtTime.bind(this) : this.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(this), this.setGroupProperty = expressionHelpers.setGroupProperty
                        }
                    }(), propertyGetTextProp = TextSelectorProp.getTextSelectorProp, TextSelectorProp.getTextSelectorProp = function(t, e, n) {
                        return 1 === e.t ? new TextExpressionSelectorProp(t, e, n) : propertyGetTextProp(t, e, n)
                    }, extendPrototype([DynamicPropertyContainer], GroupEffect), GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties, GroupEffect.prototype.init = function(t, e) {
                        this.data = t, this.effectElements = [], this.initDynamicPropertyContainer(e);
                        var n, i, r = this.data.ef.length,
                            a = this.data.ef;
                        for (n = 0; n < r; n += 1) {
                            switch (i = null, a[n].ty) {
                                case 0:
                                    i = new SliderEffect(a[n], e, this);
                                    break;
                                case 1:
                                    i = new AngleEffect(a[n], e, this);
                                    break;
                                case 2:
                                    i = new ColorEffect(a[n], e, this);
                                    break;
                                case 3:
                                    i = new PointEffect(a[n], e, this);
                                    break;
                                case 4:
                                case 7:
                                    i = new CheckboxEffect(a[n], e, this);
                                    break;
                                case 10:
                                    i = new LayerIndexEffect(a[n], e, this);
                                    break;
                                case 11:
                                    i = new MaskIndexEffect(a[n], e, this);
                                    break;
                                case 5:
                                    i = new EffectsManager(a[n], e, this);
                                    break;
                                default:
                                    i = new NoValueEffect(a[n], e, this)
                            }
                            i && this.effectElements.push(i)
                        }
                    };
                    var lottie = {},
                        _isFrozen = !1;

                    function setLocationHref(t) {
                        locationHref = t
                    }

                    function searchAnimations() {
                        !0 === standalone ? animationManager.searchAnimations(animationData, standalone, renderer) : animationManager.searchAnimations()
                    }

                    function setSubframeRendering(t) {
                        subframeEnabled = t
                    }

                    function loadAnimation(t) {
                        return !0 === standalone && (t.animationData = JSON.parse(animationData)), animationManager.loadAnimation(t)
                    }

                    function setQuality(t) {
                        if ("string" == typeof t) switch (t) {
                            case "high":
                                defaultCurveSegments = 200;
                                break;
                            case "medium":
                                defaultCurveSegments = 50;
                                break;
                            case "low":
                                defaultCurveSegments = 10
                        } else !isNaN(t) && t > 1 && (defaultCurveSegments = t);
                        roundValues(!(defaultCurveSegments >= 50))
                    }

                    function inBrowser() {
                        return "undefined" != typeof navigator
                    }

                    function installPlugin(t, e) {
                        "expressions" === t && (expressionsPlugin = e)
                    }

                    function getFactory(t) {
                        switch (t) {
                            case "propertyFactory":
                                return PropertyFactory;
                            case "shapePropertyFactory":
                                return ShapePropertyFactory;
                            case "matrix":
                                return Matrix
                        }
                    }

                    function checkReady() {
                        "complete" === document.readyState && (clearInterval(readyStateCheckInterval), searchAnimations())
                    }

                    function getQueryVariable(t) {
                        for (var e = queryString.split("&"), n = 0; n < e.length; n++) {
                            var i = e[n].split("=");
                            if (decodeURIComponent(i[0]) == t) return decodeURIComponent(i[1])
                        }
                    }
                    lottie.play = animationManager.play, lottie.pause = animationManager.pause, lottie.setLocationHref = setLocationHref, lottie.togglePause = animationManager.togglePause, lottie.setSpeed = animationManager.setSpeed, lottie.setDirection = animationManager.setDirection, lottie.stop = animationManager.stop, lottie.searchAnimations = searchAnimations, lottie.registerAnimation = animationManager.registerAnimation, lottie.loadAnimation = loadAnimation, lottie.setSubframeRendering = setSubframeRendering, lottie.resize = animationManager.resize, lottie.goToAndStop = animationManager.goToAndStop, lottie.destroy = animationManager.destroy, lottie.setQuality = setQuality, lottie.inBrowser = inBrowser, lottie.installPlugin = installPlugin, lottie.freeze = animationManager.freeze, lottie.unfreeze = animationManager.unfreeze, lottie.setVolume = animationManager.setVolume, lottie.mute = animationManager.mute, lottie.unmute = animationManager.unmute, lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations, lottie.__getFactory = getFactory, lottie.version = "5.7.5";
                    var standalone = "__[STANDALONE]__",
                        animationData = "__[ANIMATIONDATA]__",
                        renderer = "";
                    if (standalone) {
                        var scripts = document.getElementsByTagName("script"),
                            index = scripts.length - 1,
                            myScript = scripts[index] || {
                                src: ""
                            },
                            queryString = myScript.src.replace(/^[^\?]+\??/, "");
                        renderer = getQueryVariable("renderer")
                    }
                    var readyStateCheckInterval = setInterval(checkReady, 100);
                    return lottie
                }))
            },
            820: () => {},
            835: (t, e, n) => {
                "use strict";
                var i = n(763);

                function r() {
                    var t = navigator.userAgent.toLowerCase(),
                        e = navigator.appVersion.toLowerCase(),
                        n = /windows phone|iemobile|wpdesktop/.test(t),
                        i = !n && /android.*mobile/.test(t),
                        r = !n && !i && /android/i.test(t),
                        a = i || r,
                        s = !n && /ip(hone|od|ad)/i.test(t) && !window.MSStream,
                        o = !n && /ipad/i.test(t) && s,
                        l = r || o,
                        h = i || s && !o || n,
                        u = h || l,
                        c = t.indexOf("firefox") > -1,
                        p = !!t.match(/version\/[\d\.]+.*safari/),
                        f = t.indexOf("opr") > -1,
                        d = !window.ActiveXObject && "ActiveXObject" in window,
                        m = e.indexOf("msie") > -1 || d || e.indexOf("edge") > -1,
                        g = t.indexOf("edge") > -1,
                        v = null !== window.chrome && void 0 !== window.chrome && "google inc." == navigator.vendor.toLowerCase() && !f && !g;
                    this.infos = {
                        isDroid: a,
                        isDroidPhone: i,
                        isDroidTablet: r,
                        isWindowsPhone: n,
                        isIos: s,
                        isIpad: o,
                        isDevice: u,
                        isEdge: g,
                        isIE: m,
                        isIE11: d,
                        isPhone: h,
                        isTablet: l,
                        isFirefox: c,
                        isSafari: p,
                        isOpera: f,
                        isChrome: v,
                        isDesktop: !h && !l
                    }, Object.keys(this.infos).forEach((function(t) {
                        Object.defineProperty(this, t, {
                            get: function() {
                                return this.infos[t]
                            }
                        })
                    }), this), Object.freeze(this)
                }
                t.exports = new r, r.prototype.addClasses = function(t) {
                    Object.keys(this.infos).forEach((function(e) {
                        this.infos[e] && function(t, e) {
                            t.addClass ? t.addClass(e) : t.classList ? t.classList.add(e) : t.className += " " + e
                        }(t, i(e))
                    }), this)
                }, r.prototype.getInfos = function() {
                    return t = this.infos, JSON.parse(JSON.stringify(t));
                    var t
                }
            }
        },
        __webpack_module_cache__ = {};

    function __webpack_require__(t) {
        if (__webpack_module_cache__[t]) return __webpack_module_cache__[t].exports;
        var e = __webpack_module_cache__[t] = {
            exports: {}
        };
        return __webpack_modules__[t].call(e.exports, e, e.exports, __webpack_require__), e.exports
    }
    __webpack_require__.n = t => {
        var e = t && t.__esModule ? () => t.default : () => t;
        return __webpack_require__.d(e, {
            a: e
        }), e
    }, __webpack_require__.d = (t, e) => {
        for (var n in e) __webpack_require__.o(e, n) && !__webpack_require__.o(t, n) && Object.defineProperty(t, n, {
            enumerable: !0,
            get: e[n]
        })
    }, __webpack_require__.g = function() {
        if ("object" == typeof globalThis) return globalThis;
        try {
            return this || new Function("return this")()
        } catch (t) {
            if ("object" == typeof window) return window
        }
    }(), __webpack_require__.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), __webpack_require__.r = t => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }, (() => {
        "use strict";
        var t = {};
        __webpack_require__.r(t), __webpack_require__.d(t, {
            HeroSlide: () => Zh,
            PlaneVideo: () => su
        });
        __webpack_require__(820), __webpack_require__(827), __webpack_require__(913);

        function e() {}
        e.prototype = {
            on: function(t, e, n) {
                var i = this.e || (this.e = {});
                return (i[t] || (i[t] = [])).push({
                    fn: e,
                    ctx: n
                }), this
            },
            once: function(t, e, n) {
                var i = this;

                function r() {
                    i.off(t, r), e.apply(n, arguments)
                }
                return r._ = e, this.on(t, r, n)
            },
            emit: function(t) {
                for (var e = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[t] || []).slice(), i = 0, r = n.length; i < r; i++) n[i].fn.apply(n[i].ctx, e);
                return this
            },
            off: function(t, e) {
                var n = this.e || (this.e = {}),
                    i = n[t],
                    r = [];
                if (i && e)
                    for (var a = 0, s = i.length; a < s; a++) i[a].fn !== e && i[a].fn._ !== e && r.push(i[a]);
                return r.length ? n[t] = r : delete n[t], this
            }
        };
        var n = e;
        n.TinyEmitter = e;
        var i = function(t) {
            this.wrap = document.querySelector("[data-router-wrapper]"), this.properties = t, this.Transition = t.transition ? new t.transition.class(this.wrap, t.transition.name) : null
        };
        i.prototype.setup = function() {
            this.onEnter && this.onEnter(), this.onEnterCompleted && this.onEnterCompleted()
        }, i.prototype.add = function() {
            this.wrap.insertAdjacentHTML("beforeend", this.properties.view.outerHTML)
        }, i.prototype.update = function() {
            document.title = this.properties.page.title
        }, i.prototype.show = function(t) {
            var e = this;
            return new Promise((function(n) {
                try {
                    function i(t) {
                        e.onEnterCompleted && e.onEnterCompleted(), n()
                    }
                    return e.update(), e.onEnter && e.onEnter(), Promise.resolve(e.Transition ? Promise.resolve(e.Transition.show(t)).then(i) : i())
                } catch (t) {
                    return Promise.reject(t)
                }
            }))
        }, i.prototype.hide = function(t) {
            var e = this;
            return new Promise((function(n) {
                try {
                    function i(t) {
                        e.onLeaveCompleted && e.onLeaveCompleted(), n()
                    }
                    return e.onLeave && e.onLeave(), Promise.resolve(e.Transition ? Promise.resolve(e.Transition.hide(t)).then(i) : i())
                } catch (t) {
                    return Promise.reject(t)
                }
            }))
        };
        var r = new window.DOMParser,
            a = function(t, e) {
                this.renderers = t, this.transitions = e
            };
        a.prototype.getOrigin = function(t) {
            var e = t.match(/(https?:\/\/[\w\-.]+)/);
            return e ? e[1].replace(/https?:\/\//, "") : null
        }, a.prototype.getPathname = function(t) {
            var e = t.match(/https?:\/\/.*?(\/[\w_\-./]+)/);
            return e ? e[1] : "/"
        }, a.prototype.getAnchor = function(t) {
            var e = t.match(/(#.*)$/);
            return e ? e[1] : null
        }, a.prototype.getParams = function(t) {
            var e = t.match(/\?([\w_\-.=&]+)/);
            if (!e) return null;
            for (var n = e[1].split("&"), i = {}, r = 0; r < n.length; r++) {
                var a = n[r].split("=");
                i[a[0]] = a[1]
            }
            return i
        }, a.prototype.getDOM = function(t) {
            return "string" == typeof t ? r.parseFromString(t, "text/html") : t
        }, a.prototype.getView = function(t) {
            return t.querySelector("[data-router-view]")
        }, a.prototype.getSlug = function(t) {
            return t.getAttribute("data-router-view")
        }, a.prototype.getRenderer = function(t) {
            if (!this.renderers) return Promise.resolve(i);
            if (t in this.renderers) {
                var e = this.renderers[t];
                return "function" != typeof e || i.isPrototypeOf(e) ? "function" == typeof e.then ? Promise.resolve(e).then((function(t) {
                    return t.default
                })) : Promise.resolve(e) : Promise.resolve(e()).then((function(t) {
                    return t.default
                }))
            }
            return Promise.resolve(i)
        }, a.prototype.getTransition = function(t) {
            return this.transitions ? t in this.transitions ? {
                class: this.transitions[t],
                name: t
            } : "default" in this.transitions ? {
                class: this.transitions.default,
                name: "default"
            } : null : null
        }, a.prototype.getProperties = function(t) {
            var e = this.getDOM(t),
                n = this.getView(e),
                i = this.getSlug(n);
            return {
                page: e,
                view: n,
                slug: i,
                renderer: this.getRenderer(i, this.renderers),
                transition: this.getTransition(i, this.transitions)
            }
        }, a.prototype.getLocation = function(t) {
            return {
                href: t,
                anchor: this.getAnchor(t),
                origin: this.getOrigin(t),
                params: this.getParams(t),
                pathname: this.getPathname(t)
            }
        };
        var s = function(t) {
                function e(e) {
                    var n = this;
                    void 0 === e && (e = {});
                    var i = e.renderers,
                        r = e.transitions;
                    t.call(this), this.Helpers = new a(i, r), this.Transitions = r, this.Contextual = !1, this.location = this.Helpers.getLocation(window.location.href), this.properties = this.Helpers.getProperties(document.cloneNode(!0)), this.popping = !1, this.running = !1, this.trigger = null, this.cache = new Map, this.cache.set(this.location.href, this.properties), this.properties.renderer.then((function(t) {
                        n.From = new t(n.properties), n.From.setup()
                    })), this._navigate = this.navigate.bind(this), window.addEventListener("popstate", this.popState.bind(this)), this.links = document.querySelectorAll("a:not([target]):not([data-router-disabled])"), this.attach(this.links)
                }
                return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.attach = function(t) {
                    for (var e = 0, n = t; e < n.length; e += 1) n[e].addEventListener("click", this._navigate)
                }, e.prototype.detach = function(t) {
                    for (var e = 0, n = t; e < n.length; e += 1) n[e].removeEventListener("click", this._navigate)
                }, e.prototype.navigate = function(t) {
                    if (!t.metaKey && !t.ctrlKey) {
                        t.preventDefault();
                        var e = !!t.currentTarget.hasAttribute("data-transition") && t.currentTarget.dataset.transition;
                        this.redirect(t.currentTarget.href, e, t.currentTarget)
                    }
                }, e.prototype.redirect = function(t, e, n) {
                    if (void 0 === e && (e = !1), void 0 === n && (n = "script"), this.trigger = n, !this.running && t !== this.location.href) {
                        var i = this.Helpers.getLocation(t);
                        this.Contextual = !1, e && (this.Contextual = this.Transitions.contextual[e].prototype, this.Contextual.name = e), i.origin !== this.location.origin || i.anchor && i.pathname === this.location.pathname ? window.location.href = t : (this.location = i, this.beforeFetch())
                    }
                }, e.prototype.popState = function() {
                    this.trigger = "popstate", this.Contextual = !1;
                    var t = this.Helpers.getLocation(window.location.href);
                    this.location.pathname !== t.pathname || !this.location.anchor && !t.anchor ? (this.popping = !0, this.location = t, this.beforeFetch()) : this.location = t
                }, e.prototype.pushState = function() {
                    this.popping || window.history.pushState(this.location, "", this.location.href)
                }, e.prototype.fetch = function() {
                    try {
                        var t = this;
                        return Promise.resolve(fetch(t.location.href, {
                            mode: "same-origin",
                            method: "GET",
                            headers: {
                                "X-Requested-With": "Highway"
                            },
                            credentials: "same-origin"
                        })).then((function(e) {
                            if (e.status >= 200 && e.status < 300) return e.text();
                            window.location.href = t.location.href
                        }))
                    } catch (t) {
                        return Promise.reject(t)
                    }
                }, e.prototype.beforeFetch = function() {
                    try {
                        var t = this;

                        function e() {
                            t.afterFetch()
                        }
                        t.pushState(), t.running = !0, t.emit("NAVIGATE_OUT", {
                            from: {
                                page: t.From.properties.page,
                                view: t.From.properties.view
                            },
                            trigger: t.trigger,
                            location: t.location
                        });
                        var n = {
                                trigger: t.trigger,
                                contextual: t.Contextual
                            },
                            i = t.cache.has(t.location.href) ? Promise.resolve(t.From.hide(n)).then((function() {
                                t.properties = t.cache.get(t.location.href)
                            })) : Promise.resolve(Promise.all([t.fetch(), t.From.hide(n)])).then((function(e) {
                                t.properties = t.Helpers.getProperties(e[0]), t.cache.set(t.location.href, t.properties)
                            }));
                        return Promise.resolve(i && i.then ? i.then(e) : e())
                    } catch (t) {
                        return Promise.reject(t)
                    }
                }, e.prototype.afterFetch = function() {
                    try {
                        var t = this;
                        return Promise.resolve(t.properties.renderer).then((function(e) {
                            return t.To = new e(t.properties), t.To.add(), t.emit("NAVIGATE_IN", {
                                to: {
                                    page: t.To.properties.page,
                                    view: t.To.wrap.lastElementChild
                                },
                                trigger: t.trigger,
                                location: t.location
                            }), Promise.resolve(t.To.show({
                                trigger: t.trigger,
                                contextual: t.Contextual
                            })).then((function() {
                                t.popping = !1, t.running = !1, t.detach(t.links), t.links = document.querySelectorAll("a:not([target]):not([data-router-disabled])"), t.attach(t.links), t.emit("NAVIGATE_END", {
                                    to: {
                                        page: t.To.properties.page,
                                        view: t.To.wrap.lastElementChild
                                    },
                                    from: {
                                        page: t.From.properties.page,
                                        view: t.From.properties.view
                                    },
                                    trigger: t.trigger,
                                    location: t.location
                                }), t.From = t.To, t.trigger = null
                            }))
                        }))
                    } catch (t) {
                        return Promise.reject(t)
                    }
                }, e
            }(n),
            o = function(t, e) {
                this.wrap = t, this.name = e
            };
        o.prototype.show = function(t) {
            var e = this,
                n = t.trigger,
                i = t.contextual,
                r = this.wrap.lastElementChild,
                a = this.wrap.firstElementChild;
            return new Promise((function(t) {
                i ? (r.setAttribute("data-transition-in", i.name), r.removeAttribute("data-transition-out", i.name), i.in && i.in({
                    to: r,
                    from: a,
                    trigger: n,
                    done: t
                })) : (r.setAttribute("data-transition-in", e.name), r.removeAttribute("data-transition-out", e.name), e.in && e.in({
                    to: r,
                    from: a,
                    trigger: n,
                    done: t
                }))
            }))
        }, o.prototype.hide = function(t) {
            var e = this,
                n = t.trigger,
                i = t.contextual,
                r = this.wrap.firstElementChild;
            return new Promise((function(t) {
                i ? (r.setAttribute("data-transition-out", i.name), r.removeAttribute("data-transition-in", i.name), i.out && i.out({
                    from: r,
                    trigger: n,
                    done: t
                })) : (r.setAttribute("data-transition-out", e.name), r.removeAttribute("data-transition-in", e.name), e.out && e.out({
                    from: r,
                    trigger: n,
                    done: t
                }))
            }))
        }, console.log("Highway v2.2.0");
        const l = {
            Core: s,
            Helpers: a,
            Renderer: i,
            Transition: o
        };
        var h = __webpack_require__(835),
            u = __webpack_require__.n(h);

        function c(t, e) {
            var n = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
                var i = Object.getOwnPropertySymbols(t);
                e && (i = i.filter((function(e) {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                }))), n.push.apply(n, i)
            }
            return n
        }

        function p(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }
        const f = {
            dom: {
                doc: document.documentElement,
                body: document.body,
                scroll: document.querySelector("[data-router-wrapper]"),
                gl: document.querySelector(".js-gl"),
                lastClicked: null
            },
            bounds: {
                ww: window.innerWidth,
                wh: window.innerHeight,
                vh: 0,
                scroll: 0,
                hero: {
                    w: 0,
                    h: 0
                }
            },
            flags: function(t) {
                for (var e = 1; e < arguments.length; e++) {
                    var n = null != arguments[e] ? arguments[e] : {};
                    e % 2 ? c(Object(n), !0).forEach((function(e) {
                        p(t, e, n[e])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : c(Object(n)).forEach((function(e) {
                        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                    }))
                }
                return t
            }({
                locked: !0,
                resize: !1,
                dragging: !1,
                loaded: !1,
                small: window.matchMedia("(max-width: 639px)").matches,
                hover: window.matchMedia("(hover: hover)").matches,
                windows: -1 !== ["Win32", "Win64", "Windows", "WinCE"].indexOf(window.navigator.platform)
            }, u().getInfos()),
            addClasses: function() {
                u().addClasses(this.dom.body), this.flags.windows && this.dom.body.classList.add("is-windows")
            }
        };
        var d = function(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : document;
                return e.querySelector(t)
            },
            m = function(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : document;
                return e.querySelectorAll(t)
            };

        function g() {
            if (!(this instanceof g)) return new g;
            this.size = 0, this.uid = 0, this.selectors = [], this.selectorObjects = {}, this.indexes = Object.create(this.indexes), this.activeIndexes = []
        }
        var v = window.document.documentElement,
            y = v.matches || v.webkitMatchesSelector || v.mozMatchesSelector || v.oMatchesSelector || v.msMatchesSelector;
        g.prototype.matchesSelector = function(t, e) {
            return y.call(t, e)
        }, g.prototype.querySelectorAll = function(t, e) {
            return e.querySelectorAll(t)
        }, g.prototype.indexes = [];
        var _ = /^#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
        g.prototype.indexes.push({
            name: "ID",
            selector: function(t) {
                var e;
                if (e = t.match(_)) return e[0].slice(1)
            },
            element: function(t) {
                if (t.id) return [t.id]
            }
        });
        var x = /^\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
        g.prototype.indexes.push({
            name: "CLASS",
            selector: function(t) {
                var e;
                if (e = t.match(x)) return e[0].slice(1)
            },
            element: function(t) {
                var e = t.className;
                if (e) {
                    if ("string" == typeof e) return e.split(/\s/);
                    if ("object" == typeof e && "baseVal" in e) return e.baseVal.split(/\s/)
                }
            }
        });
        var b, E = /^((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
        g.prototype.indexes.push({
            name: "TAG",
            selector: function(t) {
                var e;
                if (e = t.match(E)) return e[0].toUpperCase()
            },
            element: function(t) {
                return [t.nodeName.toUpperCase()]
            }
        }), g.prototype.indexes.default = {
            name: "UNIVERSAL",
            selector: function() {
                return !0
            },
            element: function() {
                return [!0]
            }
        }, b = "function" == typeof window.Map ? window.Map : function() {
            function t() {
                this.map = {}
            }
            return t.prototype.get = function(t) {
                return this.map[t + " "]
            }, t.prototype.set = function(t, e) {
                this.map[t + " "] = e
            }, t
        }();
        var w = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g;

        function D(t, e) {
            var n, i, r, a, s, o, l = (t = t.slice(0).concat(t.default)).length,
                h = e,
                u = [];
            do {
                if (w.exec(""), (r = w.exec(h)) && (h = r[3], r[2] || !h))
                    for (n = 0; n < l; n++)
                        if (s = (o = t[n]).selector(r[1])) {
                            for (i = u.length, a = !1; i--;)
                                if (u[i].index === o && u[i].key === s) {
                                    a = !0;
                                    break
                                }
                            a || u.push({
                                index: o,
                                key: s
                            });
                            break
                        }
            } while (r);
            return u
        }

        function S(t, e) {
            var n, i, r;
            for (n = 0, i = t.length; n < i; n++)
                if (r = t[n], e.isPrototypeOf(r)) return r
        }

        function M(t, e) {
            return t.id - e.id
        }
        g.prototype.logDefaultIndexUsed = function() {}, g.prototype.add = function(t, e) {
            var n, i, r, a, s, o, l, h, u = this.activeIndexes,
                c = this.selectors,
                p = this.selectorObjects;
            if ("string" == typeof t) {
                for (p[(n = {
                        id: this.uid++,
                        selector: t,
                        data: e
                    }).id] = n, l = D(this.indexes, t), i = 0; i < l.length; i++) a = (h = l[i]).key, (s = S(u, r = h.index)) || ((s = Object.create(r)).map = new b, u.push(s)), r === this.indexes.default && this.logDefaultIndexUsed(n), (o = s.map.get(a)) || (o = [], s.map.set(a, o)), o.push(n);
                this.size++, c.push(t)
            }
        }, g.prototype.remove = function(t, e) {
            if ("string" == typeof t) {
                var n, i, r, a, s, o, l, h, u = this.activeIndexes,
                    c = this.selectors = [],
                    p = this.selectorObjects,
                    f = {},
                    d = 1 === arguments.length;
                for (n = D(this.indexes, t), r = 0; r < n.length; r++)
                    for (i = n[r], a = u.length; a--;)
                        if (o = u[a], i.index.isPrototypeOf(o)) {
                            if (l = o.map.get(i.key))
                                for (s = l.length; s--;)(h = l[s]).selector !== t || !d && h.data !== e || (l.splice(s, 1), f[h.id] = !0);
                            break
                        }
                for (r in f) delete p[r], this.size--;
                for (r in p) c.push(p[r].selector)
            }
        }, g.prototype.queryAll = function(t) {
            if (!this.selectors.length) return [];
            var e, n, i, r, a, s, o, l, h = {},
                u = [],
                c = this.querySelectorAll(this.selectors.join(", "), t);
            for (e = 0, i = c.length; e < i; e++)
                for (a = c[e], n = 0, r = (s = this.matches(a)).length; n < r; n++) h[(l = s[n]).id] ? o = h[l.id] : (o = {
                    id: l.id,
                    selector: l.selector,
                    data: l.data,
                    elements: []
                }, h[l.id] = o, u.push(o)), o.elements.push(a);
            return u.sort(M)
        }, g.prototype.matches = function(t) {
            if (!t) return [];
            var e, n, i, r, a, s, o, l, h, u, c, p = this.activeIndexes,
                f = {},
                d = [];
            for (e = 0, r = p.length; e < r; e++)
                if (l = (o = p[e]).element(t))
                    for (n = 0, a = l.length; n < a; n++)
                        if (h = o.map.get(l[n]))
                            for (i = 0, s = h.length; i < s; i++) !f[c = (u = h[i]).id] && this.matchesSelector(t, u.selector) && (f[c] = !0, d.push(u));
            return d.sort(M)
        };
        const T = {},
            A = {},
            C = ["mouseenter", "mouseleave"];

        function P(t) {
            void 0 === A[t] && (A[t] = [])
        }

        function F(t) {
            return "string" == typeof t ? document.querySelectorAll(t) : t
        }

        function L(t) {
            let e = function(t, e) {
                const n = [];
                let i = e;
                do {
                    if (1 !== i.nodeType) break;
                    const e = t.matches(i);
                    e.length && n.push({
                        delegatedTarget: i,
                        stack: e
                    })
                } while (i = i.parentElement);
                return n
            }(T[t.type], t.target);
            if (e.length)
                for (let n = 0; n < e.length; n++)
                    for (let i = 0; i < e[n].stack.length; i++) - 1 !== C.indexOf(t.type) ? (R(t, e[n].delegatedTarget), t.target === e[n].delegatedTarget && e[n].stack[i].data(t)) : (R(t, e[n].delegatedTarget), e[n].stack[i].data(t))
        }

        function R(t, e) {
            Object.defineProperty(t, "currentTarget", {
                configurable: !0,
                enumerable: !0,
                value: e
            })
        }

        function I(t) {
            return JSON.parse(JSON.stringify(t))
        }
        const k = new class {
            bindAll(t, e) {
                void 0 === e && (e = Object.getOwnPropertyNames(Object.getPrototypeOf(t)));
                for (let n = 0; n < e.length; n++) t[e[n]] = t[e[n]].bind(t)
            }
            on(t, e, n, i) {
                if ("function" == typeof e && void 0 === n) return P(t), void A[t].push(e);
                const r = t.split(" ");
                for (let t = 0; t < r.length; t++)
                    if (e.nodeType && 1 === e.nodeType || e === window || e === document) e.addEventListener(r[t], n, i);
                    else {
                        e = F(e);
                        for (let a = 0; a < e.length; a++) e[a].addEventListener(r[t], n, i)
                    }
            }
            delegate(t, e, n) {
                const i = t.split(" ");
                for (let t = 0; t < i.length; t++) {
                    let r = T[i[t]];
                    void 0 === r && (r = new g, T[i[t]] = r, -1 !== C.indexOf(i[t]) ? document.addEventListener(i[t], L, !0) : document.addEventListener(i[t], L)), r.add(e, n)
                }
            }
            off(t, e, n) {
                if (void 0 === e) return void(A[t] = []);
                if ("function" == typeof e) {
                    P(t);
                    for (let n = 0; n < A[t].length; n++) A[t][n] === e && A[t].splice(n, 1);
                    return
                }
                const i = t.split(" ");
                for (let t = 0; t < i.length; t++) {
                    const r = T[i[t]];
                    if (void 0 === r || (r.remove(e, n), 0 !== r.size))
                        if (void 0 === e.removeEventListener) {
                            e = F(e);
                            for (let r = 0; r < e.length; r++) e[r].removeEventListener(i[t], n)
                        } else e.removeEventListener(i[t], n);
                    else delete T[i[t]], document.removeEventListener(i[t], L)
                }
            }
            emit(t, ...e) {
                ! function(t, e) {
                    if (A[t])
                        for (let n = 0; n < A[t].length; n++) A[t][n](...e)
                }(t, e)
            }
            debugDelegated() {
                return I(T)
            }
            debugBus() {
                return I(A)
            }
        };

        function O(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }

        function N(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function B(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }
        var z = 37,
            V = 38,
            U = 39,
            G = 40,
            H = 32,
            j = "ontouchstart" in window || window.TouchEvent || window.DocumentTouch && document instanceof DocumentTouch,
            W = "onkeydown" in document,
            X = f.flags,
            q = f.bounds,
            Y = X.windows,
            Z = X.isFirefox,
            J = function() {
                function t() {
                    var e = this,
                        n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    O(this, t), B(this, "wheel", (function(t) {
                        var n = e.opts,
                            i = n.mm,
                            r = n.fm,
                            a = e.evt;
                        a.deltaY = t.wheelDeltaY || -1 * t.deltaY, Z && 1 == t.deltaMode && (a.deltaY *= r), a.deltaY *= i, e.notify(t)
                    })), B(this, "touchStart", (function(t) {
                        var n = t.targetTouches ? t.targetTouches[0] : t;
                        e.touchStartY = n.pageY
                    })), B(this, "touchMove", (function(t) {
                        var n = e.opts.tm,
                            i = e.evt,
                            r = t.targetTouches ? t.targetTouches[0] : t;
                        i.deltaY = (r.pageY - e.touchStartY) * n, e.touchStartY = r.pageY, e.notify(t)
                    })), B(this, "keyDown", (function(t) {
                        if ("INPUT" !== document.activeElement.nodeName) {
                            var n = e.evt,
                                i = e.opts.ks,
                                r = q.wh - 40;
                            switch (n.deltaY = 0, t.keyCode) {
                                case z:
                                case V:
                                    n.deltaY = i;
                                    break;
                                case U:
                                case G:
                                    n.deltaY = -i;
                                    break;
                                case H && t.shiftKey:
                                    n.deltaY = r;
                                    break;
                                case H:
                                    n.deltaY = -r;
                                    break;
                                default:
                                    return
                            }
                            e.notify(t)
                        }
                    })), this.el = window, this.opts = Object.assign({
                        mm: Y ? 1.1 : .45,
                        tm: 2.75,
                        fm: Y ? 40 : 90,
                        ks: 120
                    }, n), this.evt = {
                        y: 0,
                        deltaY: 0
                    }, this.touchStartY = null, this.init()
                }
                var e, n, i;
                return e = t, (n = [{
                    key: "init",
                    value: function() {
                        this.notify(), this.addEvents()
                    }
                }, {
                    key: "addEvents",
                    value: function() {
                        k.on("wheel", this.el, this.wheel, {
                            passive: !0
                        }), j && (k.on("touchstart", this.el, this.touchStart, {
                            passive: !0
                        }), k.on("touchmove", this.el, this.touchMove, {
                            passive: !0
                        })), W && k.on("keydown", document, this.keyDown)
                    }
                }, {
                    key: "notify",
                    value: function() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                            e = this.evt;
                        e.y += e.deltaY, k.emit("vs", {
                            y: e.y,
                            deltaY: e.deltaY,
                            originalEvent: t
                        })
                    }
                }]) && N(e.prototype, n), i && N(e, i), t
            }();
        var K = f.flags;
        new function t() {
            var e, n, i;
            ! function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), i = function(t) {
                var e = t.deltaY;
                K.locked || (Fu.run(), k.emit("scroll", {
                    y: -1 * e
                }))
            }, (n = "onVS") in (e = this) ? Object.defineProperty(e, n, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[n] = i, K.isDesktop && (new J, k.on("vs", this.onVS))
        };

        function $(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }

        function Q(t, e) {
            t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
        }
        var tt, et, nt, it, rt, at, st, ot, lt, ht, ut, ct, pt, ft, dt, mt, gt, vt, yt, _t, xt, bt, Et, wt = {
                autoSleep: 120,
                force3D: "auto",
                nullTargetWarn: 1,
                units: {
                    lineHeight: ""
                }
            },
            Dt = {
                duration: .5,
                overwrite: !1,
                delay: 0
            },
            St = 1e8,
            Mt = 2 * Math.PI,
            Tt = Mt / 4,
            At = 0,
            Ct = Math.sqrt,
            Pt = Math.cos,
            Ft = Math.sin,
            Lt = function(t) {
                return "string" == typeof t
            },
            Rt = function(t) {
                return "function" == typeof t
            },
            It = function(t) {
                return "number" == typeof t
            },
            kt = function(t) {
                return void 0 === t
            },
            Ot = function(t) {
                return "object" == typeof t
            },
            Nt = function(t) {
                return !1 !== t
            },
            Bt = function() {
                return "undefined" != typeof window
            },
            zt = function(t) {
                return Rt(t) || Lt(t)
            },
            Vt = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {},
            Ut = Array.isArray,
            Gt = /(?:-?\.?\d|\.)+/gi,
            Ht = /[-+=.]*\d+[.e\-+]*\d*[e\-\+]*\d*/g,
            jt = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
            Wt = /[-+=.]*\d+(?:\.|e-|e)*\d*/gi,
            Xt = /[+-]=-?[\.\d]+/,
            qt = /[#\-+.]*\b[a-z\d-=+%.]+/gi,
            Yt = {},
            Zt = {},
            Jt = function(t) {
                return (Zt = Ee(t, Yt)) && ai
            },
            Kt = function(t, e) {
                return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
            },
            $t = function(t, e) {
                return !e && console.warn(t)
            },
            Qt = function(t, e) {
                return t && (Yt[t] = e) && Zt && (Zt[t] = e) || Yt
            },
            te = function() {
                return 0
            },
            ee = {},
            ne = [],
            ie = {},
            re = {},
            ae = {},
            se = 30,
            oe = [],
            le = "",
            he = function(t) {
                var e, n, i = t[0];
                if (Ot(i) || Rt(i) || (t = [t]), !(e = (i._gsap || {}).harness)) {
                    for (n = oe.length; n-- && !oe[n].targetTest(i););
                    e = oe[n]
                }
                for (n = t.length; n--;) t[n] && (t[n]._gsap || (t[n]._gsap = new Pn(t[n], e))) || t.splice(n, 1);
                return t
            },
            ue = function(t) {
                return t._gsap || he(Ze(t))[0]._gsap
            },
            ce = function(t, e, n) {
                return (n = t[e]) && Rt(n) ? t[e]() : kt(n) && t.getAttribute && t.getAttribute(e) || n
            },
            pe = function(t, e) {
                return (t = t.split(",")).forEach(e) || t
            },
            fe = function(t) {
                return Math.round(1e5 * t) / 1e5 || 0
            },
            de = function(t, e) {
                for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n;);
                return i < n
            },
            me = function(t, e, n) {
                var i, r = It(t[1]),
                    a = (r ? 2 : 1) + (e < 2 ? 0 : 1),
                    s = t[a];
                if (r && (s.duration = t[1]), s.parent = n, e) {
                    for (i = s; n && !("immediateRender" in i);) i = n.vars.defaults || {}, n = Nt(n.vars.inherit) && n.parent;
                    s.immediateRender = Nt(i.immediateRender), e < 2 ? s.runBackwards = 1 : s.startAt = t[a - 1]
                }
                return s
            },
            ge = function() {
                var t, e, n = ne.length,
                    i = ne.slice(0);
                for (ie = {}, ne.length = 0, t = 0; t < n; t++)(e = i[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
            },
            ve = function(t, e, n, i) {
                ne.length && ge(), t.render(e, n, i), ne.length && ge()
            },
            ye = function(t) {
                var e = parseFloat(t);
                return (e || 0 === e) && (t + "").match(qt).length < 2 ? e : Lt(t) ? t.trim() : t
            },
            _e = function(t) {
                return t
            },
            xe = function(t, e) {
                for (var n in e) n in t || (t[n] = e[n]);
                return t
            },
            be = function(t, e) {
                for (var n in e) n in t || "duration" === n || "ease" === n || (t[n] = e[n])
            },
            Ee = function(t, e) {
                for (var n in e) t[n] = e[n];
                return t
            },
            we = function t(e, n) {
                for (var i in n) e[i] = Ot(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i];
                return e
            },
            De = function(t, e) {
                var n, i = {};
                for (n in t) n in e || (i[n] = t[n]);
                return i
            },
            Se = function(t) {
                var e = t.parent || tt,
                    n = t.keyframes ? be : xe;
                if (Nt(t.inherit))
                    for (; e;) n(t, e.vars.defaults), e = e.parent || e._dp;
                return t
            },
            Me = function(t, e, n, i) {
                void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
                var r = e._prev,
                    a = e._next;
                r ? r._next = a : t[n] === e && (t[n] = a), a ? a._prev = r : t[i] === e && (t[i] = r), e._next = e._prev = e.parent = null
            },
            Te = function(t, e) {
                t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t), t._act = 0
            },
            Ae = function(t, e) {
                if (t && (!e || e._end > t._dur || e._start < 0))
                    for (var n = t; n;) n._dirty = 1, n = n.parent;
                return t
            },
            Ce = function(t) {
                for (var e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent;
                return t
            },
            Pe = function(t) {
                return t._repeat ? Fe(t._tTime, t = t.duration() + t._rDelay) * t : 0
            },
            Fe = function(t, e) {
                return (t /= e) && ~~t === t ? ~~t - 1 : ~~t
            },
            Le = function(t, e) {
                return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
            },
            Re = function(t) {
                return t._end = fe(t._start + (t._tDur / Math.abs(t._ts || t._rts || 1e-8) || 0))
            },
            Ie = function(t, e) {
                var n = t._dp;
                return n && n.smoothChildTiming && t._ts && (t._start = fe(t._dp._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), Re(t), n._dirty || Ae(n, t)), t
            },
            ke = function(t, e) {
                var n;
                if ((e._time || e._initted && !e._dur) && (n = Le(t.rawTime(), e), (!e._dur || je(0, e.totalDuration(), n) - e._tTime > 1e-8) && e.render(n, !0)), Ae(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
                    if (t._dur < t.duration())
                        for (n = t; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
                    t._zTime = -1e-8
                }
            },
            Oe = function(t, e, n, i) {
                return e.parent && Te(e), e._start = fe(n + e._delay), e._end = fe(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)),
                    function(t, e, n, i, r) {
                        void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
                        var a, s = t[i];
                        if (r)
                            for (a = e[r]; s && s[r] > a;) s = s._prev;
                        s ? (e._next = s._next, s._next = e) : (e._next = t[n], t[n] = e), e._next ? e._next._prev = e : t[i] = e, e._prev = s, e.parent = e._dp = t
                    }(t, e, "_first", "_last", t._sort ? "_start" : 0), t._recent = e, i || ke(t, e), t
            },
            Ne = function(t, e) {
                return (Yt.ScrollTrigger || Kt("scrollTrigger", e)) && Yt.ScrollTrigger.create(e, t)
            },
            Be = function(t, e, n, i) {
                return Nn(t, e), t._initted ? !n && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && at !== vn.frame ? (ne.push(t), t._lazy = [e, i], 1) : void 0 : 1
            },
            ze = function(t, e, n, i) {
                var r = t._repeat,
                    a = fe(e) || 0,
                    s = t._tTime / t._tDur;
                return s && !i && (t._time *= a / t._dur), t._dur = a, t._tDur = r ? r < 0 ? 1e10 : fe(a * (r + 1) + t._rDelay * r) : a, s && !i ? Ie(t, t._tTime = t._tDur * s) : t.parent && Re(t), n || Ae(t.parent, t), t
            },
            Ve = function(t) {
                return t instanceof Ln ? Ae(t) : ze(t, t._dur)
            },
            Ue = {
                _start: 0,
                endTime: te
            },
            Ge = function t(e, n) {
                var i, r, a = e.labels,
                    s = e._recent || Ue,
                    o = e.duration() >= St ? s.endTime(!1) : e._dur;
                return Lt(n) && (isNaN(n) || n in a) ? "<" === (i = n.charAt(0)) || ">" === i ? ("<" === i ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) : (i = n.indexOf("=")) < 0 ? (n in a || (a[n] = o), a[n]) : (r = +(n.charAt(i - 1) + n.substr(i + 1)), i > 1 ? t(e, n.substr(0, i - 1)) + r : o + r) : null == n ? o : +n
            },
            He = function(t, e) {
                return t || 0 === t ? e(t) : e
            },
            je = function(t, e, n) {
                return n < t ? t : n > e ? e : n
            },
            We = function(t) {
                return (t = (t + "").substr((parseFloat(t) + "").length)) && isNaN(t) ? t : ""
            },
            Xe = [].slice,
            qe = function(t, e) {
                return t && Ot(t) && "length" in t && (!e && !t.length || t.length - 1 in t && Ot(t[0])) && !t.nodeType && t !== et
            },
            Ye = function(t, e, n) {
                return void 0 === n && (n = []), t.forEach((function(t) {
                    var i;
                    return Lt(t) && !e || qe(t, 1) ? (i = n).push.apply(i, Ze(t)) : n.push(t)
                })) || n
            },
            Ze = function(t, e) {
                return !Lt(t) || e || !nt && yn() ? Ut(t) ? Ye(t, e) : qe(t) ? Xe.call(t, 0) : t ? [t] : [] : Xe.call(it.querySelectorAll(t), 0)
            },
            Je = function(t) {
                return t.sort((function() {
                    return .5 - Math.random()
                }))
            },
            Ke = function(t) {
                if (Rt(t)) return t;
                var e = Ot(t) ? t : {
                        each: t
                    },
                    n = Sn(e.ease),
                    i = e.from || 0,
                    r = parseFloat(e.base) || 0,
                    a = {},
                    s = i > 0 && i < 1,
                    o = isNaN(i) || s,
                    l = e.axis,
                    h = i,
                    u = i;
                return Lt(i) ? h = u = {
                        center: .5,
                        edges: .5,
                        end: 1
                    }[i] || 0 : !s && o && (h = i[0], u = i[1]),
                    function(t, s, c) {
                        var p, f, d, m, g, v, y, _, x, b = (c || e).length,
                            E = a[b];
                        if (!E) {
                            if (!(x = "auto" === e.grid ? 0 : (e.grid || [1, St])[1])) {
                                for (y = -St; y < (y = c[x++].getBoundingClientRect().left) && x < b;);
                                x--
                            }
                            for (E = a[b] = [], p = o ? Math.min(x, b) * h - .5 : i % x, f = o ? b * u / x - .5 : i / x | 0, y = 0, _ = St, v = 0; v < b; v++) d = v % x - p, m = f - (v / x | 0), E[v] = g = l ? Math.abs("y" === l ? m : d) : Ct(d * d + m * m), g > y && (y = g), g < _ && (_ = g);
                            "random" === i && Je(E), E.max = y - _, E.min = _, E.v = b = (parseFloat(e.amount) || parseFloat(e.each) * (x > b ? b - 1 : l ? "y" === l ? b / x : x : Math.max(x, b / x)) || 0) * ("edges" === i ? -1 : 1), E.b = b < 0 ? r - b : r, E.u = We(e.amount || e.each) || 0, n = n && b < 0 ? wn(n) : n
                        }
                        return b = (E[t] - E.min) / E.max || 0, fe(E.b + (n ? n(b) : b) * E.v) + E.u
                    }
            },
            $e = function(t) {
                var e = t < 1 ? Math.pow(10, (t + "").length - 2) : 1;
                return function(n) {
                    return Math.floor(Math.round(parseFloat(n) / t) * t * e) / e + (It(n) ? 0 : We(n))
                }
            },
            Qe = function(t, e) {
                var n, i, r = Ut(t);
                return !r && Ot(t) && (n = r = t.radius || St, t.values ? (t = Ze(t.values), (i = !It(t[0])) && (n *= n)) : t = $e(t.increment)), He(e, r ? Rt(t) ? function(e) {
                    return i = t(e), Math.abs(i - e) <= n ? i : e
                } : function(e) {
                    for (var r, a, s = parseFloat(i ? e.x : e), o = parseFloat(i ? e.y : 0), l = St, h = 0, u = t.length; u--;)(r = i ? (r = t[u].x - s) * r + (a = t[u].y - o) * a : Math.abs(t[u] - s)) < l && (l = r, h = u);
                    return h = !n || l <= n ? t[h] : e, i || h === e || It(e) ? h : h + We(e)
                } : $e(t))
            },
            tn = function(t, e, n, i) {
                return He(Ut(t) ? !e : !0 === n ? !!(n = 0) : !i, (function() {
                    return Ut(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t + Math.random() * (e - t)) / n) * n * i) / i
                }))
            },
            en = function(t, e, n) {
                return He(n, (function(n) {
                    return t[~~e(n)]
                }))
            },
            nn = function(t) {
                for (var e, n, i, r, a = 0, s = ""; ~(e = t.indexOf("random(", a));) i = t.indexOf(")", e), r = "[" === t.charAt(e + 7), n = t.substr(e + 7, i - e - 7).match(r ? qt : Gt), s += t.substr(a, e - a) + tn(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5), a = i + 1;
                return s + t.substr(a, t.length - a)
            },
            rn = function(t, e, n, i, r) {
                var a = e - t,
                    s = i - n;
                return He(r, (function(e) {
                    return n + ((e - t) / a * s || 0)
                }))
            },
            an = function(t, e, n) {
                var i, r, a, s = t.labels,
                    o = St;
                for (i in s)(r = s[i] - e) < 0 == !!n && r && o > (r = Math.abs(r)) && (a = i, o = r);
                return a
            },
            sn = function(t, e, n) {
                var i, r, a = t.vars,
                    s = a[e];
                if (s) return i = a[e + "Params"], r = a.callbackScope || t, n && ne.length && ge(), i ? s.apply(r, i) : s.call(r)
            },
            on = function(t) {
                return Te(t), t.progress() < 1 && sn(t, "onInterrupt"), t
            },
            ln = function(t) {
                var e = (t = !t.name && t.default || t).name,
                    n = Rt(t),
                    i = e && !n && t.init ? function() {
                        this._props = []
                    } : t,
                    r = {
                        init: te,
                        render: Jn,
                        add: kn,
                        kill: $n,
                        modifier: Kn,
                        rawVars: 0
                    },
                    a = {
                        targetTest: 0,
                        get: 0,
                        getSetter: Xn,
                        aliases: {},
                        register: 0
                    };
                if (yn(), t !== i) {
                    if (re[e]) return;
                    xe(i, xe(De(t, r), a)), Ee(i.prototype, Ee(r, De(t, a))), re[i.prop = e] = i, t.targetTest && (oe.push(i), ee[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
                }
                Qt(e, i), t.register && t.register(ai, i, ei)
            },
            hn = {
                aqua: [0, 255, 255],
                lime: [0, 255, 0],
                silver: [192, 192, 192],
                black: [0, 0, 0],
                maroon: [128, 0, 0],
                teal: [0, 128, 128],
                blue: [0, 0, 255],
                navy: [0, 0, 128],
                white: [255, 255, 255],
                olive: [128, 128, 0],
                yellow: [255, 255, 0],
                orange: [255, 165, 0],
                gray: [128, 128, 128],
                purple: [128, 0, 128],
                green: [0, 128, 0],
                red: [255, 0, 0],
                pink: [255, 192, 203],
                cyan: [0, 255, 255],
                transparent: [255, 255, 255, 0]
            },
            un = function(t, e, n) {
                return 255 * (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) + .5 | 0
            },
            cn = function(t, e, n) {
                var i, r, a, s, o, l, h, u, c, p, f = t ? It(t) ? [t >> 16, t >> 8 & 255, 255 & t] : 0 : hn.black;
                if (!f) {
                    if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), hn[t]) f = hn[t];
                    else if ("#" === t.charAt(0)) 4 === t.length && (i = t.charAt(1), r = t.charAt(2), a = t.charAt(3), t = "#" + i + i + r + r + a + a), f = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & 255, 255 & t];
                    else if ("hsl" === t.substr(0, 3))
                        if (f = p = t.match(Gt), e) {
                            if (~t.indexOf("=")) return f = t.match(Ht), n && f.length < 4 && (f[3] = 1), f
                        } else s = +f[0] % 360 / 360, o = +f[1] / 100, i = 2 * (l = +f[2] / 100) - (r = l <= .5 ? l * (o + 1) : l + o - l * o), f.length > 3 && (f[3] *= 1), f[0] = un(s + 1 / 3, i, r), f[1] = un(s, i, r), f[2] = un(s - 1 / 3, i, r);
                    else f = t.match(Gt) || hn.transparent;
                    f = f.map(Number)
                }
                return e && !p && (i = f[0] / 255, r = f[1] / 255, a = f[2] / 255, l = ((h = Math.max(i, r, a)) + (u = Math.min(i, r, a))) / 2, h === u ? s = o = 0 : (c = h - u, o = l > .5 ? c / (2 - h - u) : c / (h + u), s = h === i ? (r - a) / c + (r < a ? 6 : 0) : h === r ? (a - i) / c + 2 : (i - r) / c + 4, s *= 60), f[0] = ~~(s + .5), f[1] = ~~(100 * o + .5), f[2] = ~~(100 * l + .5)), n && f.length < 4 && (f[3] = 1), f
            },
            pn = function(t) {
                var e = [],
                    n = [],
                    i = -1;
                return t.split(dn).forEach((function(t) {
                    var r = t.match(jt) || [];
                    e.push.apply(e, r), n.push(i += r.length + 1)
                })), e.c = n, e
            },
            fn = function(t, e, n) {
                var i, r, a, s, o = "",
                    l = (t + o).match(dn),
                    h = e ? "hsla(" : "rgba(",
                    u = 0;
                if (!l) return t;
                if (l = l.map((function(t) {
                        return (t = cn(t, e, 1)) && h + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
                    })), n && (a = pn(t), (i = n.c).join(o) !== a.c.join(o)))
                    for (s = (r = t.replace(dn, "1").split(jt)).length - 1; u < s; u++) o += r[u] + (~i.indexOf(u) ? l.shift() || h + "0,0,0,0)" : (a.length ? a : l.length ? l : n).shift());
                if (!r)
                    for (s = (r = t.split(dn)).length - 1; u < s; u++) o += r[u] + l[u];
                return o + r[s]
            },
            dn = function() {
                var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
                for (t in hn) e += "|" + t + "\\b";
                return new RegExp(e + ")", "gi")
            }(),
            mn = /hsl[a]?\(/,
            gn = function(t) {
                var e, n = t.join(" ");
                if (dn.lastIndex = 0, dn.test(n)) return e = mn.test(n), t[1] = fn(t[1], e), t[0] = fn(t[0], e, pn(t[1])), !0
            },
            vn = (dt = Date.now, mt = 500, gt = 33, vt = dt(), yt = vt, xt = _t = 1e3 / 240, Et = function t(e) {
                var n, i, r, a, s = dt() - yt,
                    o = !0 === e;
                if (s > mt && (vt += s - gt), ((n = (r = (yt += s) - vt) - xt) > 0 || o) && (a = ++ct.frame, pt = r - 1e3 * ct.time, ct.time = r /= 1e3, xt += n + (n >= _t ? 4 : _t - n), i = 1), o || (lt = ht(t)), i)
                    for (ft = 0; ft < bt.length; ft++) bt[ft](r, pt, a, e)
            }, ct = {
                time: 0,
                frame: 0,
                tick: function() {
                    Et(!0)
                },
                deltaRatio: function(t) {
                    return pt / (1e3 / (t || 60))
                },
                wake: function() {
                    rt && (!nt && Bt() && (et = nt = window, it = et.document || {}, Yt.gsap = ai, (et.gsapVersions || (et.gsapVersions = [])).push(ai.version), Jt(Zt || et.GreenSockGlobals || !et.gsap && et || {}), ut = et.requestAnimationFrame), lt && ct.sleep(), ht = ut || function(t) {
                        return setTimeout(t, xt - 1e3 * ct.time + 1 | 0)
                    }, ot = 1, Et(2))
                },
                sleep: function() {
                    (ut ? et.cancelAnimationFrame : clearTimeout)(lt), ot = 0, ht = te
                },
                lagSmoothing: function(t, e) {
                    mt = t || 1 / 1e-8, gt = Math.min(e, mt, 0)
                },
                fps: function(t) {
                    _t = 1e3 / (t || 240), xt = 1e3 * ct.time + _t
                },
                add: function(t) {
                    bt.indexOf(t) < 0 && bt.push(t), yn()
                },
                remove: function(t) {
                    var e;
                    ~(e = bt.indexOf(t)) && bt.splice(e, 1) && ft >= e && ft--
                },
                _listeners: bt = []
            }),
            yn = function() {
                return !ot && vn.wake()
            },
            _n = {},
            xn = /^[\d.\-M][\d.\-,\s]/,
            bn = /["']/g,
            En = function(t) {
                for (var e, n, i, r = {}, a = t.substr(1, t.length - 3).split(":"), s = a[0], o = 1, l = a.length; o < l; o++) n = a[o], e = o !== l - 1 ? n.lastIndexOf(",") : n.length, i = n.substr(0, e), r[s] = isNaN(i) ? i.replace(bn, "").trim() : +i, s = n.substr(e + 1).trim();
                return r
            },
            wn = function(t) {
                return function(e) {
                    return 1 - t(1 - e)
                }
            },
            Dn = function t(e, n) {
                for (var i, r = e._first; r;) r instanceof Ln ? t(r, n) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === n || (r.timeline ? t(r.timeline, n) : (i = r._ease, r._ease = r._yEase, r._yEase = i, r._yoyo = n)), r = r._next
            },
            Sn = function(t, e) {
                return t && (Rt(t) ? t : _n[t] || function(t) {
                    var e, n, i, r, a = (t + "").split("("),
                        s = _n[a[0]];
                    return s && a.length > 1 && s.config ? s.config.apply(null, ~t.indexOf("{") ? [En(a[1])] : (e = t, n = e.indexOf("(") + 1, i = e.indexOf(")"), r = e.indexOf("(", n), e.substring(n, ~r && r < i ? e.indexOf(")", i + 1) : i)).split(",").map(ye)) : _n._CE && xn.test(t) ? _n._CE("", t) : s
                }(t)) || e
            },
            Mn = function(t, e, n, i) {
                void 0 === n && (n = function(t) {
                    return 1 - e(1 - t)
                }), void 0 === i && (i = function(t) {
                    return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
                });
                var r, a = {
                    easeIn: e,
                    easeOut: n,
                    easeInOut: i
                };
                return pe(t, (function(t) {
                    for (var e in _n[t] = Yt[t] = a, _n[r = t.toLowerCase()] = n, a) _n[r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = _n[t + "." + e] = a[e]
                })), a
            },
            Tn = function(t) {
                return function(e) {
                    return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2
                }
            },
            An = function t(e, n, i) {
                var r = n >= 1 ? n : 1,
                    a = (i || (e ? .3 : .45)) / (n < 1 ? n : 1),
                    s = a / Mt * (Math.asin(1 / r) || 0),
                    o = function(t) {
                        return 1 === t ? 1 : r * Math.pow(2, -10 * t) * Ft((t - s) * a) + 1
                    },
                    l = "out" === e ? o : "in" === e ? function(t) {
                        return 1 - o(1 - t)
                    } : Tn(o);
                return a = Mt / a, l.config = function(n, i) {
                    return t(e, n, i)
                }, l
            },
            Cn = function t(e, n) {
                void 0 === n && (n = 1.70158);
                var i = function(t) {
                        return t ? --t * t * ((n + 1) * t + n) + 1 : 0
                    },
                    r = "out" === e ? i : "in" === e ? function(t) {
                        return 1 - i(1 - t)
                    } : Tn(i);
                return r.config = function(n) {
                    return t(e, n)
                }, r
            };
        pe("Linear,Quad,Cubic,Quart,Quint,Strong", (function(t, e) {
                var n = e < 5 ? e + 1 : e;
                Mn(t + ",Power" + (n - 1), e ? function(t) {
                    return Math.pow(t, n)
                } : function(t) {
                    return t
                }, (function(t) {
                    return 1 - Math.pow(1 - t, n)
                }), (function(t) {
                    return t < .5 ? Math.pow(2 * t, n) / 2 : 1 - Math.pow(2 * (1 - t), n) / 2
                }))
            })), _n.Linear.easeNone = _n.none = _n.Linear.easeIn, Mn("Elastic", An("in"), An("out"), An()),
            function(t, e) {
                var n = 1 / e,
                    i = function(i) {
                        return i < n ? t * i * i : i < .7272727272727273 ? t * Math.pow(i - 1.5 / e, 2) + .75 : i < .9090909090909092 ? t * (i -= 2.25 / e) * i + .9375 : t * Math.pow(i - 2.625 / e, 2) + .984375
                    };
                Mn("Bounce", (function(t) {
                    return 1 - i(1 - t)
                }), i)
            }(7.5625, 2.75), Mn("Expo", (function(t) {
                return t ? Math.pow(2, 10 * (t - 1)) : 0
            })), Mn("Circ", (function(t) {
                return -(Ct(1 - t * t) - 1)
            })), Mn("Sine", (function(t) {
                return 1 === t ? 1 : 1 - Pt(t * Tt)
            })), Mn("Back", Cn("in"), Cn("out"), Cn()), _n.SteppedEase = _n.steps = Yt.SteppedEase = {
                config: function(t, e) {
                    void 0 === t && (t = 1);
                    var n = 1 / t,
                        i = t + (e ? 0 : 1),
                        r = e ? 1 : 0;
                    return function(t) {
                        return ((i * je(0, 1 - 1e-8, t) | 0) + r) * n
                    }
                }
            }, Dt.ease = _n["quad.out"], pe("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(t) {
                return le += t + "," + t + "Params,"
            }));
        var Pn = function(t, e) {
                this.id = At++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : ce, this.set = e ? e.getSetter : Xn
            },
            Fn = function() {
                function t(t, e) {
                    var n = t.parent || tt;
                    this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, ze(this, +t.duration, 1, 1), this.data = t.data, ot || vn.wake(), n && Oe(n, this, e || 0 === e ? e : n._time, 1), t.reversed && this.reverse(), t.paused && this.paused(!0)
                }
                var e = t.prototype;
                return e.delay = function(t) {
                    return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay
                }, e.duration = function(t) {
                    return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
                }, e.totalDuration = function(t) {
                    return arguments.length ? (this._dirty = 0, ze(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
                }, e.totalTime = function(t, e) {
                    if (yn(), !arguments.length) return this._tTime;
                    var n = this._dp;
                    if (n && n.smoothChildTiming && this._ts) {
                        for (Ie(this, t); n.parent;) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent;
                        !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && Oe(this._dp, this, this._start - this._delay)
                    }
                    return (this._tTime !== t || !this._dur && !e || this._initted && 1e-8 === Math.abs(this._zTime) || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), ve(this, t, e)), this
                }, e.time = function(t, e) {
                    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Pe(this)) % this._dur || (t ? this._dur : 0), e) : this._time
                }, e.totalProgress = function(t, e) {
                    return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
                }, e.progress = function(t, e) {
                    return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Pe(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
                }, e.iteration = function(t, e) {
                    var n = this.duration() + this._rDelay;
                    return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? Fe(this._tTime, n) + 1 : 1
                }, e.timeScale = function(t) {
                    if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
                    if (this._rts === t) return this;
                    var e = this.parent && this._ts ? Le(this.parent._time, this) : this._tTime;
                    return this._rts = +t || 0, this._ts = this._ps || -1e-8 === t ? 0 : this._rts, Ce(this.totalTime(je(-this._delay, this._tDur, e), !0))
                }, e.paused = function(t) {
                    return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (yn(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && (this._tTime -= 1e-8) && 1e-8 !== Math.abs(this._zTime)))), this) : this._ps
                }, e.startTime = function(t) {
                    if (arguments.length) {
                        this._start = t;
                        var e = this.parent || this._dp;
                        return e && (e._sort || !this.parent) && Oe(e, this, t - this._delay), this
                    }
                    return this._start
                }, e.endTime = function(t) {
                    return this._start + (Nt(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts)
                }, e.rawTime = function(t) {
                    var e = this.parent || this._dp;
                    return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Le(e.rawTime(t), this) : this._tTime : this._tTime
                }, e.globalTime = function(t) {
                    for (var e = this, n = arguments.length ? t : e.rawTime(); e;) n = e._start + n / (e._ts || 1), e = e._dp;
                    return n
                }, e.repeat = function(t) {
                    return arguments.length ? (this._repeat = t, Ve(this)) : this._repeat
                }, e.repeatDelay = function(t) {
                    return arguments.length ? (this._rDelay = t, Ve(this)) : this._rDelay
                }, e.yoyo = function(t) {
                    return arguments.length ? (this._yoyo = t, this) : this._yoyo
                }, e.seek = function(t, e) {
                    return this.totalTime(Ge(this, t), Nt(e))
                }, e.restart = function(t, e) {
                    return this.play().totalTime(t ? -this._delay : 0, Nt(e))
                }, e.play = function(t, e) {
                    return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                }, e.reverse = function(t, e) {
                    return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
                }, e.pause = function(t, e) {
                    return null != t && this.seek(t, e), this.paused(!0)
                }, e.resume = function() {
                    return this.paused(!1)
                }, e.reversed = function(t) {
                    return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0
                }, e.invalidate = function() {
                    return this._initted = 0, this._zTime = -1e-8, this
                }, e.isActive = function() {
                    var t, e = this.parent || this._dp,
                        n = this._start;
                    return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= n && t < this.endTime(!0) - 1e-8))
                }, e.eventCallback = function(t, e, n) {
                    var i = this.vars;
                    return arguments.length > 1 ? (e ? (i[t] = e, n && (i[t + "Params"] = n), "onUpdate" === t && (this._onUpdate = e)) : delete i[t], this) : i[t]
                }, e.then = function(t) {
                    var e = this;
                    return new Promise((function(n) {
                        var i = Rt(t) ? t : _e,
                            r = function() {
                                var t = e.then;
                                e.then = null, Rt(i) && (i = i(e)) && (i.then || i === e) && (e.then = t), n(i), e.then = t
                            };
                        e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? r() : e._prom = r
                    }))
                }, e.kill = function() {
                    on(this)
                }, t
            }();
        xe(Fn.prototype, {
            _time: 0,
            _start: 0,
            _end: 0,
            _tTime: 0,
            _tDur: 0,
            _dirty: 0,
            _repeat: 0,
            _yoyo: !1,
            parent: null,
            _initted: !1,
            _rDelay: 0,
            _ts: 1,
            _dp: 0,
            ratio: 0,
            _zTime: -1e-8,
            _prom: 0,
            _ps: !1,
            _rts: 1
        });
        var Ln = function(t) {
            function e(e, n) {
                var i;
                return void 0 === e && (e = {}), (i = t.call(this, e, n) || this).labels = {}, i.smoothChildTiming = !!e.smoothChildTiming, i.autoRemoveChildren = !!e.autoRemoveChildren, i._sort = Nt(e.sortChildren), i.parent && ke(i.parent, $(i)), e.scrollTrigger && Ne($(i), e.scrollTrigger), i
            }
            Q(e, t);
            var n = e.prototype;
            return n.to = function(t, e, n) {
                return new Un(t, me(arguments, 0, this), Ge(this, It(e) ? arguments[3] : n)), this
            }, n.from = function(t, e, n) {
                return new Un(t, me(arguments, 1, this), Ge(this, It(e) ? arguments[3] : n)), this
            }, n.fromTo = function(t, e, n, i) {
                return new Un(t, me(arguments, 2, this), Ge(this, It(e) ? arguments[4] : i)), this
            }, n.set = function(t, e, n) {
                return e.duration = 0, e.parent = this, Se(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new Un(t, e, Ge(this, n), 1), this
            }, n.call = function(t, e, n) {
                return Oe(this, Un.delayedCall(0, t, e), Ge(this, n))
            }, n.staggerTo = function(t, e, n, i, r, a, s) {
                return n.duration = e, n.stagger = n.stagger || i, n.onComplete = a, n.onCompleteParams = s, n.parent = this, new Un(t, n, Ge(this, r)), this
            }, n.staggerFrom = function(t, e, n, i, r, a, s) {
                return n.runBackwards = 1, Se(n).immediateRender = Nt(n.immediateRender), this.staggerTo(t, e, n, i, r, a, s)
            }, n.staggerFromTo = function(t, e, n, i, r, a, s, o) {
                return i.startAt = n, Se(i).immediateRender = Nt(i.immediateRender), this.staggerTo(t, e, i, r, a, s, o)
            }, n.render = function(t, e, n) {
                var i, r, a, s, o, l, h, u, c, p, f, d, m = this._time,
                    g = this._dirty ? this.totalDuration() : this._tDur,
                    v = this._dur,
                    y = this !== tt && t > g - 1e-8 && t >= 0 ? g : t < 1e-8 ? 0 : t,
                    _ = this._zTime < 0 != t < 0 && (this._initted || !v);
                if (y !== this._tTime || n || _) {
                    if (m !== this._time && v && (y += this._time - m, t += this._time - m), i = y, c = this._start, l = !(u = this._ts), _ && (v || (m = this._zTime), (t || !e) && (this._zTime = t)), this._repeat && (f = this._yoyo, o = v + this._rDelay, i = fe(y % o), y === g ? (s = this._repeat, i = v) : ((s = ~~(y / o)) && s === y / o && (i = v, s--), i > v && (i = v)), p = Fe(this._tTime, o), !m && this._tTime && p !== s && (p = s), f && 1 & s && (i = v - i, d = 1), s !== p && !this._lock)) {
                        var x = f && 1 & p,
                            b = x === (f && 1 & s);
                        if (s < p && (x = !x), m = x ? 0 : v, this._lock = 1, this.render(m || (d ? 0 : fe(s * o)), e, !v)._lock = 0, !e && this.parent && sn(this, "onRepeat"), this.vars.repeatRefresh && !d && (this.invalidate()._lock = 1), m !== this._time || l !== !this._ts) return this;
                        if (v = this._dur, g = this._tDur, b && (this._lock = 2, m = x ? v : -1e-4, this.render(m, !0), this.vars.repeatRefresh && !d && this.invalidate()), this._lock = 0, !this._ts && !l) return this;
                        Dn(this, d)
                    }
                    if (this._hasPause && !this._forcing && this._lock < 2 && (h = function(t, e, n) {
                            var i;
                            if (n > e)
                                for (i = t._first; i && i._start <= n;) {
                                    if (!i._dur && "isPause" === i.data && i._start > e) return i;
                                    i = i._next
                                } else
                                    for (i = t._last; i && i._start >= n;) {
                                        if (!i._dur && "isPause" === i.data && i._start < e) return i;
                                        i = i._prev
                                    }
                        }(this, fe(m), fe(i))) && (y -= i - (i = h._start)), this._tTime = y, this._time = i, this._act = !u, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t), !m && i && !e && sn(this, "onStart"), i >= m && t >= 0)
                        for (r = this._first; r;) {
                            if (a = r._next, (r._act || i >= r._start) && r._ts && h !== r) {
                                if (r.parent !== this) return this.render(t, e, n);
                                if (r.render(r._ts > 0 ? (i - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (i - r._start) * r._ts, e, n), i !== this._time || !this._ts && !l) {
                                    h = 0, a && (y += this._zTime = -1e-8);
                                    break
                                }
                            }
                            r = a
                        } else {
                            r = this._last;
                            for (var E = t < 0 ? t : i; r;) {
                                if (a = r._prev, (r._act || E <= r._end) && r._ts && h !== r) {
                                    if (r.parent !== this) return this.render(t, e, n);
                                    if (r.render(r._ts > 0 ? (E - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (E - r._start) * r._ts, e, n), i !== this._time || !this._ts && !l) {
                                        h = 0, a && (y += this._zTime = E ? -1e-8 : 1e-8);
                                        break
                                    }
                                }
                                r = a
                            }
                        }
                    if (h && !e && (this.pause(), h.render(i >= m ? 0 : -1e-8)._zTime = i >= m ? 1 : -1, this._ts)) return this._start = c, Re(this), this.render(t, e, n);
                    this._onUpdate && !e && sn(this, "onUpdate", !0), (y === g && g >= this.totalDuration() || !y && m) && (c !== this._start && Math.abs(u) === Math.abs(this._ts) || this._lock || ((t || !v) && (y === g && this._ts > 0 || !y && this._ts < 0) && Te(this, 1), e || t < 0 && !m || !y && !m || (sn(this, y === g ? "onComplete" : "onReverseComplete", !0), this._prom && !(y < g && this.timeScale() > 0) && this._prom())))
                }
                return this
            }, n.add = function(t, e) {
                var n = this;
                if (It(e) || (e = Ge(this, e)), !(t instanceof Fn)) {
                    if (Ut(t)) return t.forEach((function(t) {
                        return n.add(t, e)
                    })), this;
                    if (Lt(t)) return this.addLabel(t, e);
                    if (!Rt(t)) return this;
                    t = Un.delayedCall(0, t)
                }
                return this !== t ? Oe(this, t, e) : this
            }, n.getChildren = function(t, e, n, i) {
                void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === n && (n = !0), void 0 === i && (i = -St);
                for (var r = [], a = this._first; a;) a._start >= i && (a instanceof Un ? e && r.push(a) : (n && r.push(a), t && r.push.apply(r, a.getChildren(!0, e, n)))), a = a._next;
                return r
            }, n.getById = function(t) {
                for (var e = this.getChildren(1, 1, 1), n = e.length; n--;)
                    if (e[n].vars.id === t) return e[n]
            }, n.remove = function(t) {
                return Lt(t) ? this.removeLabel(t) : Rt(t) ? this.killTweensOf(t) : (Me(this, t), t === this._recent && (this._recent = this._last), Ae(this))
            }, n.totalTime = function(e, n) {
                return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = fe(vn.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))), t.prototype.totalTime.call(this, e, n), this._forcing = 0, this) : this._tTime
            }, n.addLabel = function(t, e) {
                return this.labels[t] = Ge(this, e), this
            }, n.removeLabel = function(t) {
                return delete this.labels[t], this
            }, n.addPause = function(t, e, n) {
                var i = Un.delayedCall(0, e || te, n);
                return i.data = "isPause", this._hasPause = 1, Oe(this, i, Ge(this, t))
            }, n.removePause = function(t) {
                var e = this._first;
                for (t = Ge(this, t); e;) e._start === t && "isPause" === e.data && Te(e), e = e._next
            }, n.killTweensOf = function(t, e, n) {
                for (var i = this.getTweensOf(t, n), r = i.length; r--;) Rn !== i[r] && i[r].kill(t, e);
                return this
            }, n.getTweensOf = function(t, e) {
                for (var n, i = [], r = Ze(t), a = this._first, s = It(e); a;) a instanceof Un ? de(a._targets, r) && (s ? (!Rn || a._initted && a._ts) && a.globalTime(0) <= e && a.globalTime(a.totalDuration()) > e : !e || a.isActive()) && i.push(a) : (n = a.getTweensOf(r, e)).length && i.push.apply(i, n), a = a._next;
                return i
            }, n.tweenTo = function(t, e) {
                e = e || {};
                var n = this,
                    i = Ge(n, t),
                    r = e,
                    a = r.startAt,
                    s = r.onStart,
                    o = r.onStartParams,
                    l = Un.to(n, xe(e, {
                        ease: "none",
                        lazy: !1,
                        time: i,
                        overwrite: "auto",
                        duration: e.duration || Math.abs((i - (a && "time" in a ? a.time : n._time)) / n.timeScale()) || 1e-8,
                        onStart: function() {
                            n.pause();
                            var t = e.duration || Math.abs((i - n._time) / n.timeScale());
                            l._dur !== t && ze(l, t, 0, 1).render(l._time, !0, !0), s && s.apply(l, o || [])
                        }
                    }));
                return l
            }, n.tweenFromTo = function(t, e, n) {
                return this.tweenTo(e, xe({
                    startAt: {
                        time: Ge(this, t)
                    }
                }, n))
            }, n.recent = function() {
                return this._recent
            }, n.nextLabel = function(t) {
                return void 0 === t && (t = this._time), an(this, Ge(this, t))
            }, n.previousLabel = function(t) {
                return void 0 === t && (t = this._time), an(this, Ge(this, t), 1)
            }, n.currentLabel = function(t) {
                return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + 1e-8)
            }, n.shiftChildren = function(t, e, n) {
                void 0 === n && (n = 0);
                for (var i, r = this._first, a = this.labels; r;) r._start >= n && (r._start += t, r._end += t), r = r._next;
                if (e)
                    for (i in a) a[i] >= n && (a[i] += t);
                return Ae(this)
            }, n.invalidate = function() {
                var e = this._first;
                for (this._lock = 0; e;) e.invalidate(), e = e._next;
                return t.prototype.invalidate.call(this)
            }, n.clear = function(t) {
                void 0 === t && (t = !0);
                for (var e, n = this._first; n;) e = n._next, this.remove(n), n = e;
                return this._time = this._tTime = this._pTime = 0, t && (this.labels = {}), Ae(this)
            }, n.totalDuration = function(t) {
                var e, n, i, r = 0,
                    a = this,
                    s = a._last,
                    o = St;
                if (arguments.length) return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -t : t));
                if (a._dirty) {
                    for (i = a.parent; s;) e = s._prev, s._dirty && s.totalDuration(), (n = s._start) > o && a._sort && s._ts && !a._lock ? (a._lock = 1, Oe(a, s, n - s._delay, 1)._lock = 0) : o = n, n < 0 && s._ts && (r -= n, (!i && !a._dp || i && i.smoothChildTiming) && (a._start += n / a._ts, a._time -= n, a._tTime -= n), a.shiftChildren(-n, !1, -Infinity), o = 0), s._end > r && s._ts && (r = s._end), s = e;
                    ze(a, a === tt && a._time > r ? a._time : r, 1, 1), a._dirty = 0
                }
                return a._tDur
            }, e.updateRoot = function(t) {
                if (tt._ts && (ve(tt, Le(t, tt)), at = vn.frame), vn.frame >= se) {
                    se += wt.autoSleep || 120;
                    var e = tt._first;
                    if ((!e || !e._ts) && wt.autoSleep && vn._listeners.length < 2) {
                        for (; e && !e._ts;) e = e._next;
                        e || vn.sleep()
                    }
                }
            }, e
        }(Fn);
        xe(Ln.prototype, {
            _lock: 0,
            _hasPause: 0,
            _forcing: 0
        });
        var Rn, In = function(t, e, n, i, r, a, s) {
                var o, l, h, u, c, p, f, d, m = new ei(this._pt, t, e, 0, 1, Zn, null, r),
                    g = 0,
                    v = 0;
                for (m.b = n, m.e = i, n += "", (f = ~(i += "").indexOf("random(")) && (i = nn(i)), a && (a(d = [n, i], t, e), n = d[0], i = d[1]), l = n.match(Wt) || []; o = Wt.exec(i);) u = o[0], c = i.substring(g, o.index), h ? h = (h + 1) % 5 : "rgba(" === c.substr(-5) && (h = 1), u !== l[v++] && (p = parseFloat(l[v - 1]) || 0, m._pt = {
                    _next: m._pt,
                    p: c || 1 === v ? c : ",",
                    s: p,
                    c: "=" === u.charAt(1) ? parseFloat(u.substr(2)) * ("-" === u.charAt(0) ? -1 : 1) : parseFloat(u) - p,
                    m: h && h < 4 ? Math.round : 0
                }, g = Wt.lastIndex);
                return m.c = g < i.length ? i.substring(g, i.length) : "", m.fp = s, (Xt.test(i) || f) && (m.e = 0), this._pt = m, m
            },
            kn = function(t, e, n, i, r, a, s, o, l) {
                Rt(i) && (i = i(r || 0, t, a));
                var h, u = t[e],
                    c = "get" !== n ? n : Rt(u) ? l ? t[e.indexOf("set") || !Rt(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : u,
                    p = Rt(u) ? l ? jn : Hn : Gn;
                if (Lt(i) && (~i.indexOf("random(") && (i = nn(i)), "=" === i.charAt(1) && (i = parseFloat(c) + parseFloat(i.substr(2)) * ("-" === i.charAt(0) ? -1 : 1) + (We(c) || 0))), c !== i) return isNaN(c * i) ? (!u && !(e in t) && Kt(e, i), In.call(this, t, e, c, i, p, o || wt.stringFilter, l)) : (h = new ei(this._pt, t, e, +c || 0, i - (c || 0), "boolean" == typeof u ? Yn : qn, 0, p), l && (h.fp = l), s && h.modifier(s, this, t), this._pt = h)
            },
            On = function(t, e, n, i, r, a) {
                var s, o, l, h;
                if (re[t] && !1 !== (s = new re[t]).init(r, s.rawVars ? e[t] : function(t, e, n, i, r) {
                        if (Rt(t) && (t = Bn(t, r, e, n, i)), !Ot(t) || t.style && t.nodeType || Ut(t) || Vt(t)) return Lt(t) ? Bn(t, r, e, n, i) : t;
                        var a, s = {};
                        for (a in t) s[a] = Bn(t[a], r, e, n, i);
                        return s
                    }(e[t], i, r, a, n), n, i, a) && (n._pt = o = new ei(n._pt, r, t, 0, 1, s.render, s, 0, s.priority), n !== st))
                    for (l = n._ptLookup[n._targets.indexOf(r)], h = s._props.length; h--;) l[s._props[h]] = o;
                return s
            },
            Nn = function t(e, n) {
                var i, r, a, s, o, l, h, u, c, p, f, d, m, g = e.vars,
                    v = g.ease,
                    y = g.startAt,
                    _ = g.immediateRender,
                    x = g.lazy,
                    b = g.onUpdate,
                    E = g.onUpdateParams,
                    w = g.callbackScope,
                    D = g.runBackwards,
                    S = g.yoyoEase,
                    M = g.keyframes,
                    T = g.autoRevert,
                    A = e._dur,
                    C = e._startAt,
                    P = e._targets,
                    F = e.parent,
                    L = F && "nested" === F.data ? F.parent._targets : P,
                    R = "auto" === e._overwrite,
                    I = e.timeline;
                if (I && (!M || !v) && (v = "none"), e._ease = Sn(v, Dt.ease), e._yEase = S ? wn(Sn(!0 === S ? v : S, Dt.ease)) : 0, S && e._yoyo && !e._repeat && (S = e._yEase, e._yEase = e._ease, e._ease = S), !I) {
                    if (d = (u = P[0] ? ue(P[0]).harness : 0) && g[u.prop], i = De(g, ee), C && C.render(-1, !0).kill(), y) {
                        if (Te(e._startAt = Un.set(P, xe({
                                data: "isStart",
                                overwrite: !1,
                                parent: F,
                                immediateRender: !0,
                                lazy: Nt(x),
                                startAt: null,
                                delay: 0,
                                onUpdate: b,
                                onUpdateParams: E,
                                callbackScope: w,
                                stagger: 0
                            }, y))), _)
                            if (n > 0) T || (e._startAt = 0);
                            else if (A && !(n < 0 && C)) return void(n && (e._zTime = n))
                    } else if (D && A)
                        if (C) !T && (e._startAt = 0);
                        else if (n && (_ = !1), a = xe({
                            overwrite: !1,
                            data: "isFromStart",
                            lazy: _ && Nt(x),
                            immediateRender: _,
                            stagger: 0,
                            parent: F
                        }, i), d && (a[u.prop] = d), Te(e._startAt = Un.set(P, a)), _) {
                        if (!n) return
                    } else t(e._startAt, 1e-8);
                    for (e._pt = 0, x = A && Nt(x) || x && !A, r = 0; r < P.length; r++) {
                        if (h = (o = P[r])._gsap || he(P)[r]._gsap, e._ptLookup[r] = p = {}, ie[h.id] && ne.length && ge(), f = L === P ? r : L.indexOf(o), u && !1 !== (c = new u).init(o, d || i, e, f, L) && (e._pt = s = new ei(e._pt, o, c.name, 0, 1, c.render, c, 0, c.priority), c._props.forEach((function(t) {
                                p[t] = s
                            })), c.priority && (l = 1)), !u || d)
                            for (a in i) re[a] && (c = On(a, i, e, f, o, L)) ? c.priority && (l = 1) : p[a] = s = kn.call(e, o, a, "get", i[a], f, L, 0, g.stringFilter);
                        e._op && e._op[r] && e.kill(o, e._op[r]), R && e._pt && (Rn = e, tt.killTweensOf(o, p, e.globalTime(0)), m = !e.parent, Rn = 0), e._pt && x && (ie[h.id] = 1)
                    }
                    l && ti(e), e._onInit && e._onInit(e)
                }
                e._from = !I && !!g.runBackwards, e._onUpdate = b, e._initted = (!e._op || e._pt) && !m
            },
            Bn = function(t, e, n, i, r) {
                return Rt(t) ? t.call(e, n, i, r) : Lt(t) && ~t.indexOf("random(") ? nn(t) : t
            },
            zn = le + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
            Vn = (zn + ",id,stagger,delay,duration,paused,scrollTrigger").split(","),
            Un = function(t) {
                function e(e, n, i, r) {
                    var a;
                    "number" == typeof n && (i.duration = n, n = i, i = null);
                    var s, o, l, h, u, c, p, f, d = (a = t.call(this, r ? n : Se(n), i) || this).vars,
                        m = d.duration,
                        g = d.delay,
                        v = d.immediateRender,
                        y = d.stagger,
                        _ = d.overwrite,
                        x = d.keyframes,
                        b = d.defaults,
                        E = d.scrollTrigger,
                        w = d.yoyoEase,
                        D = a.parent,
                        S = (Ut(e) || Vt(e) ? It(e[0]) : "length" in n) ? [e] : Ze(e);
                    if (a._targets = S.length ? he(S) : $t("GSAP target " + e + " not found. https://greensock.com", !wt.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = _, x || y || zt(m) || zt(g)) {
                        if (n = a.vars, (s = a.timeline = new Ln({
                                data: "nested",
                                defaults: b || {}
                            })).kill(), s.parent = $(a), x) xe(s.vars.defaults, {
                            ease: "none"
                        }), x.forEach((function(t) {
                            return s.to(S, t, ">")
                        }));
                        else {
                            if (h = S.length, p = y ? Ke(y) : te, Ot(y))
                                for (u in y) ~zn.indexOf(u) && (f || (f = {}), f[u] = y[u]);
                            for (o = 0; o < h; o++) {
                                for (u in l = {}, n) Vn.indexOf(u) < 0 && (l[u] = n[u]);
                                l.stagger = 0, w && (l.yoyoEase = w), f && Ee(l, f), c = S[o], l.duration = +Bn(m, $(a), o, c, S), l.delay = (+Bn(g, $(a), o, c, S) || 0) - a._delay, !y && 1 === h && l.delay && (a._delay = g = l.delay, a._start += g, l.delay = 0), s.to(c, l, p(o, c, S))
                            }
                            s.duration() ? m = g = 0 : a.timeline = 0
                        }
                        m || a.duration(m = s.duration())
                    } else a.timeline = 0;
                    return !0 === _ && (Rn = $(a), tt.killTweensOf(S), Rn = 0), D && ke(D, $(a)), (v || !m && !x && a._start === fe(D._time) && Nt(v) && function t(e) {
                        return !e || e._ts && t(e.parent)
                    }($(a)) && "nested" !== D.data) && (a._tTime = -1e-8, a.render(Math.max(0, -g))), E && Ne($(a), E), a
                }
                Q(e, t);
                var n = e.prototype;
                return n.render = function(t, e, n) {
                    var i, r, a, s, o, l, h, u, c, p = this._time,
                        f = this._tDur,
                        d = this._dur,
                        m = t > f - 1e-8 && t >= 0 ? f : t < 1e-8 ? 0 : t;
                    if (d) {
                        if (m !== this._tTime || !t || n || this._startAt && this._zTime < 0 != t < 0) {
                            if (i = m, u = this.timeline, this._repeat) {
                                if (s = d + this._rDelay, i = fe(m % s), m === f ? (a = this._repeat, i = d) : ((a = ~~(m / s)) && a === m / s && (i = d, a--), i > d && (i = d)), (l = this._yoyo && 1 & a) && (c = this._yEase, i = d - i), o = Fe(this._tTime, s), i === p && !n && this._initted) return this;
                                a !== o && (u && this._yEase && Dn(u, l), !this.vars.repeatRefresh || l || this._lock || (this._lock = n = 1, this.render(fe(s * a), !0).invalidate()._lock = 0))
                            }
                            if (!this._initted) {
                                if (Be(this, t < 0 ? t : i, n, e)) return this._tTime = 0, this;
                                if (d !== this._dur) return this.render(t, e, n)
                            }
                            for (this._tTime = m, this._time = i, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = h = (c || this._ease)(i / d), this._from && (this.ratio = h = 1 - h), i && !p && !e && sn(this, "onStart"), r = this._pt; r;) r.r(h, r.d), r = r._next;
                            u && u.render(t < 0 ? t : !i && l ? -1e-8 : u._dur * h, e, n) || this._startAt && (this._zTime = t), this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, n), sn(this, "onUpdate")), this._repeat && a !== o && this.vars.onRepeat && !e && this.parent && sn(this, "onRepeat"), m !== this._tDur && m || this._tTime !== m || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, !0), (t || !d) && (m === this._tDur && this._ts > 0 || !m && this._ts < 0) && Te(this, 1), e || t < 0 && !p || !m && !p || (sn(this, m === f ? "onComplete" : "onReverseComplete", !0), this._prom && !(m < f && this.timeScale() > 0) && this._prom()))
                        }
                    } else ! function(t, e, n, i) {
                        var r, a, s = t.ratio,
                            o = e < 0 || !e && s && !t._start && t._zTime > 1e-8 && !t._dp._lock || (t._ts < 0 || t._dp._ts < 0) && "isFromStart" !== t.data && "isStart" !== t.data ? 0 : 1,
                            l = t._rDelay,
                            h = 0;
                        if (l && t._repeat && (h = je(0, t._tDur, e), Fe(h, l) !== (a = Fe(t._tTime, l)) && (s = 1 - o, t.vars.repeatRefresh && t._initted && t.invalidate())), o !== s || i || 1e-8 === t._zTime || !e && t._zTime) {
                            if (!t._initted && Be(t, e, i, n)) return;
                            for (a = t._zTime, t._zTime = e || (n ? 1e-8 : 0), n || (n = e && !a), t.ratio = o, t._from && (o = 1 - o), t._time = 0, t._tTime = h, n || sn(t, "onStart"), r = t._pt; r;) r.r(o, r.d), r = r._next;
                            t._startAt && e < 0 && t._startAt.render(e, !0, !0), t._onUpdate && !n && sn(t, "onUpdate"), h && t._repeat && !n && t.parent && sn(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === o && (o && Te(t, 1), n || (sn(t, o ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
                        } else t._zTime || (t._zTime = e)
                    }(this, t, e, n);
                    return this
                }, n.targets = function() {
                    return this._targets
                }, n.invalidate = function() {
                    return this._pt = this._op = this._startAt = this._onUpdate = this._act = this._lazy = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), t.prototype.invalidate.call(this)
                }, n.kill = function(t, e) {
                    if (void 0 === e && (e = "all"), !(t || e && "all" !== e) && (this._lazy = 0, this.parent)) return on(this);
                    if (this.timeline) {
                        var n = this.timeline.totalDuration();
                        return this.timeline.killTweensOf(t, e, Rn && !0 !== Rn.vars.overwrite)._first || on(this), this.parent && n !== this.timeline.totalDuration() && ze(this, this._dur * this.timeline._tDur / n, 0, 1), this
                    }
                    var i, r, a, s, o, l, h, u = this._targets,
                        c = t ? Ze(t) : u,
                        p = this._ptLookup,
                        f = this._pt;
                    if ((!e || "all" === e) && function(t, e) {
                            for (var n = t.length, i = n === e.length; i && n-- && t[n] === e[n];);
                            return n < 0
                        }(u, c)) return "all" === e && (this._pt = 0), on(this);
                    for (i = this._op = this._op || [], "all" !== e && (Lt(e) && (o = {}, pe(e, (function(t) {
                            return o[t] = 1
                        })), e = o), e = function(t, e) {
                            var n, i, r, a, s = t[0] ? ue(t[0]).harness : 0,
                                o = s && s.aliases;
                            if (!o) return e;
                            for (i in n = Ee({}, e), o)
                                if (i in n)
                                    for (r = (a = o[i].split(",")).length; r--;) n[a[r]] = n[i];
                            return n
                        }(u, e)), h = u.length; h--;)
                        if (~c.indexOf(u[h]))
                            for (o in r = p[h], "all" === e ? (i[h] = e, s = r, a = {}) : (a = i[h] = i[h] || {}, s = e), s)(l = r && r[o]) && ("kill" in l.d && !0 !== l.d.kill(o) || Me(this, l, "_pt"), delete r[o]), "all" !== a && (a[o] = 1);
                    return this._initted && !this._pt && f && on(this), this
                }, e.to = function(t, n) {
                    return new e(t, n, arguments[2])
                }, e.from = function(t, n) {
                    return new e(t, me(arguments, 1))
                }, e.delayedCall = function(t, n, i, r) {
                    return new e(n, 0, {
                        immediateRender: !1,
                        lazy: !1,
                        overwrite: !1,
                        delay: t,
                        onComplete: n,
                        onReverseComplete: n,
                        onCompleteParams: i,
                        onReverseCompleteParams: i,
                        callbackScope: r
                    })
                }, e.fromTo = function(t, n, i) {
                    return new e(t, me(arguments, 2))
                }, e.set = function(t, n) {
                    return n.duration = 0, n.repeatDelay || (n.repeat = 0), new e(t, n)
                }, e.killTweensOf = function(t, e, n) {
                    return tt.killTweensOf(t, e, n)
                }, e
            }(Fn);
        xe(Un.prototype, {
            _targets: [],
            _lazy: 0,
            _startAt: 0,
            _op: 0,
            _onInit: 0
        }), pe("staggerTo,staggerFrom,staggerFromTo", (function(t) {
            Un[t] = function() {
                var e = new Ln,
                    n = Xe.call(arguments, 0);
                return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n)
            }
        }));
        var Gn = function(t, e, n) {
                return t[e] = n
            },
            Hn = function(t, e, n) {
                return t[e](n)
            },
            jn = function(t, e, n, i) {
                return t[e](i.fp, n)
            },
            Wn = function(t, e, n) {
                return t.setAttribute(e, n)
            },
            Xn = function(t, e) {
                return Rt(t[e]) ? Hn : kt(t[e]) && t.setAttribute ? Wn : Gn
            },
            qn = function(t, e) {
                return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4, e)
            },
            Yn = function(t, e) {
                return e.set(e.t, e.p, !!(e.s + e.c * t), e)
            },
            Zn = function(t, e) {
                var n = e._pt,
                    i = "";
                if (!t && e.b) i = e.b;
                else if (1 === t && e.e) i = e.e;
                else {
                    for (; n;) i = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round(1e4 * (n.s + n.c * t)) / 1e4) + i, n = n._next;
                    i += e.c
                }
                e.set(e.t, e.p, i, e)
            },
            Jn = function(t, e) {
                for (var n = e._pt; n;) n.r(t, n.d), n = n._next
            },
            Kn = function(t, e, n, i) {
                for (var r, a = this._pt; a;) r = a._next, a.p === i && a.modifier(t, e, n), a = r
            },
            $n = function(t) {
                for (var e, n, i = this._pt; i;) n = i._next, i.p === t && !i.op || i.op === t ? Me(this, i, "_pt") : i.dep || (e = 1), i = n;
                return !e
            },
            Qn = function(t, e, n, i) {
                i.mSet(t, e, i.m.call(i.tween, n, i.mt), i)
            },
            ti = function(t) {
                for (var e, n, i, r, a = t._pt; a;) {
                    for (e = a._next, n = i; n && n.pr > a.pr;) n = n._next;
                    (a._prev = n ? n._prev : r) ? a._prev._next = a: i = a, (a._next = n) ? n._prev = a : r = a, a = e
                }
                t._pt = i
            },
            ei = function() {
                function t(t, e, n, i, r, a, s, o, l) {
                    this.t = e, this.s = i, this.c = r, this.p = n, this.r = a || qn, this.d = s || this, this.set = o || Gn, this.pr = l || 0, this._next = t, t && (t._prev = this)
                }
                return t.prototype.modifier = function(t, e, n) {
                    this.mSet = this.mSet || this.set, this.set = Qn, this.m = t, this.mt = n, this.tween = e
                }, t
            }();
        pe(le + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(t) {
            return ee[t] = 1
        })), Yt.TweenMax = Yt.TweenLite = Un, Yt.TimelineLite = Yt.TimelineMax = Ln, tt = new Ln({
            sortChildren: !1,
            defaults: Dt,
            autoRemoveChildren: !0,
            id: "root",
            smoothChildTiming: !0
        }), wt.stringFilter = gn;
        var ni = {
            registerPlugin: function() {
                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                e.forEach((function(t) {
                    return ln(t)
                }))
            },
            timeline: function(t) {
                return new Ln(t)
            },
            getTweensOf: function(t, e) {
                return tt.getTweensOf(t, e)
            },
            getProperty: function(t, e, n, i) {
                Lt(t) && (t = Ze(t)[0]);
                var r = ue(t || {}).get,
                    a = n ? _e : ye;
                return "native" === n && (n = ""), t ? e ? a((re[e] && re[e].get || r)(t, e, n, i)) : function(e, n, i) {
                    return a((re[e] && re[e].get || r)(t, e, n, i))
                } : t
            },
            quickSetter: function(t, e, n) {
                if ((t = Ze(t)).length > 1) {
                    var i = t.map((function(t) {
                            return ai.quickSetter(t, e, n)
                        })),
                        r = i.length;
                    return function(t) {
                        for (var e = r; e--;) i[e](t)
                    }
                }
                t = t[0] || {};
                var a = re[e],
                    s = ue(t),
                    o = s.harness && (s.harness.aliases || {})[e] || e,
                    l = a ? function(e) {
                        var i = new a;
                        st._pt = 0, i.init(t, n ? e + n : e, st, 0, [t]), i.render(1, i), st._pt && Jn(1, st)
                    } : s.set(t, o);
                return a ? l : function(e) {
                    return l(t, o, n ? e + n : e, s, 1)
                }
            },
            isTweening: function(t) {
                return tt.getTweensOf(t, !0).length > 0
            },
            defaults: function(t) {
                return t && t.ease && (t.ease = Sn(t.ease, Dt.ease)), we(Dt, t || {})
            },
            config: function(t) {
                return we(wt, t || {})
            },
            registerEffect: function(t) {
                var e = t.name,
                    n = t.effect,
                    i = t.plugins,
                    r = t.defaults,
                    a = t.extendTimeline;
                (i || "").split(",").forEach((function(t) {
                    return t && !re[t] && !Yt[t] && $t(e + " effect requires " + t + " plugin.")
                })), ae[e] = function(t, e, i) {
                    return n(Ze(t), xe(e || {}, r), i)
                }, a && (Ln.prototype[e] = function(t, n, i) {
                    return this.add(ae[e](t, Ot(n) ? n : (i = n) && {}, this), i)
                })
            },
            registerEase: function(t, e) {
                _n[t] = Sn(e)
            },
            parseEase: function(t, e) {
                return arguments.length ? Sn(t, e) : _n
            },
            getById: function(t) {
                return tt.getById(t)
            },
            exportRoot: function(t, e) {
                void 0 === t && (t = {});
                var n, i, r = new Ln(t);
                for (r.smoothChildTiming = Nt(t.smoothChildTiming), tt.remove(r), r._dp = 0, r._time = r._tTime = tt._time, n = tt._first; n;) i = n._next, !e && !n._dur && n instanceof Un && n.vars.onComplete === n._targets[0] || Oe(r, n, n._start - n._delay), n = i;
                return Oe(tt, r, 0), r
            },
            utils: {
                wrap: function t(e, n, i) {
                    var r = n - e;
                    return Ut(e) ? en(e, t(0, e.length), n) : He(i, (function(t) {
                        return (r + (t - e) % r) % r + e
                    }))
                },
                wrapYoyo: function t(e, n, i) {
                    var r = n - e,
                        a = 2 * r;
                    return Ut(e) ? en(e, t(0, e.length - 1), n) : He(i, (function(t) {
                        return e + ((t = (a + (t - e) % a) % a || 0) > r ? a - t : t)
                    }))
                },
                distribute: Ke,
                random: tn,
                snap: Qe,
                normalize: function(t, e, n) {
                    return rn(t, e, 0, 1, n)
                },
                getUnit: We,
                clamp: function(t, e, n) {
                    return He(n, (function(n) {
                        return je(t, e, n)
                    }))
                },
                splitColor: cn,
                toArray: Ze,
                mapRange: rn,
                pipe: function() {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    return function(t) {
                        return e.reduce((function(t, e) {
                            return e(t)
                        }), t)
                    }
                },
                unitize: function(t, e) {
                    return function(n) {
                        return t(parseFloat(n)) + (e || We(n))
                    }
                },
                interpolate: function t(e, n, i, r) {
                    var a = isNaN(e + n) ? 0 : function(t) {
                        return (1 - t) * e + t * n
                    };
                    if (!a) {
                        var s, o, l, h, u, c = Lt(e),
                            p = {};
                        if (!0 === i && (r = 1) && (i = null), c) e = {
                            p: e
                        }, n = {
                            p: n
                        };
                        else if (Ut(e) && !Ut(n)) {
                            for (l = [], h = e.length, u = h - 2, o = 1; o < h; o++) l.push(t(e[o - 1], e[o]));
                            h--, a = function(t) {
                                t *= h;
                                var e = Math.min(u, ~~t);
                                return l[e](t - e)
                            }, i = n
                        } else r || (e = Ee(Ut(e) ? [] : {}, e));
                        if (!l) {
                            for (s in n) kn.call(p, e, s, "get", n[s]);
                            a = function(t) {
                                return Jn(t, p) || (c ? e.p : e)
                            }
                        }
                    }
                    return He(i, a)
                },
                shuffle: Je
            },
            install: Jt,
            effects: ae,
            ticker: vn,
            updateRoot: Ln.updateRoot,
            plugins: re,
            globalTimeline: tt,
            core: {
                PropTween: ei,
                globals: Qt,
                Tween: Un,
                Timeline: Ln,
                Animation: Fn,
                getCache: ue,
                _removeLinkedListItem: Me
            }
        };
        pe("to,from,fromTo,delayedCall,set,killTweensOf", (function(t) {
            return ni[t] = Un[t]
        })), vn.add(Ln.updateRoot), st = ni.to({}, {
            duration: 0
        });
        var ii = function(t, e) {
                for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e;) n = n._next;
                return n
            },
            ri = function(t, e) {
                return {
                    name: t,
                    rawVars: 1,
                    init: function(t, n, i) {
                        i._onInit = function(t) {
                            var i, r;
                            if (Lt(n) && (i = {}, pe(n, (function(t) {
                                    return i[t] = 1
                                })), n = i), e) {
                                for (r in i = {}, n) i[r] = e(n[r]);
                                n = i
                            }! function(t, e) {
                                var n, i, r, a = t._targets;
                                for (n in e)
                                    for (i = a.length; i--;)(r = t._ptLookup[i][n]) && (r = r.d) && (r._pt && (r = ii(r, n)), r && r.modifier && r.modifier(e[n], t, a[i], n))
                            }(t, n)
                        }
                    }
                }
            },
            ai = ni.registerPlugin({
                name: "attr",
                init: function(t, e, n, i, r) {
                    var a, s;
                    for (a in e)(s = this.add(t, "setAttribute", (t.getAttribute(a) || 0) + "", e[a], i, r, 0, 0, a)) && (s.op = a), this._props.push(a)
                }
            }, {
                name: "endArray",
                init: function(t, e) {
                    for (var n = e.length; n--;) this.add(t, n, t[n] || 0, e[n])
                }
            }, ri("roundProps", $e), ri("modifiers"), ri("snap", Qe)) || ni;
        Un.version = Ln.version = ai.version = "3.5.1", rt = 1, Bt() && yn();
        _n.Power0, _n.Power1, _n.Power2, _n.Power3, _n.Power4, _n.Linear, _n.Quad, _n.Cubic, _n.Quart, _n.Quint, _n.Strong, _n.Elastic, _n.Back, _n.SteppedEase, _n.Bounce, _n.Sine, _n.Expo, _n.Circ;
        var si, oi, li, hi, ui, ci, pi, fi, di = {},
            mi = 180 / Math.PI,
            gi = Math.PI / 180,
            vi = Math.atan2,
            yi = /([A-Z])/g,
            _i = /(?:left|right|width|margin|padding|x)/i,
            xi = /[\s,\(]\S/,
            bi = {
                autoAlpha: "opacity,visibility",
                scale: "scaleX,scaleY",
                alpha: "opacity"
            },
            Ei = function(t, e) {
                return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
            },
            wi = function(t, e) {
                return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
            },
            Di = function(t, e) {
                return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
            },
            Si = function(t, e) {
                var n = e.s + e.c * t;
                e.set(e.t, e.p, ~~(n + (n < 0 ? -.5 : .5)) + e.u, e)
            },
            Mi = function(t, e) {
                return e.set(e.t, e.p, t ? e.e : e.b, e)
            },
            Ti = function(t, e) {
                return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
            },
            Ai = function(t, e, n) {
                return t.style[e] = n
            },
            Ci = function(t, e, n) {
                return t.style.setProperty(e, n)
            },
            Pi = function(t, e, n) {
                return t._gsap[e] = n
            },
            Fi = function(t, e, n) {
                return t._gsap.scaleX = t._gsap.scaleY = n
            },
            Li = function(t, e, n, i, r) {
                var a = t._gsap;
                a.scaleX = a.scaleY = n, a.renderTransform(r, a)
            },
            Ri = function(t, e, n, i, r) {
                var a = t._gsap;
                a[e] = n, a.renderTransform(r, a)
            },
            Ii = "transform",
            ki = Ii + "Origin",
            Oi = function(t, e) {
                var n = oi.createElementNS ? oi.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : oi.createElement(t);
                return n.style ? n : oi.createElement(t)
            },
            Ni = function t(e, n, i) {
                var r = getComputedStyle(e);
                return r[n] || r.getPropertyValue(n.replace(yi, "-$1").toLowerCase()) || r.getPropertyValue(n) || !i && t(e, zi(n) || n, 1) || ""
            },
            Bi = "O,Moz,ms,Ms,Webkit".split(","),
            zi = function(t, e, n) {
                var i = (e || ui).style,
                    r = 5;
                if (t in i && !n) return t;
                for (t = t.charAt(0).toUpperCase() + t.substr(1); r-- && !(Bi[r] + t in i););
                return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? Bi[r] : "") + t
            },
            Vi = function() {
                "undefined" != typeof window && window.document && (si = window, oi = si.document, li = oi.documentElement, ui = Oi("div") || {
                    style: {}
                }, ci = Oi("div"), Ii = zi(Ii), ki = Ii + "Origin", ui.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", fi = !!zi("perspective"), hi = 1)
            },
            Ui = function t(e) {
                var n, i = Oi("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                    r = this.parentNode,
                    a = this.nextSibling,
                    s = this.style.cssText;
                if (li.appendChild(i), i.appendChild(this), this.style.display = "block", e) try {
                    n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t
                } catch (t) {} else this._gsapBBox && (n = this._gsapBBox());
                return r && (a ? r.insertBefore(this, a) : r.appendChild(this)), li.removeChild(i), this.style.cssText = s, n
            },
            Gi = function(t, e) {
                for (var n = e.length; n--;)
                    if (t.hasAttribute(e[n])) return t.getAttribute(e[n])
            },
            Hi = function(t) {
                var e;
                try {
                    e = t.getBBox()
                } catch (n) {
                    e = Ui.call(t, !0)
                }
                return e && (e.width || e.height) || t.getBBox === Ui || (e = Ui.call(t, !0)), !e || e.width || e.x || e.y ? e : {
                    x: +Gi(t, ["x", "cx", "x1"]) || 0,
                    y: +Gi(t, ["y", "cy", "y1"]) || 0,
                    width: 0,
                    height: 0
                }
            },
            ji = function(t) {
                return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !Hi(t))
            },
            Wi = function(t, e) {
                if (e) {
                    var n = t.style;
                    e in di && e !== ki && (e = Ii), n.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), n.removeProperty(e.replace(yi, "-$1").toLowerCase())) : n.removeAttribute(e)
                }
            },
            Xi = function(t, e, n, i, r, a) {
                var s = new ei(t._pt, e, n, 0, 1, a ? Ti : Mi);
                return t._pt = s, s.b = i, s.e = r, t._props.push(n), s
            },
            qi = {
                deg: 1,
                rad: 1,
                turn: 1
            },
            Yi = function t(e, n, i, r) {
                var a, s, o, l, h = parseFloat(i) || 0,
                    u = (i + "").trim().substr((h + "").length) || "px",
                    c = ui.style,
                    p = _i.test(n),
                    f = "svg" === e.tagName.toLowerCase(),
                    d = (f ? "client" : "offset") + (p ? "Width" : "Height"),
                    m = "px" === r,
                    g = "%" === r;
                return r === u || !h || qi[r] || qi[u] ? h : ("px" !== u && !m && (h = t(e, n, i, "px")), l = e.getCTM && ji(e), g && (di[n] || ~n.indexOf("adius")) ? fe(h / (l ? e.getBBox()[p ? "width" : "height"] : e[d]) * 100) : (c[p ? "width" : "height"] = 100 + (m ? u : r), s = ~n.indexOf("adius") || "em" === r && e.appendChild && !f ? e : e.parentNode, l && (s = (e.ownerSVGElement || {}).parentNode), s && s !== oi && s.appendChild || (s = oi.body), (o = s._gsap) && g && o.width && p && o.time === vn.time ? fe(h / o.width * 100) : ((g || "%" === u) && (c.position = Ni(e, "position")), s === e && (c.position = "static"), s.appendChild(ui), a = ui[d], s.removeChild(ui), c.position = "absolute", p && g && ((o = ue(s)).time = vn.time, o.width = s[d]), fe(m ? a * h / 100 : a && h ? 100 / a * h : 0))))
            },
            Zi = function(t, e, n, i) {
                var r;
                return hi || Vi(), e in bi && "transform" !== e && ~(e = bi[e]).indexOf(",") && (e = e.split(",")[0]), di[e] && "transform" !== e ? (r = sr(t, i), r = "transformOrigin" !== e ? r[e] : or(Ni(t, ki)) + " " + r.zOrigin + "px") : (!(r = t.style[e]) || "auto" === r || i || ~(r + "").indexOf("calc(")) && (r = Qi[e] && Qi[e](t, e, n) || Ni(t, e) || ce(t, e) || ("opacity" === e ? 1 : 0)), n && !~(r + "").indexOf(" ") ? Yi(t, e, r, n) + n : r
            },
            Ji = function(t, e, n, i) {
                if (!n || "none" === n) {
                    var r = zi(e, t, 1),
                        a = r && Ni(t, r, 1);
                    a && a !== n ? (e = r, n = a) : "borderColor" === e && (n = Ni(t, "borderTopColor"))
                }
                var s, o, l, h, u, c, p, f, d, m, g, v, y = new ei(this._pt, t.style, e, 0, 1, Zn),
                    _ = 0,
                    x = 0;
                if (y.b = n, y.e = i, n += "", "auto" === (i += "") && (t.style[e] = i, i = Ni(t, e) || i, t.style[e] = n), gn(s = [n, i]), i = s[1], l = (n = s[0]).match(jt) || [], (i.match(jt) || []).length) {
                    for (; o = jt.exec(i);) p = o[0], d = i.substring(_, o.index), u ? u = (u + 1) % 5 : "rgba(" !== d.substr(-5) && "hsla(" !== d.substr(-5) || (u = 1), p !== (c = l[x++] || "") && (h = parseFloat(c) || 0, g = c.substr((h + "").length), (v = "=" === p.charAt(1) ? +(p.charAt(0) + "1") : 0) && (p = p.substr(2)), f = parseFloat(p), m = p.substr((f + "").length), _ = jt.lastIndex - m.length, m || (m = m || wt.units[e] || g, _ === i.length && (i += m, y.e += m)), g !== m && (h = Yi(t, e, c, m) || 0), y._pt = {
                        _next: y._pt,
                        p: d || 1 === x ? d : ",",
                        s: h,
                        c: v ? v * f : f - h,
                        m: u && u < 4 ? Math.round : 0
                    });
                    y.c = _ < i.length ? i.substring(_, i.length) : ""
                } else y.r = "display" === e && "none" === i ? Ti : Mi;
                return Xt.test(i) && (y.e = 0), this._pt = y, y
            },
            Ki = {
                top: "0%",
                bottom: "100%",
                left: "0%",
                right: "100%",
                center: "50%"
            },
            $i = function(t, e) {
                if (e.tween && e.tween._time === e.tween._dur) {
                    var n, i, r, a = e.t,
                        s = a.style,
                        o = e.u,
                        l = a._gsap;
                    if ("all" === o || !0 === o) s.cssText = "", i = 1;
                    else
                        for (r = (o = o.split(",")).length; --r > -1;) n = o[r], di[n] && (i = 1, n = "transformOrigin" === n ? ki : Ii), Wi(a, n);
                    i && (Wi(a, Ii), l && (l.svg && a.removeAttribute("transform"), sr(a, 1), l.uncache = 1))
                }
            },
            Qi = {
                clearProps: function(t, e, n, i, r) {
                    if ("isFromStart" !== r.data) {
                        var a = t._pt = new ei(t._pt, e, n, 0, 0, $i);
                        return a.u = i, a.pr = -10, a.tween = r, t._props.push(n), 1
                    }
                }
            },
            tr = [1, 0, 0, 1, 0, 0],
            er = {},
            nr = function(t) {
                return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
            },
            ir = function(t) {
                var e = Ni(t, Ii);
                return nr(e) ? tr : e.substr(7).match(Ht).map(fe)
            },
            rr = function(t, e) {
                var n, i, r, a, s = t._gsap || ue(t),
                    o = t.style,
                    l = ir(t);
                return s.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = t.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? tr : l : (l !== tr || t.offsetParent || t === li || s.svg || (r = o.display, o.display = "block", (n = t.parentNode) && t.offsetParent || (a = 1, i = t.nextSibling, li.appendChild(t)), l = ir(t), r ? o.display = r : Wi(t, "display"), a && (i ? n.insertBefore(t, i) : n ? n.appendChild(t) : li.removeChild(t))), e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
            },
            ar = function(t, e, n, i, r, a) {
                var s, o, l, h = t._gsap,
                    u = r || rr(t, !0),
                    c = h.xOrigin || 0,
                    p = h.yOrigin || 0,
                    f = h.xOffset || 0,
                    d = h.yOffset || 0,
                    m = u[0],
                    g = u[1],
                    v = u[2],
                    y = u[3],
                    _ = u[4],
                    x = u[5],
                    b = e.split(" "),
                    E = parseFloat(b[0]) || 0,
                    w = parseFloat(b[1]) || 0;
                n ? u !== tr && (o = m * y - g * v) && (l = E * (-g / o) + w * (m / o) - (m * x - g * _) / o, E = E * (y / o) + w * (-v / o) + (v * x - y * _) / o, w = l) : (E = (s = Hi(t)).x + (~b[0].indexOf("%") ? E / 100 * s.width : E), w = s.y + (~(b[1] || b[0]).indexOf("%") ? w / 100 * s.height : w)), i || !1 !== i && h.smooth ? (_ = E - c, x = w - p, h.xOffset = f + (_ * m + x * v) - _, h.yOffset = d + (_ * g + x * y) - x) : h.xOffset = h.yOffset = 0, h.xOrigin = E, h.yOrigin = w, h.smooth = !!i, h.origin = e, h.originIsAbsolute = !!n, t.style[ki] = "0px 0px", a && (Xi(a, h, "xOrigin", c, E), Xi(a, h, "yOrigin", p, w), Xi(a, h, "xOffset", f, h.xOffset), Xi(a, h, "yOffset", d, h.yOffset)), t.setAttribute("data-svg-origin", E + " " + w)
            },
            sr = function(t, e) {
                var n = t._gsap || new Pn(t);
                if ("x" in n && !e && !n.uncache) return n;
                var i, r, a, s, o, l, h, u, c, p, f, d, m, g, v, y, _, x, b, E, w, D, S, M, T, A, C, P, F, L, R, I, k = t.style,
                    O = n.scaleX < 0,
                    N = Ni(t, ki) || "0";
                return i = r = a = l = h = u = c = p = f = 0, s = o = 1, n.svg = !(!t.getCTM || !ji(t)), g = rr(t, n.svg), n.svg && (M = !n.uncache && t.getAttribute("data-svg-origin"), ar(t, M || N, !!M || n.originIsAbsolute, !1 !== n.smooth, g)), d = n.xOrigin || 0, m = n.yOrigin || 0, g !== tr && (x = g[0], b = g[1], E = g[2], w = g[3], i = D = g[4], r = S = g[5], 6 === g.length ? (s = Math.sqrt(x * x + b * b), o = Math.sqrt(w * w + E * E), l = x || b ? vi(b, x) * mi : 0, (c = E || w ? vi(E, w) * mi + l : 0) && (o *= Math.cos(c * gi)), n.svg && (i -= d - (d * x + m * E), r -= m - (d * b + m * w))) : (I = g[6], L = g[7], C = g[8], P = g[9], F = g[10], R = g[11], i = g[12], r = g[13], a = g[14], h = (v = vi(I, F)) * mi, v && (M = D * (y = Math.cos(-v)) + C * (_ = Math.sin(-v)), T = S * y + P * _, A = I * y + F * _, C = D * -_ + C * y, P = S * -_ + P * y, F = I * -_ + F * y, R = L * -_ + R * y, D = M, S = T, I = A), u = (v = vi(-E, F)) * mi, v && (y = Math.cos(-v), R = w * (_ = Math.sin(-v)) + R * y, x = M = x * y - C * _, b = T = b * y - P * _, E = A = E * y - F * _), l = (v = vi(b, x)) * mi, v && (M = x * (y = Math.cos(v)) + b * (_ = Math.sin(v)), T = D * y + S * _, b = b * y - x * _, S = S * y - D * _, x = M, D = T), h && Math.abs(h) + Math.abs(l) > 359.9 && (h = l = 0, u = 180 - u), s = fe(Math.sqrt(x * x + b * b + E * E)), o = fe(Math.sqrt(S * S + I * I)), v = vi(D, S), c = Math.abs(v) > 2e-4 ? v * mi : 0, f = R ? 1 / (R < 0 ? -R : R) : 0), n.svg && (M = t.getAttribute("transform"), n.forceCSS = t.setAttribute("transform", "") || !nr(Ni(t, Ii)), M && t.setAttribute("transform", M))), Math.abs(c) > 90 && Math.abs(c) < 270 && (O ? (s *= -1, c += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (o *= -1, c += c <= 0 ? 180 : -180)), n.x = ((n.xPercent = i && Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0) ? 0 : i) + "px", n.y = ((n.yPercent = r && Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0) ? 0 : r) + "px", n.z = a + "px", n.scaleX = fe(s), n.scaleY = fe(o), n.rotation = fe(l) + "deg", n.rotationX = fe(h) + "deg", n.rotationY = fe(u) + "deg", n.skewX = c + "deg", n.skewY = p + "deg", n.transformPerspective = f + "px", (n.zOrigin = parseFloat(N.split(" ")[2]) || 0) && (k[ki] = or(N)), n.xOffset = n.yOffset = 0, n.force3D = wt.force3D, n.renderTransform = n.svg ? cr : fi ? ur : hr, n.uncache = 0, n
            },
            or = function(t) {
                return (t = t.split(" "))[0] + " " + t[1]
            },
            lr = function(t, e, n) {
                var i = We(e);
                return fe(parseFloat(e) + parseFloat(Yi(t, "x", n + "px", i))) + i
            },
            hr = function(t, e) {
                e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, ur(t, e)
            },
            ur = function(t, e) {
                var n = e || this,
                    i = n.xPercent,
                    r = n.yPercent,
                    a = n.x,
                    s = n.y,
                    o = n.z,
                    l = n.rotation,
                    h = n.rotationY,
                    u = n.rotationX,
                    c = n.skewX,
                    p = n.skewY,
                    f = n.scaleX,
                    d = n.scaleY,
                    m = n.transformPerspective,
                    g = n.force3D,
                    v = n.target,
                    y = n.zOrigin,
                    _ = "",
                    x = "auto" === g && t && 1 !== t || !0 === g;
                if (y && ("0deg" !== u || "0deg" !== h)) {
                    var b, E = parseFloat(h) * gi,
                        w = Math.sin(E),
                        D = Math.cos(E);
                    E = parseFloat(u) * gi, b = Math.cos(E), a = lr(v, a, w * b * -y), s = lr(v, s, -Math.sin(E) * -y), o = lr(v, o, D * b * -y + y)
                }
                "0px" !== m && (_ += "perspective(" + m + ") "), (i || r) && (_ += "translate(" + i + "%, " + r + "%) "), (x || "0px" !== a || "0px" !== s || "0px" !== o) && (_ += "0px" !== o || x ? "translate3d(" + a + ", " + s + ", " + o + ") " : "translate(" + a + ", " + s + ") "), "0deg" !== l && (_ += "rotate(" + l + ") "), "0deg" !== h && (_ += "rotateY(" + h + ") "), "0deg" !== u && (_ += "rotateX(" + u + ") "), "0deg" === c && "0deg" === p || (_ += "skew(" + c + ", " + p + ") "), 1 === f && 1 === d || (_ += "scale(" + f + ", " + d + ") "), v.style[Ii] = _ || "translate(0, 0)"
            },
            cr = function(t, e) {
                var n, i, r, a, s, o = e || this,
                    l = o.xPercent,
                    h = o.yPercent,
                    u = o.x,
                    c = o.y,
                    p = o.rotation,
                    f = o.skewX,
                    d = o.skewY,
                    m = o.scaleX,
                    g = o.scaleY,
                    v = o.target,
                    y = o.xOrigin,
                    _ = o.yOrigin,
                    x = o.xOffset,
                    b = o.yOffset,
                    E = o.forceCSS,
                    w = parseFloat(u),
                    D = parseFloat(c);
                p = parseFloat(p), f = parseFloat(f), (d = parseFloat(d)) && (f += d = parseFloat(d), p += d), p || f ? (p *= gi, f *= gi, n = Math.cos(p) * m, i = Math.sin(p) * m, r = Math.sin(p - f) * -g, a = Math.cos(p - f) * g, f && (d *= gi, s = Math.tan(f - d), r *= s = Math.sqrt(1 + s * s), a *= s, d && (s = Math.tan(d), n *= s = Math.sqrt(1 + s * s), i *= s)), n = fe(n), i = fe(i), r = fe(r), a = fe(a)) : (n = m, a = g, i = r = 0), (w && !~(u + "").indexOf("px") || D && !~(c + "").indexOf("px")) && (w = Yi(v, "x", u, "px"), D = Yi(v, "y", c, "px")), (y || _ || x || b) && (w = fe(w + y - (y * n + _ * r) + x), D = fe(D + _ - (y * i + _ * a) + b)), (l || h) && (s = v.getBBox(), w = fe(w + l / 100 * s.width), D = fe(D + h / 100 * s.height)), s = "matrix(" + n + "," + i + "," + r + "," + a + "," + w + "," + D + ")", v.setAttribute("transform", s), E && (v.style[Ii] = s)
            },
            pr = function(t, e, n, i, r, a) {
                var s, o, l = Lt(r),
                    h = parseFloat(r) * (l && ~r.indexOf("rad") ? mi : 1),
                    u = a ? h * a : h - i,
                    c = i + u + "deg";
                return l && ("short" === (s = r.split("_")[1]) && (u %= 360) !== u % 180 && (u += u < 0 ? 360 : -360), "cw" === s && u < 0 ? u = (u + 36e9) % 360 - 360 * ~~(u / 360) : "ccw" === s && u > 0 && (u = (u - 36e9) % 360 - 360 * ~~(u / 360))), t._pt = o = new ei(t._pt, e, n, i, u, wi), o.e = c, o.u = "deg", t._props.push(n), o
            },
            fr = function(t, e, n) {
                var i, r, a, s, o, l, h, u = ci.style,
                    c = n._gsap;
                for (r in u.cssText = getComputedStyle(n).cssText + ";position:absolute;display:block;", u[Ii] = e, oi.body.appendChild(ci), i = sr(ci, 1), di)(a = c[r]) !== (s = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (o = We(a) !== (h = We(s)) ? Yi(n, r, a, h) : parseFloat(a), l = parseFloat(s), t._pt = new ei(t._pt, c, r, o, l - o, Ei), t._pt.u = h || 0, t._props.push(r));
                oi.body.removeChild(ci)
            };
        pe("padding,margin,Width,Radius", (function(t, e) {
            var n = "Top",
                i = "Right",
                r = "Bottom",
                a = "Left",
                s = (e < 3 ? [n, i, r, a] : [n + a, n + i, r + i, r + a]).map((function(n) {
                    return e < 2 ? t + n : "border" + n + t
                }));
            Qi[e > 1 ? "border" + t : t] = function(t, e, n, i, r) {
                var a, o;
                if (arguments.length < 4) return a = s.map((function(e) {
                    return Zi(t, e, n)
                })), 5 === (o = a.join(" ")).split(a[0]).length ? a[0] : o;
                a = (i + "").split(" "), o = {}, s.forEach((function(t, e) {
                    return o[t] = a[e] = a[e] || a[(e - 1) / 2 | 0]
                })), t.init(e, o, r)
            }
        }));
        var dr, mr, gr = {
            name: "css",
            register: Vi,
            targetTest: function(t) {
                return t.style && t.nodeType
            },
            init: function(t, e, n, i, r) {
                var a, s, o, l, h, u, c, p, f, d, m, g, v, y, _, x, b, E, w, D = this._props,
                    S = t.style;
                for (c in hi || Vi(), e)
                    if ("autoRound" !== c && (s = e[c], !re[c] || !On(c, e, n, i, t, r)))
                        if (h = typeof s, u = Qi[c], "function" === h && (h = typeof(s = s.call(n, i, t, r))), "string" === h && ~s.indexOf("random(") && (s = nn(s)), u) u(this, t, c, s, n) && (_ = 1);
                        else if ("--" === c.substr(0, 2)) this.add(S, "setProperty", getComputedStyle(t).getPropertyValue(c) + "", s + "", i, r, 0, 0, c);
                else if ("undefined" !== h) {
                    if (a = Zi(t, c), l = parseFloat(a), (d = "string" === h && "=" === s.charAt(1) ? +(s.charAt(0) + "1") : 0) && (s = s.substr(2)), o = parseFloat(s), c in bi && ("autoAlpha" === c && (1 === l && "hidden" === Zi(t, "visibility") && o && (l = 0), Xi(this, S, "visibility", l ? "inherit" : "hidden", o ? "inherit" : "hidden", !o)), "scale" !== c && "transform" !== c && ~(c = bi[c]).indexOf(",") && (c = c.split(",")[0])), m = c in di)
                        if (g || ((v = t._gsap).renderTransform || sr(t), y = !1 !== e.smoothOrigin && v.smooth, (g = this._pt = new ei(this._pt, S, Ii, 0, 1, v.renderTransform, v, 0, -1)).dep = 1), "scale" === c) this._pt = new ei(this._pt, v, "scaleY", v.scaleY, d ? d * o : o - v.scaleY), D.push("scaleY", c), c += "X";
                        else {
                            if ("transformOrigin" === c) {
                                b = void 0, E = void 0, w = void 0, b = (x = s).split(" "), E = b[0], w = b[1] || "50%", "top" !== E && "bottom" !== E && "left" !== w && "right" !== w || (x = E, E = w, w = x), b[0] = Ki[E] || E, b[1] = Ki[w] || w, s = b.join(" "), v.svg ? ar(t, s, 0, y, 0, this) : ((f = parseFloat(s.split(" ")[2]) || 0) !== v.zOrigin && Xi(this, v, "zOrigin", v.zOrigin, f), Xi(this, S, c, or(a), or(s)));
                                continue
                            }
                            if ("svgOrigin" === c) {
                                ar(t, s, 1, y, 0, this);
                                continue
                            }
                            if (c in er) {
                                pr(this, v, c, l, s, d);
                                continue
                            }
                            if ("smoothOrigin" === c) {
                                Xi(this, v, "smooth", v.smooth, s);
                                continue
                            }
                            if ("force3D" === c) {
                                v[c] = s;
                                continue
                            }
                            if ("transform" === c) {
                                fr(this, s, t);
                                continue
                            }
                        }
                    else c in S || (c = zi(c) || c);
                    if (m || (o || 0 === o) && (l || 0 === l) && !xi.test(s) && c in S) o || (o = 0), (p = (a + "").substr((l + "").length)) !== (f = We(s) || (c in wt.units ? wt.units[c] : p)) && (l = Yi(t, c, a, f)), this._pt = new ei(this._pt, m ? v : S, c, l, d ? d * o : o - l, "px" !== f || !1 === e.autoRound || m ? Ei : Si), this._pt.u = f || 0, p !== f && (this._pt.b = a, this._pt.r = Di);
                    else if (c in S) Ji.call(this, t, c, a, s);
                    else {
                        if (!(c in t)) {
                            Kt(c, s);
                            continue
                        }
                        this.add(t, c, t[c], s, i, r)
                    }
                    D.push(c)
                }
                _ && ti(this)
            },
            get: Zi,
            aliases: bi,
            getSetter: function(t, e, n) {
                var i = bi[e];
                return i && i.indexOf(",") < 0 && (e = i), e in di && e !== ki && (t._gsap.x || Zi(t, "x")) ? n && pi === n ? "scale" === e ? Fi : Pi : (pi = n || {}) && ("scale" === e ? Li : Ri) : t.style && !kt(t.style[e]) ? Ai : ~e.indexOf("-") ? Ci : Xn(t, e)
            },
            core: {
                _removeProperty: Wi,
                _getMatrix: rr
            }
        };
        ai.utils.checkPrefix = zi, mr = pe("x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + (dr = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function(t) {
            di[t] = 1
        })), pe(dr, (function(t) {
            wt.units[t] = "deg", er[t] = 1
        })), bi[mr[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + dr, pe("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function(t) {
            var e = t.split(":");
            bi[e[1]] = mr[e[0]]
        })), pe("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(t) {
            wt.units[t] = "px"
        })), ai.registerPlugin(gr);
        var vr = ai.registerPlugin(gr) || ai;
        vr.core.Tween;

        function yr(t, e, n) {
            return t * (1 - n) + e * n
        }
        for (var _r = [], xr = 0; xr < 256; xr++) _r[xr] = (xr < 16 ? "0" : "") + xr.toString(16);
        var br, Er = {
            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,
            generateUUID: function() {
                var t = 4294967295 * Math.random() | 0,
                    e = 4294967295 * Math.random() | 0,
                    n = 4294967295 * Math.random() | 0,
                    i = 4294967295 * Math.random() | 0;
                return (_r[255 & t] + _r[t >> 8 & 255] + _r[t >> 16 & 255] + _r[t >> 24 & 255] + "-" + _r[255 & e] + _r[e >> 8 & 255] + "-" + _r[e >> 16 & 15 | 64] + _r[e >> 24 & 255] + "-" + _r[63 & n | 128] + _r[n >> 8 & 255] + "-" + _r[n >> 16 & 255] + _r[n >> 24 & 255] + _r[255 & i] + _r[i >> 8 & 255] + _r[i >> 16 & 255] + _r[i >> 24 & 255]).toUpperCase()
            },
            clamp: function(t, e, n) {
                return Math.max(e, Math.min(n, t))
            },
            euclideanModulo: function(t, e) {
                return (t % e + e) % e
            },
            mapLinear: function(t, e, n, i, r) {
                return i + (t - e) * (r - i) / (n - e)
            },
            lerp: function(t, e, n) {
                return (1 - n) * t + n * e
            },
            smoothstep: function(t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
            },
            smootherstep: function(t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
            },
            randInt: function(t, e) {
                return t + Math.floor(Math.random() * (e - t + 1))
            },
            randFloat: function(t, e) {
                return t + Math.random() * (e - t)
            },
            randFloatSpread: function(t) {
                return t * (.5 - Math.random())
            },
            degToRad: function(t) {
                return t * Er.DEG2RAD
            },
            radToDeg: function(t) {
                return t * Er.RAD2DEG
            },
            isPowerOfTwo: function(t) {
                return 0 == (t & t - 1) && 0 !== t
            },
            ceilPowerOfTwo: function(t) {
                return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
            },
            floorPowerOfTwo: function(t) {
                return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
            },
            setQuaternionFromProperEuler: function(t, e, n, i, r) {
                var a = Math.cos,
                    s = Math.sin,
                    o = a(n / 2),
                    l = s(n / 2),
                    h = a((e + i) / 2),
                    u = s((e + i) / 2),
                    c = a((e - i) / 2),
                    p = s((e - i) / 2),
                    f = a((i - e) / 2),
                    d = s((i - e) / 2);
                switch (r) {
                    case "XYX":
                        t.set(o * u, l * c, l * p, o * h);
                        break;
                    case "YZY":
                        t.set(l * p, o * u, l * c, o * h);
                        break;
                    case "ZXZ":
                        t.set(l * c, l * p, o * u, o * h);
                        break;
                    case "XZX":
                        t.set(o * u, l * d, l * f, o * h);
                        break;
                    case "YXY":
                        t.set(l * f, o * u, l * d, o * h);
                        break;
                    case "ZYZ":
                        t.set(l * d, l * f, o * u, o * h);
                        break;
                    default:
                        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                }
            }
        };

        function wr() {}

        function Dr(t, e) {
            this.x = t || 0, this.y = e || 0
        }

        function Sr() {
            this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
        }
        Object.assign(wr.prototype, {
            addEventListener: function(t, e) {
                void 0 === this._listeners && (this._listeners = {});
                var n = this._listeners;
                void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
            },
            hasEventListener: function(t, e) {
                if (void 0 === this._listeners) return !1;
                var n = this._listeners;
                return void 0 !== n[t] && -1 !== n[t].indexOf(e)
            },
            removeEventListener: function(t, e) {
                if (void 0 !== this._listeners) {
                    var n = this._listeners[t];
                    if (void 0 !== n) {
                        var i = n.indexOf(e); - 1 !== i && n.splice(i, 1)
                    }
                }
            },
            dispatchEvent: function(t) {
                if (void 0 !== this._listeners) {
                    var e = this._listeners[t.type];
                    if (void 0 !== e) {
                        t.target = this;
                        for (var n = e.slice(0), i = 0, r = n.length; i < r; i++) n[i].call(this, t)
                    }
                }
            }
        }), Object.defineProperties(Dr.prototype, {
            width: {
                get: function() {
                    return this.x
                },
                set: function(t) {
                    this.x = t
                }
            },
            height: {
                get: function() {
                    return this.y
                },
                set: function(t) {
                    this.y = t
                }
            }
        }), Object.assign(Dr.prototype, {
            isVector2: !0,
            set: function(t, e) {
                return this.x = t, this.y = e, this
            },
            setScalar: function(t) {
                return this.x = t, this.y = t, this
            },
            setX: function(t) {
                return this.x = t, this
            },
            setY: function(t) {
                return this.y = t, this
            },
            setComponent: function(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            },
            getComponent: function(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            },
            clone: function() {
                return new this.constructor(this.x, this.y)
            },
            copy: function(t) {
                return this.x = t.x, this.y = t.y, this
            },
            add: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
            },
            addScalar: function(t) {
                return this.x += t, this.y += t, this
            },
            addVectors: function(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this
            },
            addScaledVector: function(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this
            },
            sub: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
            },
            subScalar: function(t) {
                return this.x -= t, this.y -= t, this
            },
            subVectors: function(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this
            },
            multiply: function(t) {
                return this.x *= t.x, this.y *= t.y, this
            },
            multiplyScalar: function(t) {
                return this.x *= t, this.y *= t, this
            },
            divide: function(t) {
                return this.x /= t.x, this.y /= t.y, this
            },
            divideScalar: function(t) {
                return this.multiplyScalar(1 / t)
            },
            applyMatrix3: function(t) {
                var e = this.x,
                    n = this.y,
                    i = t.elements;
                return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
            },
            min: function(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
            },
            max: function(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
            },
            clamp: function(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
            },
            clampScalar: function(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
            },
            clampLength: function(t, e) {
                var n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            },
            floor: function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            },
            ceil: function() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            },
            round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            },
            roundToZero: function() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
            },
            negate: function() {
                return this.x = -this.x, this.y = -this.y, this
            },
            dot: function(t) {
                return this.x * t.x + this.y * t.y
            },
            cross: function(t) {
                return this.x * t.y - this.y * t.x
            },
            lengthSq: function() {
                return this.x * this.x + this.y * this.y
            },
            length: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            },
            manhattanLength: function() {
                return Math.abs(this.x) + Math.abs(this.y)
            },
            normalize: function() {
                return this.divideScalar(this.length() || 1)
            },
            angle: function() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            },
            distanceTo: function(t) {
                return Math.sqrt(this.distanceToSquared(t))
            },
            distanceToSquared: function(t) {
                var e = this.x - t.x,
                    n = this.y - t.y;
                return e * e + n * n
            },
            manhattanDistanceTo: function(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            },
            setLength: function(t) {
                return this.normalize().multiplyScalar(t)
            },
            lerp: function(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
            },
            lerpVectors: function(t, e, n) {
                return this.subVectors(e, t).multiplyScalar(n).add(t)
            },
            equals: function(t) {
                return t.x === this.x && t.y === this.y
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
            },
            fromBufferAttribute: function(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
            },
            rotateAround: function(t, e) {
                var n = Math.cos(e),
                    i = Math.sin(e),
                    r = this.x - t.x,
                    a = this.y - t.y;
                return this.x = r * n - a * i + t.x, this.y = r * i + a * n + t.y, this
            },
            random: function() {
                return this.x = Math.random(), this.y = Math.random(), this
            }
        }), Object.assign(Sr.prototype, {
            isMatrix3: !0,
            set: function(t, e, n, i, r, a, s, o, l) {
                var h = this.elements;
                return h[0] = t, h[1] = i, h[2] = s, h[3] = e, h[4] = r, h[5] = o, h[6] = n, h[7] = a, h[8] = l, this
            },
            identity: function() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            },
            clone: function() {
                return (new this.constructor).fromArray(this.elements)
            },
            copy: function(t) {
                var e = this.elements,
                    n = t.elements;
                return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
            },
            extractBasis: function(t, e, n) {
                return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
            },
            setFromMatrix4: function(t) {
                var e = t.elements;
                return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
            },
            multiply: function(t) {
                return this.multiplyMatrices(this, t)
            },
            premultiply: function(t) {
                return this.multiplyMatrices(t, this)
            },
            multiplyMatrices: function(t, e) {
                var n = t.elements,
                    i = e.elements,
                    r = this.elements,
                    a = n[0],
                    s = n[3],
                    o = n[6],
                    l = n[1],
                    h = n[4],
                    u = n[7],
                    c = n[2],
                    p = n[5],
                    f = n[8],
                    d = i[0],
                    m = i[3],
                    g = i[6],
                    v = i[1],
                    y = i[4],
                    _ = i[7],
                    x = i[2],
                    b = i[5],
                    E = i[8];
                return r[0] = a * d + s * v + o * x, r[3] = a * m + s * y + o * b, r[6] = a * g + s * _ + o * E, r[1] = l * d + h * v + u * x, r[4] = l * m + h * y + u * b, r[7] = l * g + h * _ + u * E, r[2] = c * d + p * v + f * x, r[5] = c * m + p * y + f * b, r[8] = c * g + p * _ + f * E, this
            },
            multiplyScalar: function(t) {
                var e = this.elements;
                return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
            },
            determinant: function() {
                var t = this.elements,
                    e = t[0],
                    n = t[1],
                    i = t[2],
                    r = t[3],
                    a = t[4],
                    s = t[5],
                    o = t[6],
                    l = t[7],
                    h = t[8];
                return e * a * h - e * s * l - n * r * h + n * s * o + i * r * l - i * a * o
            },
            getInverse: function(t, e) {
                void 0 !== e && console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");
                var n = t.elements,
                    i = this.elements,
                    r = n[0],
                    a = n[1],
                    s = n[2],
                    o = n[3],
                    l = n[4],
                    h = n[5],
                    u = n[6],
                    c = n[7],
                    p = n[8],
                    f = p * l - h * c,
                    d = h * u - p * o,
                    m = c * o - l * u,
                    g = r * f + a * d + s * m;
                if (0 === g) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                var v = 1 / g;
                return i[0] = f * v, i[1] = (s * c - p * a) * v, i[2] = (h * a - s * l) * v, i[3] = d * v, i[4] = (p * r - s * u) * v, i[5] = (s * o - h * r) * v, i[6] = m * v, i[7] = (a * u - c * r) * v, i[8] = (l * r - a * o) * v, this
            },
            transpose: function() {
                var t, e = this.elements;
                return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
            },
            getNormalMatrix: function(t) {
                return this.setFromMatrix4(t).getInverse(this).transpose()
            },
            transposeIntoArray: function(t) {
                var e = this.elements;
                return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
            },
            setUvTransform: function(t, e, n, i, r, a, s) {
                var o = Math.cos(r),
                    l = Math.sin(r);
                this.set(n * o, n * l, -n * (o * a + l * s) + a + t, -i * l, i * o, -i * (-l * a + o * s) + s + e, 0, 0, 1)
            },
            scale: function(t, e) {
                var n = this.elements;
                return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
            },
            rotate: function(t) {
                var e = Math.cos(t),
                    n = Math.sin(t),
                    i = this.elements,
                    r = i[0],
                    a = i[3],
                    s = i[6],
                    o = i[1],
                    l = i[4],
                    h = i[7];
                return i[0] = e * r + n * o, i[3] = e * a + n * l, i[6] = e * s + n * h, i[1] = -n * r + e * o, i[4] = -n * a + e * l, i[7] = -n * s + e * h, this
            },
            translate: function(t, e) {
                var n = this.elements;
                return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
            },
            equals: function(t) {
                for (var e = this.elements, n = t.elements, i = 0; i < 9; i++)
                    if (e[i] !== n[i]) return !1;
                return !0
            },
            fromArray: function(t, e) {
                void 0 === e && (e = 0);
                for (var n = 0; n < 9; n++) this.elements[n] = t[n + e];
                return this
            },
            toArray: function(t, e) {
                void 0 === t && (t = []), void 0 === e && (e = 0);
                var n = this.elements;
                return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
            }
        });
        var Mr = function(t) {
                var e;
                if ("undefined" == typeof HTMLCanvasElement) return t.src;
                if (t instanceof HTMLCanvasElement) e = t;
                else {
                    void 0 === br && (br = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), br.width = t.width, br.height = t.height;
                    var n = br.getContext("2d");
                    t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = br
                }
                return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
            },
            Tr = 0;

        function Ar(t, e, n, i, r, a, s, o, l, h) {
            Object.defineProperty(this, "id", {
                value: Tr++
            }), this.uuid = Er.generateUUID(), this.name = "", this.image = void 0 !== t ? t : Ar.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : Ar.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : 1001, this.wrapT = void 0 !== i ? i : 1001, this.magFilter = void 0 !== r ? r : 1006, this.minFilter = void 0 !== a ? a : 1008, this.anisotropy = void 0 !== l ? l : 1, this.format = void 0 !== s ? s : 1023, this.internalFormat = null, this.type = void 0 !== o ? o : 1009, this.offset = new Dr(0, 0), this.repeat = new Dr(1, 1), this.center = new Dr(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Sr, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== h ? h : 3e3, this.version = 0, this.onUpdate = null
        }

        function Cr(t, e, n, i, r, a, s, o, l, h, u, c) {
            Ar.call(this, null, a, s, o, l, h, i, r, u, c), this.image = {
                data: t || null,
                width: e || 1,
                height: n || 1
            }, this.magFilter = void 0 !== l ? l : 1003, this.minFilter = void 0 !== h ? h : 1003, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
        }

        function Pr(t, e, n, i) {
            this._x = t || 0, this._y = e || 0, this._z = n || 0, this._w = void 0 !== i ? i : 1
        }
        Ar.DEFAULT_IMAGE = void 0, Ar.DEFAULT_MAPPING = 300, Ar.prototype = Object.assign(Object.create(wr.prototype), {
            constructor: Ar,
            isTexture: !0,
            updateMatrix: function() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
            },
            toJSON: function(t) {
                var e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                var n = {
                    metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                if (void 0 !== this.image) {
                    var i = this.image;
                    if (void 0 === i.uuid && (i.uuid = Er.generateUUID()), !e && void 0 === t.images[i.uuid]) {
                        var r;
                        if (Array.isArray(i)) {
                            r = [];
                            for (var a = 0, s = i.length; a < s; a++) r.push(Mr(i[a]))
                        } else r = Mr(i);
                        t.images[i.uuid] = {
                            uuid: i.uuid,
                            url: r
                        }
                    }
                    n.image = i.uuid
                }
                return e || (t.textures[this.uuid] = n), n
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            },
            transformUv: function(t) {
                if (300 !== this.mapping) return t;
                if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                    case 1e3:
                        t.x = t.x - Math.floor(t.x);
                        break;
                    case 1001:
                        t.x = t.x < 0 ? 0 : 1;
                        break;
                    case 1002:
                        1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                }
                if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                    case 1e3:
                        t.y = t.y - Math.floor(t.y);
                        break;
                    case 1001:
                        t.y = t.y < 0 ? 0 : 1;
                        break;
                    case 1002:
                        1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                }
                return this.flipY && (t.y = 1 - t.y), t
            }
        }), Object.defineProperty(Ar.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }), Cr.prototype = Object.create(Ar.prototype), Cr.prototype.constructor = Cr, Cr.prototype.isDataTexture = !0, Object.assign(Pr, {
            slerp: function(t, e, n, i) {
                return n.copy(t).slerp(e, i)
            },
            slerpFlat: function(t, e, n, i, r, a, s) {
                var o = n[i + 0],
                    l = n[i + 1],
                    h = n[i + 2],
                    u = n[i + 3],
                    c = r[a + 0],
                    p = r[a + 1],
                    f = r[a + 2],
                    d = r[a + 3];
                if (u !== d || o !== c || l !== p || h !== f) {
                    var m = 1 - s,
                        g = o * c + l * p + h * f + u * d,
                        v = g >= 0 ? 1 : -1,
                        y = 1 - g * g;
                    if (y > Number.EPSILON) {
                        var _ = Math.sqrt(y),
                            x = Math.atan2(_, g * v);
                        m = Math.sin(m * x) / _, s = Math.sin(s * x) / _
                    }
                    var b = s * v;
                    if (o = o * m + c * b, l = l * m + p * b, h = h * m + f * b, u = u * m + d * b, m === 1 - s) {
                        var E = 1 / Math.sqrt(o * o + l * l + h * h + u * u);
                        o *= E, l *= E, h *= E, u *= E
                    }
                }
                t[e] = o, t[e + 1] = l, t[e + 2] = h, t[e + 3] = u
            },
            multiplyQuaternionsFlat: function(t, e, n, i, r, a) {
                var s = n[i],
                    o = n[i + 1],
                    l = n[i + 2],
                    h = n[i + 3],
                    u = r[a],
                    c = r[a + 1],
                    p = r[a + 2],
                    f = r[a + 3];
                return t[e] = s * f + h * u + o * p - l * c, t[e + 1] = o * f + h * c + l * u - s * p, t[e + 2] = l * f + h * p + s * c - o * u, t[e + 3] = h * f - s * u - o * c - l * p, t
            }
        }), Object.defineProperties(Pr.prototype, {
            x: {
                get: function() {
                    return this._x
                },
                set: function(t) {
                    this._x = t, this._onChangeCallback()
                }
            },
            y: {
                get: function() {
                    return this._y
                },
                set: function(t) {
                    this._y = t, this._onChangeCallback()
                }
            },
            z: {
                get: function() {
                    return this._z
                },
                set: function(t) {
                    this._z = t, this._onChangeCallback()
                }
            },
            w: {
                get: function() {
                    return this._w
                },
                set: function(t) {
                    this._w = t, this._onChangeCallback()
                }
            }
        }), Object.assign(Pr.prototype, {
            isQuaternion: !0,
            set: function(t, e, n, i) {
                return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this
            },
            clone: function() {
                return new this.constructor(this._x, this._y, this._z, this._w)
            },
            copy: function(t) {
                return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
            },
            setFromEuler: function(t, e) {
                if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                var n = t._x,
                    i = t._y,
                    r = t._z,
                    a = t.order,
                    s = Math.cos,
                    o = Math.sin,
                    l = s(n / 2),
                    h = s(i / 2),
                    u = s(r / 2),
                    c = o(n / 2),
                    p = o(i / 2),
                    f = o(r / 2);
                switch (a) {
                    case "XYZ":
                        this._x = c * h * u + l * p * f, this._y = l * p * u - c * h * f, this._z = l * h * f + c * p * u, this._w = l * h * u - c * p * f;
                        break;
                    case "YXZ":
                        this._x = c * h * u + l * p * f, this._y = l * p * u - c * h * f, this._z = l * h * f - c * p * u, this._w = l * h * u + c * p * f;
                        break;
                    case "ZXY":
                        this._x = c * h * u - l * p * f, this._y = l * p * u + c * h * f, this._z = l * h * f + c * p * u, this._w = l * h * u - c * p * f;
                        break;
                    case "ZYX":
                        this._x = c * h * u - l * p * f, this._y = l * p * u + c * h * f, this._z = l * h * f - c * p * u, this._w = l * h * u + c * p * f;
                        break;
                    case "YZX":
                        this._x = c * h * u + l * p * f, this._y = l * p * u + c * h * f, this._z = l * h * f - c * p * u, this._w = l * h * u - c * p * f;
                        break;
                    case "XZY":
                        this._x = c * h * u - l * p * f, this._y = l * p * u - c * h * f, this._z = l * h * f + c * p * u, this._w = l * h * u + c * p * f;
                        break;
                    default:
                        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
                }
                return !1 !== e && this._onChangeCallback(), this
            },
            setFromAxisAngle: function(t, e) {
                var n = e / 2,
                    i = Math.sin(n);
                return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
            },
            setFromRotationMatrix: function(t) {
                var e, n = t.elements,
                    i = n[0],
                    r = n[4],
                    a = n[8],
                    s = n[1],
                    o = n[5],
                    l = n[9],
                    h = n[2],
                    u = n[6],
                    c = n[10],
                    p = i + o + c;
                return p > 0 ? (e = .5 / Math.sqrt(p + 1), this._w = .25 / e, this._x = (u - l) * e, this._y = (a - h) * e, this._z = (s - r) * e) : i > o && i > c ? (e = 2 * Math.sqrt(1 + i - o - c), this._w = (u - l) / e, this._x = .25 * e, this._y = (r + s) / e, this._z = (a + h) / e) : o > c ? (e = 2 * Math.sqrt(1 + o - i - c), this._w = (a - h) / e, this._x = (r + s) / e, this._y = .25 * e, this._z = (l + u) / e) : (e = 2 * Math.sqrt(1 + c - i - o), this._w = (s - r) / e, this._x = (a + h) / e, this._y = (l + u) / e, this._z = .25 * e), this._onChangeCallback(), this
            },
            setFromUnitVectors: function(t, e) {
                var n = t.dot(e) + 1;
                return n < 1e-6 ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
            },
            angleTo: function(t) {
                return 2 * Math.acos(Math.abs(Er.clamp(this.dot(t), -1, 1)))
            },
            rotateTowards: function(t, e) {
                var n = this.angleTo(t);
                if (0 === n) return this;
                var i = Math.min(1, e / n);
                return this.slerp(t, i), this
            },
            inverse: function() {
                return this.conjugate()
            },
            conjugate: function() {
                return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
            },
            dot: function(t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            },
            lengthSq: function() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            },
            length: function() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            },
            normalize: function() {
                var t = this.length();
                return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
            },
            multiply: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
            },
            premultiply: function(t) {
                return this.multiplyQuaternions(t, this)
            },
            multiplyQuaternions: function(t, e) {
                var n = t._x,
                    i = t._y,
                    r = t._z,
                    a = t._w,
                    s = e._x,
                    o = e._y,
                    l = e._z,
                    h = e._w;
                return this._x = n * h + a * s + i * l - r * o, this._y = i * h + a * o + r * s - n * l, this._z = r * h + a * l + n * o - i * s, this._w = a * h - n * s - i * o - r * l, this._onChangeCallback(), this
            },
            slerp: function(t, e) {
                if (0 === e) return this;
                if (1 === e) return this.copy(t);
                var n = this._x,
                    i = this._y,
                    r = this._z,
                    a = this._w,
                    s = a * t._w + n * t._x + i * t._y + r * t._z;
                if (s < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, s = -s) : this.copy(t), s >= 1) return this._w = a, this._x = n, this._y = i, this._z = r, this;
                var o = 1 - s * s;
                if (o <= Number.EPSILON) {
                    var l = 1 - e;
                    return this._w = l * a + e * this._w, this._x = l * n + e * this._x, this._y = l * i + e * this._y, this._z = l * r + e * this._z, this.normalize(), this._onChangeCallback(), this
                }
                var h = Math.sqrt(o),
                    u = Math.atan2(h, s),
                    c = Math.sin((1 - e) * u) / h,
                    p = Math.sin(e * u) / h;
                return this._w = a * c + this._w * p, this._x = n * c + this._x * p, this._y = i * c + this._y * p, this._z = r * c + this._z * p, this._onChangeCallback(), this
            },
            equals: function(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
            },
            fromBufferAttribute: function(t, e) {
                return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
            },
            _onChange: function(t) {
                return this._onChangeCallback = t, this
            },
            _onChangeCallback: function() {}
        });
        var Fr = new Rr,
            Lr = new Pr;

        function Rr(t, e, n) {
            this.x = t || 0, this.y = e || 0, this.z = n || 0
        }
        Object.assign(Rr.prototype, {
            isVector3: !0,
            set: function(t, e, n) {
                return this.x = t, this.y = e, this.z = n, this
            },
            setScalar: function(t) {
                return this.x = t, this.y = t, this.z = t, this
            },
            setX: function(t) {
                return this.x = t, this
            },
            setY: function(t) {
                return this.y = t, this
            },
            setZ: function(t) {
                return this.z = t, this
            },
            setComponent: function(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            },
            getComponent: function(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            },
            clone: function() {
                return new this.constructor(this.x, this.y, this.z)
            },
            copy: function(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this
            },
            add: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
            },
            addScalar: function(t) {
                return this.x += t, this.y += t, this.z += t, this
            },
            addVectors: function(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
            },
            addScaledVector: function(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
            },
            sub: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
            },
            subScalar: function(t) {
                return this.x -= t, this.y -= t, this.z -= t, this
            },
            subVectors: function(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
            },
            multiply: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
            },
            multiplyScalar: function(t) {
                return this.x *= t, this.y *= t, this.z *= t, this
            },
            multiplyVectors: function(t, e) {
                return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
            },
            applyEuler: function(t) {
                return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Lr.setFromEuler(t))
            },
            applyAxisAngle: function(t, e) {
                return this.applyQuaternion(Lr.setFromAxisAngle(t, e))
            },
            applyMatrix3: function(t) {
                var e = this.x,
                    n = this.y,
                    i = this.z,
                    r = t.elements;
                return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
            },
            applyNormalMatrix: function(t) {
                return this.applyMatrix3(t).normalize()
            },
            applyMatrix4: function(t) {
                var e = this.x,
                    n = this.y,
                    i = this.z,
                    r = t.elements,
                    a = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * a, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * a, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * a, this
            },
            applyQuaternion: function(t) {
                var e = this.x,
                    n = this.y,
                    i = this.z,
                    r = t.x,
                    a = t.y,
                    s = t.z,
                    o = t.w,
                    l = o * e + a * i - s * n,
                    h = o * n + s * e - r * i,
                    u = o * i + r * n - a * e,
                    c = -r * e - a * n - s * i;
                return this.x = l * o + c * -r + h * -s - u * -a, this.y = h * o + c * -a + u * -r - l * -s, this.z = u * o + c * -s + l * -a - h * -r, this
            },
            project: function(t) {
                return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
            },
            unproject: function(t) {
                return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
            },
            transformDirection: function(t) {
                var e = this.x,
                    n = this.y,
                    i = this.z,
                    r = t.elements;
                return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize()
            },
            divide: function(t) {
                return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
            },
            divideScalar: function(t) {
                return this.multiplyScalar(1 / t)
            },
            min: function(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
            },
            max: function(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
            },
            clamp: function(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
            },
            clampScalar: function(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
            },
            clampLength: function(t, e) {
                var n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            },
            floor: function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            },
            ceil: function() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            },
            round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            },
            roundToZero: function() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
            },
            negate: function() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            },
            dot: function(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            },
            lengthSq: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            },
            length: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            },
            manhattanLength: function() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            },
            normalize: function() {
                return this.divideScalar(this.length() || 1)
            },
            setLength: function(t) {
                return this.normalize().multiplyScalar(t)
            },
            lerp: function(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
            },
            lerpVectors: function(t, e, n) {
                return this.subVectors(e, t).multiplyScalar(n).add(t)
            },
            cross: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
            },
            crossVectors: function(t, e) {
                var n = t.x,
                    i = t.y,
                    r = t.z,
                    a = e.x,
                    s = e.y,
                    o = e.z;
                return this.x = i * o - r * s, this.y = r * a - n * o, this.z = n * s - i * a, this
            },
            projectOnVector: function(t) {
                var e = t.lengthSq();
                if (0 === e) return this.set(0, 0, 0);
                var n = t.dot(this) / e;
                return this.copy(t).multiplyScalar(n)
            },
            projectOnPlane: function(t) {
                return Fr.copy(this).projectOnVector(t), this.sub(Fr)
            },
            reflect: function(t) {
                return this.sub(Fr.copy(t).multiplyScalar(2 * this.dot(t)))
            },
            angleTo: function(t) {
                var e = Math.sqrt(this.lengthSq() * t.lengthSq());
                if (0 === e) return Math.PI / 2;
                var n = this.dot(t) / e;
                return Math.acos(Er.clamp(n, -1, 1))
            },
            distanceTo: function(t) {
                return Math.sqrt(this.distanceToSquared(t))
            },
            distanceToSquared: function(t) {
                var e = this.x - t.x,
                    n = this.y - t.y,
                    i = this.z - t.z;
                return e * e + n * n + i * i
            },
            manhattanDistanceTo: function(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            },
            setFromSpherical: function(t) {
                return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
            },
            setFromSphericalCoords: function(t, e, n) {
                var i = Math.sin(e) * t;
                return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this
            },
            setFromCylindrical: function(t) {
                return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
            },
            setFromCylindricalCoords: function(t, e, n) {
                return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
            },
            setFromMatrixPosition: function(t) {
                var e = t.elements;
                return this.x = e[12], this.y = e[13], this.z = e[14], this
            },
            setFromMatrixScale: function(t) {
                var e = this.setFromMatrixColumn(t, 0).length(),
                    n = this.setFromMatrixColumn(t, 1).length(),
                    i = this.setFromMatrixColumn(t, 2).length();
                return this.x = e, this.y = n, this.z = i, this
            },
            setFromMatrixColumn: function(t, e) {
                return this.fromArray(t.elements, 4 * e)
            },
            setFromMatrix3Column: function(t, e) {
                return this.fromArray(t.elements, 3 * e)
            },
            equals: function(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
            },
            fromBufferAttribute: function(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
            },
            random: function() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
            }
        });
        var Ir = [new Rr, new Rr, new Rr, new Rr, new Rr, new Rr, new Rr, new Rr],
            kr = new Rr,
            Or = new qr,
            Nr = new Rr,
            Br = new Rr,
            zr = new Rr,
            Vr = new Rr,
            Ur = new Rr,
            Gr = new Rr,
            Hr = new Rr,
            jr = new Rr,
            Wr = new Rr,
            Xr = new Rr;

        function qr(t, e) {
            this.min = void 0 !== t ? t : new Rr(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Rr(-1 / 0, -1 / 0, -1 / 0)
        }

        function Yr(t, e, n, i, r) {
            var a, s;
            for (a = 0, s = t.length - 3; a <= s; a += 3) {
                Xr.fromArray(t, a);
                var o = r.x * Math.abs(Xr.x) + r.y * Math.abs(Xr.y) + r.z * Math.abs(Xr.z),
                    l = e.dot(Xr),
                    h = n.dot(Xr),
                    u = i.dot(Xr);
                if (Math.max(-Math.max(l, h, u), Math.min(l, h, u)) > o) return !1
            }
            return !0
        }
        Object.assign(qr.prototype, {
            isBox3: !0,
            set: function(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            },
            setFromArray: function(t) {
                for (var e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, a = -1 / 0, s = -1 / 0, o = 0, l = t.length; o < l; o += 3) {
                    var h = t[o],
                        u = t[o + 1],
                        c = t[o + 2];
                    h < e && (e = h), u < n && (n = u), c < i && (i = c), h > r && (r = h), u > a && (a = u), c > s && (s = c)
                }
                return this.min.set(e, n, i), this.max.set(r, a, s), this
            },
            setFromBufferAttribute: function(t) {
                for (var e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, a = -1 / 0, s = -1 / 0, o = 0, l = t.count; o < l; o++) {
                    var h = t.getX(o),
                        u = t.getY(o),
                        c = t.getZ(o);
                    h < e && (e = h), u < n && (n = u), c < i && (i = c), h > r && (r = h), u > a && (a = u), c > s && (s = c)
                }
                return this.min.set(e, n, i), this.max.set(r, a, s), this
            },
            setFromPoints: function(t) {
                this.makeEmpty();
                for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                return this
            },
            setFromCenterAndSize: function(t, e) {
                var n = kr.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
            },
            setFromObject: function(t) {
                return this.makeEmpty(), this.expandByObject(t)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            },
            makeEmpty: function() {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
            },
            isEmpty: function() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            },
            getCenter: function(t) {
                return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new Rr), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            },
            getSize: function(t) {
                return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new Rr), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            },
            expandByPoint: function(t) {
                return this.min.min(t), this.max.max(t), this
            },
            expandByVector: function(t) {
                return this.min.sub(t), this.max.add(t), this
            },
            expandByScalar: function(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            },
            expandByObject: function(t) {
                t.updateWorldMatrix(!1, !1);
                var e = t.geometry;
                void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), Or.copy(e.boundingBox), Or.applyMatrix4(t.matrixWorld), this.union(Or));
                for (var n = t.children, i = 0, r = n.length; i < r; i++) this.expandByObject(n[i]);
                return this
            },
            containsPoint: function(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            },
            containsBox: function(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            },
            getParameter: function(t, e) {
                return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new Rr), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            },
            intersectsBox: function(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            },
            intersectsSphere: function(t) {
                return this.clampPoint(t.center, kr), kr.distanceToSquared(t.center) <= t.radius * t.radius
            },
            intersectsPlane: function(t) {
                var e, n;
                return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
            },
            intersectsTriangle: function(t) {
                if (this.isEmpty()) return !1;
                this.getCenter(Hr), jr.subVectors(this.max, Hr), Nr.subVectors(t.a, Hr), Br.subVectors(t.b, Hr), zr.subVectors(t.c, Hr), Vr.subVectors(Br, Nr), Ur.subVectors(zr, Br), Gr.subVectors(Nr, zr);
                var e = [0, -Vr.z, Vr.y, 0, -Ur.z, Ur.y, 0, -Gr.z, Gr.y, Vr.z, 0, -Vr.x, Ur.z, 0, -Ur.x, Gr.z, 0, -Gr.x, -Vr.y, Vr.x, 0, -Ur.y, Ur.x, 0, -Gr.y, Gr.x, 0];
                return !!Yr(e, Nr, Br, zr, jr) && (!!Yr(e = [1, 0, 0, 0, 1, 0, 0, 0, 1], Nr, Br, zr, jr) && (Wr.crossVectors(Vr, Ur), Yr(e = [Wr.x, Wr.y, Wr.z], Nr, Br, zr, jr)))
            },
            clampPoint: function(t, e) {
                return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new Rr), e.copy(t).clamp(this.min, this.max)
            },
            distanceToPoint: function(t) {
                return kr.copy(t).clamp(this.min, this.max).sub(t).length()
            },
            getBoundingSphere: function(t) {
                return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(kr).length(), t
            },
            intersect: function(t) {
                return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
            },
            union: function(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            },
            applyMatrix4: function(t) {
                return this.isEmpty() || (Ir[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Ir[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Ir[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Ir[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Ir[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Ir[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Ir[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Ir[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Ir)), this
            },
            translate: function(t) {
                return this.min.add(t), this.max.add(t), this
            },
            equals: function(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        });
        var Zr = new qr;

        function Jr(t, e) {
            this.center = void 0 !== t ? t : new Rr, this.radius = void 0 !== e ? e : -1
        }
        Object.assign(Jr.prototype, {
            set: function(t, e) {
                return this.center.copy(t), this.radius = e, this
            },
            setFromPoints: function(t, e) {
                var n = this.center;
                void 0 !== e ? n.copy(e) : Zr.setFromPoints(t).getCenter(n);
                for (var i = 0, r = 0, a = t.length; r < a; r++) i = Math.max(i, n.distanceToSquared(t[r]));
                return this.radius = Math.sqrt(i), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.center.copy(t.center), this.radius = t.radius, this
            },
            isEmpty: function() {
                return this.radius < 0
            },
            makeEmpty: function() {
                return this.center.set(0, 0, 0), this.radius = -1, this
            },
            containsPoint: function(t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            },
            distanceToPoint: function(t) {
                return t.distanceTo(this.center) - this.radius
            },
            intersectsSphere: function(t) {
                var e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            },
            intersectsBox: function(t) {
                return t.intersectsSphere(this)
            },
            intersectsPlane: function(t) {
                return Math.abs(t.distanceToPoint(this.center)) <= this.radius
            },
            clampPoint: function(t, e) {
                var n = this.center.distanceToSquared(t);
                return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new Rr), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
            },
            getBoundingBox: function(t) {
                return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new qr), this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
            },
            applyMatrix4: function(t) {
                return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
            },
            translate: function(t) {
                return this.center.add(t), this
            },
            equals: function(t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
        });
        var Kr = new Rr,
            $r = new Rr,
            Qr = new Sr;

        function ta(t, e) {
            this.normal = void 0 !== t ? t : new Rr(1, 0, 0), this.constant = void 0 !== e ? e : 0
        }
        Object.assign(ta.prototype, {
            isPlane: !0,
            set: function(t, e) {
                return this.normal.copy(t), this.constant = e, this
            },
            setComponents: function(t, e, n, i) {
                return this.normal.set(t, e, n), this.constant = i, this
            },
            setFromNormalAndCoplanarPoint: function(t, e) {
                return this.normal.copy(t), this.constant = -e.dot(this.normal), this
            },
            setFromCoplanarPoints: function(t, e, n) {
                var i = Kr.subVectors(n, e).cross($r.subVectors(t, e)).normalize();
                return this.setFromNormalAndCoplanarPoint(i, t), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.normal.copy(t.normal), this.constant = t.constant, this
            },
            normalize: function() {
                var t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t), this.constant *= t, this
            },
            negate: function() {
                return this.constant *= -1, this.normal.negate(), this
            },
            distanceToPoint: function(t) {
                return this.normal.dot(t) + this.constant
            },
            distanceToSphere: function(t) {
                return this.distanceToPoint(t.center) - t.radius
            },
            projectPoint: function(t, e) {
                return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new Rr), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
            },
            intersectLine: function(t, e) {
                void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new Rr);
                var n = t.delta(Kr),
                    i = this.normal.dot(n);
                if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
                var r = -(t.start.dot(this.normal) + this.constant) / i;
                return r < 0 || r > 1 ? void 0 : e.copy(n).multiplyScalar(r).add(t.start)
            },
            intersectsLine: function(t) {
                var e = this.distanceToPoint(t.start),
                    n = this.distanceToPoint(t.end);
                return e < 0 && n > 0 || n < 0 && e > 0
            },
            intersectsBox: function(t) {
                return t.intersectsPlane(this)
            },
            intersectsSphere: function(t) {
                return t.intersectsPlane(this)
            },
            coplanarPoint: function(t) {
                return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new Rr), t.copy(this.normal).multiplyScalar(-this.constant)
            },
            applyMatrix4: function(t, e) {
                var n = e || Qr.getNormalMatrix(t),
                    i = this.coplanarPoint(Kr).applyMatrix4(t),
                    r = this.normal.applyMatrix3(n).normalize();
                return this.constant = -i.dot(r), this
            },
            translate: function(t) {
                return this.constant -= t.dot(this.normal), this
            },
            equals: function(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
        });
        var ea = new Jr,
            na = new Rr;

        function ia(t, e, n, i, r, a) {
            this.planes = [void 0 !== t ? t : new ta, void 0 !== e ? e : new ta, void 0 !== n ? n : new ta, void 0 !== i ? i : new ta, void 0 !== r ? r : new ta, void 0 !== a ? a : new ta]
        }
        Object.assign(ia.prototype, {
            set: function(t, e, n, i, r, a) {
                var s = this.planes;
                return s[0].copy(t), s[1].copy(e), s[2].copy(n), s[3].copy(i), s[4].copy(r), s[5].copy(a), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                for (var e = this.planes, n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                return this
            },
            setFromProjectionMatrix: function(t) {
                var e = this.planes,
                    n = t.elements,
                    i = n[0],
                    r = n[1],
                    a = n[2],
                    s = n[3],
                    o = n[4],
                    l = n[5],
                    h = n[6],
                    u = n[7],
                    c = n[8],
                    p = n[9],
                    f = n[10],
                    d = n[11],
                    m = n[12],
                    g = n[13],
                    v = n[14],
                    y = n[15];
                return e[0].setComponents(s - i, u - o, d - c, y - m).normalize(), e[1].setComponents(s + i, u + o, d + c, y + m).normalize(), e[2].setComponents(s + r, u + l, d + p, y + g).normalize(), e[3].setComponents(s - r, u - l, d - p, y - g).normalize(), e[4].setComponents(s - a, u - h, d - f, y - v).normalize(), e[5].setComponents(s + a, u + h, d + f, y + v).normalize(), this
            },
            intersectsObject: function(t) {
                var e = t.geometry;
                return null === e.boundingSphere && e.computeBoundingSphere(), ea.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(ea)
            },
            intersectsSprite: function(t) {
                return ea.center.set(0, 0, 0), ea.radius = .7071067811865476, ea.applyMatrix4(t.matrixWorld), this.intersectsSphere(ea)
            },
            intersectsSphere: function(t) {
                for (var e = this.planes, n = t.center, i = -t.radius, r = 0; r < 6; r++) {
                    if (e[r].distanceToPoint(n) < i) return !1
                }
                return !0
            },
            intersectsBox: function(t) {
                for (var e = this.planes, n = 0; n < 6; n++) {
                    var i = e[n];
                    if (na.x = i.normal.x > 0 ? t.max.x : t.min.x, na.y = i.normal.y > 0 ? t.max.y : t.min.y, na.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(na) < 0) return !1
                }
                return !0
            },
            containsPoint: function(t) {
                for (var e = this.planes, n = 0; n < 6; n++)
                    if (e[n].distanceToPoint(t) < 0) return !1;
                return !0
            }
        });
        var ra = new Rr,
            aa = new ca,
            sa = new Rr(0, 0, 0),
            oa = new Rr(1, 1, 1),
            la = new Rr,
            ha = new Rr,
            ua = new Rr;

        function ca() {
            this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
        }
        Object.assign(ca.prototype, {
            isMatrix4: !0,
            set: function(t, e, n, i, r, a, s, o, l, h, u, c, p, f, d, m) {
                var g = this.elements;
                return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = a, g[9] = s, g[13] = o, g[2] = l, g[6] = h, g[10] = u, g[14] = c, g[3] = p, g[7] = f, g[11] = d, g[15] = m, this
            },
            identity: function() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            },
            clone: function() {
                return (new ca).fromArray(this.elements)
            },
            copy: function(t) {
                var e = this.elements,
                    n = t.elements;
                return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
            },
            copyPosition: function(t) {
                var e = this.elements,
                    n = t.elements;
                return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
            },
            extractBasis: function(t, e, n) {
                return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
            },
            makeBasis: function(t, e, n) {
                return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
            },
            extractRotation: function(t) {
                var e = this.elements,
                    n = t.elements,
                    i = 1 / ra.setFromMatrixColumn(t, 0).length(),
                    r = 1 / ra.setFromMatrixColumn(t, 1).length(),
                    a = 1 / ra.setFromMatrixColumn(t, 2).length();
                return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * a, e[9] = n[9] * a, e[10] = n[10] * a, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            },
            makeRotationFromEuler: function(t) {
                t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                var e = this.elements,
                    n = t.x,
                    i = t.y,
                    r = t.z,
                    a = Math.cos(n),
                    s = Math.sin(n),
                    o = Math.cos(i),
                    l = Math.sin(i),
                    h = Math.cos(r),
                    u = Math.sin(r);
                if ("XYZ" === t.order) {
                    var c = a * h,
                        p = a * u,
                        f = s * h,
                        d = s * u;
                    e[0] = o * h, e[4] = -o * u, e[8] = l, e[1] = p + f * l, e[5] = c - d * l, e[9] = -s * o, e[2] = d - c * l, e[6] = f + p * l, e[10] = a * o
                } else if ("YXZ" === t.order) {
                    var m = o * h,
                        g = o * u,
                        v = l * h,
                        y = l * u;
                    e[0] = m + y * s, e[4] = v * s - g, e[8] = a * l, e[1] = a * u, e[5] = a * h, e[9] = -s, e[2] = g * s - v, e[6] = y + m * s, e[10] = a * o
                } else if ("ZXY" === t.order) {
                    m = o * h, g = o * u, v = l * h, y = l * u;
                    e[0] = m - y * s, e[4] = -a * u, e[8] = v + g * s, e[1] = g + v * s, e[5] = a * h, e[9] = y - m * s, e[2] = -a * l, e[6] = s, e[10] = a * o
                } else if ("ZYX" === t.order) {
                    c = a * h, p = a * u, f = s * h, d = s * u;
                    e[0] = o * h, e[4] = f * l - p, e[8] = c * l + d, e[1] = o * u, e[5] = d * l + c, e[9] = p * l - f, e[2] = -l, e[6] = s * o, e[10] = a * o
                } else if ("YZX" === t.order) {
                    var _ = a * o,
                        x = a * l,
                        b = s * o,
                        E = s * l;
                    e[0] = o * h, e[4] = E - _ * u, e[8] = b * u + x, e[1] = u, e[5] = a * h, e[9] = -s * h, e[2] = -l * h, e[6] = x * u + b, e[10] = _ - E * u
                } else if ("XZY" === t.order) {
                    _ = a * o, x = a * l, b = s * o, E = s * l;
                    e[0] = o * h, e[4] = -u, e[8] = l * h, e[1] = _ * u + E, e[5] = a * h, e[9] = x * u - b, e[2] = b * u - x, e[6] = s * h, e[10] = E * u + _
                }
                return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            },
            makeRotationFromQuaternion: function(t) {
                return this.compose(sa, t, oa)
            },
            lookAt: function(t, e, n) {
                var i = this.elements;
                return ua.subVectors(t, e), 0 === ua.lengthSq() && (ua.z = 1), ua.normalize(), la.crossVectors(n, ua), 0 === la.lengthSq() && (1 === Math.abs(n.z) ? ua.x += 1e-4 : ua.z += 1e-4, ua.normalize(), la.crossVectors(n, ua)), la.normalize(), ha.crossVectors(ua, la), i[0] = la.x, i[4] = ha.x, i[8] = ua.x, i[1] = la.y, i[5] = ha.y, i[9] = ua.y, i[2] = la.z, i[6] = ha.z, i[10] = ua.z, this
            },
            multiply: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
            },
            premultiply: function(t) {
                return this.multiplyMatrices(t, this)
            },
            multiplyMatrices: function(t, e) {
                var n = t.elements,
                    i = e.elements,
                    r = this.elements,
                    a = n[0],
                    s = n[4],
                    o = n[8],
                    l = n[12],
                    h = n[1],
                    u = n[5],
                    c = n[9],
                    p = n[13],
                    f = n[2],
                    d = n[6],
                    m = n[10],
                    g = n[14],
                    v = n[3],
                    y = n[7],
                    _ = n[11],
                    x = n[15],
                    b = i[0],
                    E = i[4],
                    w = i[8],
                    D = i[12],
                    S = i[1],
                    M = i[5],
                    T = i[9],
                    A = i[13],
                    C = i[2],
                    P = i[6],
                    F = i[10],
                    L = i[14],
                    R = i[3],
                    I = i[7],
                    k = i[11],
                    O = i[15];
                return r[0] = a * b + s * S + o * C + l * R, r[4] = a * E + s * M + o * P + l * I, r[8] = a * w + s * T + o * F + l * k, r[12] = a * D + s * A + o * L + l * O, r[1] = h * b + u * S + c * C + p * R, r[5] = h * E + u * M + c * P + p * I, r[9] = h * w + u * T + c * F + p * k, r[13] = h * D + u * A + c * L + p * O, r[2] = f * b + d * S + m * C + g * R, r[6] = f * E + d * M + m * P + g * I, r[10] = f * w + d * T + m * F + g * k, r[14] = f * D + d * A + m * L + g * O, r[3] = v * b + y * S + _ * C + x * R, r[7] = v * E + y * M + _ * P + x * I, r[11] = v * w + y * T + _ * F + x * k, r[15] = v * D + y * A + _ * L + x * O, this
            },
            multiplyScalar: function(t) {
                var e = this.elements;
                return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
            },
            determinant: function() {
                var t = this.elements,
                    e = t[0],
                    n = t[4],
                    i = t[8],
                    r = t[12],
                    a = t[1],
                    s = t[5],
                    o = t[9],
                    l = t[13],
                    h = t[2],
                    u = t[6],
                    c = t[10],
                    p = t[14];
                return t[3] * (+r * o * u - i * l * u - r * s * c + n * l * c + i * s * p - n * o * p) + t[7] * (+e * o * p - e * l * c + r * a * c - i * a * p + i * l * h - r * o * h) + t[11] * (+e * l * u - e * s * p - r * a * u + n * a * p + r * s * h - n * l * h) + t[15] * (-i * s * h - e * o * u + e * s * c + i * a * u - n * a * c + n * o * h)
            },
            transpose: function() {
                var t, e = this.elements;
                return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
            },
            setPosition: function(t, e, n) {
                var i = this.elements;
                return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this
            },
            getInverse: function(t, e) {
                void 0 !== e && console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");
                var n = this.elements,
                    i = t.elements,
                    r = i[0],
                    a = i[1],
                    s = i[2],
                    o = i[3],
                    l = i[4],
                    h = i[5],
                    u = i[6],
                    c = i[7],
                    p = i[8],
                    f = i[9],
                    d = i[10],
                    m = i[11],
                    g = i[12],
                    v = i[13],
                    y = i[14],
                    _ = i[15],
                    x = f * y * c - v * d * c + v * u * m - h * y * m - f * u * _ + h * d * _,
                    b = g * d * c - p * y * c - g * u * m + l * y * m + p * u * _ - l * d * _,
                    E = p * v * c - g * f * c + g * h * m - l * v * m - p * h * _ + l * f * _,
                    w = g * f * u - p * v * u - g * h * d + l * v * d + p * h * y - l * f * y,
                    D = r * x + a * b + s * E + o * w;
                if (0 === D) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                var S = 1 / D;
                return n[0] = x * S, n[1] = (v * d * o - f * y * o - v * s * m + a * y * m + f * s * _ - a * d * _) * S, n[2] = (h * y * o - v * u * o + v * s * c - a * y * c - h * s * _ + a * u * _) * S, n[3] = (f * u * o - h * d * o - f * s * c + a * d * c + h * s * m - a * u * m) * S, n[4] = b * S, n[5] = (p * y * o - g * d * o + g * s * m - r * y * m - p * s * _ + r * d * _) * S, n[6] = (g * u * o - l * y * o - g * s * c + r * y * c + l * s * _ - r * u * _) * S, n[7] = (l * d * o - p * u * o + p * s * c - r * d * c - l * s * m + r * u * m) * S, n[8] = E * S, n[9] = (g * f * o - p * v * o - g * a * m + r * v * m + p * a * _ - r * f * _) * S, n[10] = (l * v * o - g * h * o + g * a * c - r * v * c - l * a * _ + r * h * _) * S, n[11] = (p * h * o - l * f * o - p * a * c + r * f * c + l * a * m - r * h * m) * S, n[12] = w * S, n[13] = (p * v * s - g * f * s + g * a * d - r * v * d - p * a * y + r * f * y) * S, n[14] = (g * h * s - l * v * s - g * a * u + r * v * u + l * a * y - r * h * y) * S, n[15] = (l * f * s - p * h * s + p * a * u - r * f * u - l * a * d + r * h * d) * S, this
            },
            scale: function(t) {
                var e = this.elements,
                    n = t.x,
                    i = t.y,
                    r = t.z;
                return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this
            },
            getMaxScaleOnAxis: function() {
                var t = this.elements,
                    e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                    n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                    i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, n, i))
            },
            makeTranslation: function(t, e, n) {
                return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
            },
            makeRotationX: function(t) {
                var e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
            },
            makeRotationY: function(t) {
                var e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
            },
            makeRotationZ: function(t) {
                var e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            },
            makeRotationAxis: function(t, e) {
                var n = Math.cos(e),
                    i = Math.sin(e),
                    r = 1 - n,
                    a = t.x,
                    s = t.y,
                    o = t.z,
                    l = r * a,
                    h = r * s;
                return this.set(l * a + n, l * s - i * o, l * o + i * s, 0, l * s + i * o, h * s + n, h * o - i * a, 0, l * o - i * s, h * o + i * a, r * o * o + n, 0, 0, 0, 0, 1), this
            },
            makeScale: function(t, e, n) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            },
            makeShear: function(t, e, n) {
                return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this
            },
            compose: function(t, e, n) {
                var i = this.elements,
                    r = e._x,
                    a = e._y,
                    s = e._z,
                    o = e._w,
                    l = r + r,
                    h = a + a,
                    u = s + s,
                    c = r * l,
                    p = r * h,
                    f = r * u,
                    d = a * h,
                    m = a * u,
                    g = s * u,
                    v = o * l,
                    y = o * h,
                    _ = o * u,
                    x = n.x,
                    b = n.y,
                    E = n.z;
                return i[0] = (1 - (d + g)) * x, i[1] = (p + _) * x, i[2] = (f - y) * x, i[3] = 0, i[4] = (p - _) * b, i[5] = (1 - (c + g)) * b, i[6] = (m + v) * b, i[7] = 0, i[8] = (f + y) * E, i[9] = (m - v) * E, i[10] = (1 - (c + d)) * E, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
            },
            decompose: function(t, e, n) {
                var i = this.elements,
                    r = ra.set(i[0], i[1], i[2]).length(),
                    a = ra.set(i[4], i[5], i[6]).length(),
                    s = ra.set(i[8], i[9], i[10]).length();
                this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], aa.copy(this);
                var o = 1 / r,
                    l = 1 / a,
                    h = 1 / s;
                return aa.elements[0] *= o, aa.elements[1] *= o, aa.elements[2] *= o, aa.elements[4] *= l, aa.elements[5] *= l, aa.elements[6] *= l, aa.elements[8] *= h, aa.elements[9] *= h, aa.elements[10] *= h, e.setFromRotationMatrix(aa), n.x = r, n.y = a, n.z = s, this
            },
            makePerspective: function(t, e, n, i, r, a) {
                void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                var s = this.elements,
                    o = 2 * r / (e - t),
                    l = 2 * r / (n - i),
                    h = (e + t) / (e - t),
                    u = (n + i) / (n - i),
                    c = -(a + r) / (a - r),
                    p = -2 * a * r / (a - r);
                return s[0] = o, s[4] = 0, s[8] = h, s[12] = 0, s[1] = 0, s[5] = l, s[9] = u, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = c, s[14] = p, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this
            },
            makeOrthographic: function(t, e, n, i, r, a) {
                var s = this.elements,
                    o = 1 / (e - t),
                    l = 1 / (n - i),
                    h = 1 / (a - r),
                    u = (e + t) * o,
                    c = (n + i) * l,
                    p = (a + r) * h;
                return s[0] = 2 * o, s[4] = 0, s[8] = 0, s[12] = -u, s[1] = 0, s[5] = 2 * l, s[9] = 0, s[13] = -c, s[2] = 0, s[6] = 0, s[10] = -2 * h, s[14] = -p, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this
            },
            equals: function(t) {
                for (var e = this.elements, n = t.elements, i = 0; i < 16; i++)
                    if (e[i] !== n[i]) return !1;
                return !0
            },
            fromArray: function(t, e) {
                void 0 === e && (e = 0);
                for (var n = 0; n < 16; n++) this.elements[n] = t[n + e];
                return this
            },
            toArray: function(t, e) {
                void 0 === t && (t = []), void 0 === e && (e = 0);
                var n = this.elements;
                return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
            }
        });
        var pa = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            },
            fa = {
                h: 0,
                s: 0,
                l: 0
            },
            da = {
                h: 0,
                s: 0,
                l: 0
            };

        function ma(t, e, n) {
            return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
        }

        function ga(t, e, n) {
            return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
        }

        function va(t) {
            return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
        }

        function ya(t) {
            return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
        }
        Object.assign(ma.prototype, {
            isColor: !0,
            r: 1,
            g: 1,
            b: 1,
            set: function(t) {
                return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
            },
            setScalar: function(t) {
                return this.r = t, this.g = t, this.b = t, this
            },
            setHex: function(t) {
                return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
            },
            setRGB: function(t, e, n) {
                return this.r = t, this.g = e, this.b = n, this
            },
            setHSL: function(t, e, n) {
                if (t = Er.euclideanModulo(t, 1), e = Er.clamp(e, 0, 1), n = Er.clamp(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
                else {
                    var i = n <= .5 ? n * (1 + e) : n + e - n * e,
                        r = 2 * n - i;
                    this.r = ga(r, i, t + 1 / 3), this.g = ga(r, i, t), this.b = ga(r, i, t - 1 / 3)
                }
                return this
            },
            setStyle: function(t) {
                function e(e) {
                    void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                }
                var n;
                if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                    var i, r = n[1],
                        a = n[2];
                    switch (r) {
                        case "rgb":
                        case "rgba":
                            if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, e(i[5]), this;
                            if (i = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, e(i[5]), this;
                            break;
                        case "hsl":
                        case "hsla":
                            if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) {
                                var s = parseFloat(i[1]) / 360,
                                    o = parseInt(i[2], 10) / 100,
                                    l = parseInt(i[3], 10) / 100;
                                return e(i[5]), this.setHSL(s, o, l)
                            }
                    }
                } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                    var h = n[1],
                        u = h.length;
                    if (3 === u) return this.r = parseInt(h.charAt(0) + h.charAt(0), 16) / 255, this.g = parseInt(h.charAt(1) + h.charAt(1), 16) / 255, this.b = parseInt(h.charAt(2) + h.charAt(2), 16) / 255, this;
                    if (6 === u) return this.r = parseInt(h.charAt(0) + h.charAt(1), 16) / 255, this.g = parseInt(h.charAt(2) + h.charAt(3), 16) / 255, this.b = parseInt(h.charAt(4) + h.charAt(5), 16) / 255, this
                }
                return t && t.length > 0 ? this.setColorName(t) : this
            },
            setColorName: function(t) {
                var e = pa[t];
                return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this
            },
            clone: function() {
                return new this.constructor(this.r, this.g, this.b)
            },
            copy: function(t) {
                return this.r = t.r, this.g = t.g, this.b = t.b, this
            },
            copyGammaToLinear: function(t, e) {
                return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
            },
            copyLinearToGamma: function(t, e) {
                void 0 === e && (e = 2);
                var n = e > 0 ? 1 / e : 1;
                return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this
            },
            convertGammaToLinear: function(t) {
                return this.copyGammaToLinear(this, t), this
            },
            convertLinearToGamma: function(t) {
                return this.copyLinearToGamma(this, t), this
            },
            copySRGBToLinear: function(t) {
                return this.r = va(t.r), this.g = va(t.g), this.b = va(t.b), this
            },
            copyLinearToSRGB: function(t) {
                return this.r = ya(t.r), this.g = ya(t.g), this.b = ya(t.b), this
            },
            convertSRGBToLinear: function() {
                return this.copySRGBToLinear(this), this
            },
            convertLinearToSRGB: function() {
                return this.copyLinearToSRGB(this), this
            },
            getHex: function() {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            },
            getHexString: function() {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            },
            getHSL: function(t) {
                void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {
                    h: 0,
                    s: 0,
                    l: 0
                });
                var e, n, i = this.r,
                    r = this.g,
                    a = this.b,
                    s = Math.max(i, r, a),
                    o = Math.min(i, r, a),
                    l = (o + s) / 2;
                if (o === s) e = 0, n = 0;
                else {
                    var h = s - o;
                    switch (n = l <= .5 ? h / (s + o) : h / (2 - s - o), s) {
                        case i:
                            e = (r - a) / h + (r < a ? 6 : 0);
                            break;
                        case r:
                            e = (a - i) / h + 2;
                            break;
                        case a:
                            e = (i - r) / h + 4
                    }
                    e /= 6
                }
                return t.h = e, t.s = n, t.l = l, t
            },
            getStyle: function() {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            },
            offsetHSL: function(t, e, n) {
                return this.getHSL(fa), fa.h += t, fa.s += e, fa.l += n, this.setHSL(fa.h, fa.s, fa.l), this
            },
            add: function(t) {
                return this.r += t.r, this.g += t.g, this.b += t.b, this
            },
            addColors: function(t, e) {
                return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
            },
            addScalar: function(t) {
                return this.r += t, this.g += t, this.b += t, this
            },
            sub: function(t) {
                return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
            },
            multiply: function(t) {
                return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
            },
            multiplyScalar: function(t) {
                return this.r *= t, this.g *= t, this.b *= t, this
            },
            lerp: function(t, e) {
                return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
            },
            lerpHSL: function(t, e) {
                this.getHSL(fa), t.getHSL(da);
                var n = Er.lerp(fa.h, da.h, e),
                    i = Er.lerp(fa.s, da.s, e),
                    r = Er.lerp(fa.l, da.l, e);
                return this.setHSL(n, i, r), this
            },
            equals: function(t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
            },
            toJSON: function() {
                return this.getHex()
            }
        }), ma.NAMES = pa;
        var _a = {
            common: {
                diffuse: {
                    value: new ma(15658734)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new Sr
                },
                uv2Transform: {
                    value: new Sr
                },
                alphaMap: {
                    value: null
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                refractionRatio: {
                    value: .98
                },
                maxMipLevel: {
                    value: 0
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalScale: {
                    value: new Dr(1, 1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new ma(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotShadowMap: {
                    value: []
                },
                spotShadowMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                }
            },
            points: {
                diffuse: {
                    value: new ma(15658734)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                uvTransform: {
                    value: new Sr
                }
            },
            sprite: {
                diffuse: {
                    value: new ma(15658734)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new Dr(.5, .5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                uvTransform: {
                    value: new Sr
                }
            }
        };

        function xa(t, e, n, i) {
            this.x = t || 0, this.y = e || 0, this.z = n || 0, this.w = void 0 !== i ? i : 1
        }
        Object.defineProperties(xa.prototype, {
            width: {
                get: function() {
                    return this.z
                },
                set: function(t) {
                    this.z = t
                }
            },
            height: {
                get: function() {
                    return this.w
                },
                set: function(t) {
                    this.w = t
                }
            }
        }), Object.assign(xa.prototype, {
            isVector4: !0,
            set: function(t, e, n, i) {
                return this.x = t, this.y = e, this.z = n, this.w = i, this
            },
            setScalar: function(t) {
                return this.x = t, this.y = t, this.z = t, this.w = t, this
            },
            setX: function(t) {
                return this.x = t, this
            },
            setY: function(t) {
                return this.y = t, this
            },
            setZ: function(t) {
                return this.z = t, this
            },
            setW: function(t) {
                return this.w = t, this
            },
            setComponent: function(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    case 3:
                        this.w = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            },
            getComponent: function(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            },
            clone: function() {
                return new this.constructor(this.x, this.y, this.z, this.w)
            },
            copy: function(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
            },
            add: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
            },
            addScalar: function(t) {
                return this.x += t, this.y += t, this.z += t, this.w += t, this
            },
            addVectors: function(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
            },
            addScaledVector: function(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
            },
            sub: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
            },
            subScalar: function(t) {
                return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
            },
            subVectors: function(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
            },
            multiplyScalar: function(t) {
                return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
            },
            applyMatrix4: function(t) {
                var e = this.x,
                    n = this.y,
                    i = this.z,
                    r = this.w,
                    a = t.elements;
                return this.x = a[0] * e + a[4] * n + a[8] * i + a[12] * r, this.y = a[1] * e + a[5] * n + a[9] * i + a[13] * r, this.z = a[2] * e + a[6] * n + a[10] * i + a[14] * r, this.w = a[3] * e + a[7] * n + a[11] * i + a[15] * r, this
            },
            divideScalar: function(t) {
                return this.multiplyScalar(1 / t)
            },
            setAxisAngleFromQuaternion: function(t) {
                this.w = 2 * Math.acos(t.w);
                var e = Math.sqrt(1 - t.w * t.w);
                return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
            },
            setAxisAngleFromRotationMatrix: function(t) {
                var e, n, i, r, a = t.elements,
                    s = a[0],
                    o = a[4],
                    l = a[8],
                    h = a[1],
                    u = a[5],
                    c = a[9],
                    p = a[2],
                    f = a[6],
                    d = a[10];
                if (Math.abs(o - h) < .01 && Math.abs(l - p) < .01 && Math.abs(c - f) < .01) {
                    if (Math.abs(o + h) < .1 && Math.abs(l + p) < .1 && Math.abs(c + f) < .1 && Math.abs(s + u + d - 3) < .1) return this.set(1, 0, 0, 0), this;
                    e = Math.PI;
                    var m = (s + 1) / 2,
                        g = (u + 1) / 2,
                        v = (d + 1) / 2,
                        y = (o + h) / 4,
                        _ = (l + p) / 4,
                        x = (c + f) / 4;
                    return m > g && m > v ? m < .01 ? (n = 0, i = .707106781, r = .707106781) : (i = y / (n = Math.sqrt(m)), r = _ / n) : g > v ? g < .01 ? (n = .707106781, i = 0, r = .707106781) : (n = y / (i = Math.sqrt(g)), r = x / i) : v < .01 ? (n = .707106781, i = .707106781, r = 0) : (n = _ / (r = Math.sqrt(v)), i = x / r), this.set(n, i, r, e), this
                }
                var b = Math.sqrt((f - c) * (f - c) + (l - p) * (l - p) + (h - o) * (h - o));
                return Math.abs(b) < .001 && (b = 1), this.x = (f - c) / b, this.y = (l - p) / b, this.z = (h - o) / b, this.w = Math.acos((s + u + d - 1) / 2), this
            },
            min: function(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
            },
            max: function(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
            },
            clamp: function(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
            },
            clampScalar: function(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
            },
            clampLength: function(t, e) {
                var n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            },
            floor: function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            },
            ceil: function() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            },
            round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            },
            roundToZero: function() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
            },
            negate: function() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            },
            dot: function(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            },
            lengthSq: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            },
            length: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            },
            manhattanLength: function() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            },
            normalize: function() {
                return this.divideScalar(this.length() || 1)
            },
            setLength: function(t) {
                return this.normalize().multiplyScalar(t)
            },
            lerp: function(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
            },
            lerpVectors: function(t, e, n) {
                return this.subVectors(e, t).multiplyScalar(n).add(t)
            },
            equals: function(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
            },
            fromBufferAttribute: function(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
            },
            random: function() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
            }
        });
        var ba = new ca,
            Ea = new Pr;

        function wa(t, e, n, i) {
            this._x = t || 0, this._y = e || 0, this._z = n || 0, this._order = i || wa.DefaultOrder
        }

        function Da() {
            this.mask = 1
        }
        wa.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], wa.DefaultOrder = "XYZ", Object.defineProperties(wa.prototype, {
            x: {
                get: function() {
                    return this._x
                },
                set: function(t) {
                    this._x = t, this._onChangeCallback()
                }
            },
            y: {
                get: function() {
                    return this._y
                },
                set: function(t) {
                    this._y = t, this._onChangeCallback()
                }
            },
            z: {
                get: function() {
                    return this._z
                },
                set: function(t) {
                    this._z = t, this._onChangeCallback()
                }
            },
            order: {
                get: function() {
                    return this._order
                },
                set: function(t) {
                    this._order = t, this._onChangeCallback()
                }
            }
        }), Object.assign(wa.prototype, {
            isEuler: !0,
            set: function(t, e, n, i) {
                return this._x = t, this._y = e, this._z = n, this._order = i || this._order, this._onChangeCallback(), this
            },
            clone: function() {
                return new this.constructor(this._x, this._y, this._z, this._order)
            },
            copy: function(t) {
                return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
            },
            setFromRotationMatrix: function(t, e, n) {
                var i = Er.clamp,
                    r = t.elements,
                    a = r[0],
                    s = r[4],
                    o = r[8],
                    l = r[1],
                    h = r[5],
                    u = r[9],
                    c = r[2],
                    p = r[6],
                    f = r[10];
                switch (e = e || this._order) {
                    case "XYZ":
                        this._y = Math.asin(i(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-u, f), this._z = Math.atan2(-s, a)) : (this._x = Math.atan2(p, h), this._z = 0);
                        break;
                    case "YXZ":
                        this._x = Math.asin(-i(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(o, f), this._z = Math.atan2(l, h)) : (this._y = Math.atan2(-c, a), this._z = 0);
                        break;
                    case "ZXY":
                        this._x = Math.asin(i(p, -1, 1)), Math.abs(p) < .9999999 ? (this._y = Math.atan2(-c, f), this._z = Math.atan2(-s, h)) : (this._y = 0, this._z = Math.atan2(l, a));
                        break;
                    case "ZYX":
                        this._y = Math.asin(-i(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(p, f), this._z = Math.atan2(l, a)) : (this._x = 0, this._z = Math.atan2(-s, h));
                        break;
                    case "YZX":
                        this._z = Math.asin(i(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, h), this._y = Math.atan2(-c, a)) : (this._x = 0, this._y = Math.atan2(o, f));
                        break;
                    case "XZY":
                        this._z = Math.asin(-i(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(p, h), this._y = Math.atan2(o, a)) : (this._x = Math.atan2(-u, f), this._y = 0);
                        break;
                    default:
                        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                }
                return this._order = e, !1 !== n && this._onChangeCallback(), this
            },
            setFromQuaternion: function(t, e, n) {
                return ba.makeRotationFromQuaternion(t), this.setFromRotationMatrix(ba, e, n)
            },
            setFromVector3: function(t, e) {
                return this.set(t.x, t.y, t.z, e || this._order)
            },
            reorder: function(t) {
                return Ea.setFromEuler(this), this.setFromQuaternion(Ea, t)
            },
            equals: function(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            },
            fromArray: function(t) {
                return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
            },
            toVector3: function(t) {
                return t ? t.set(this._x, this._y, this._z) : new Rr(this._x, this._y, this._z)
            },
            _onChange: function(t) {
                return this._onChangeCallback = t, this
            },
            _onChangeCallback: function() {}
        }), Object.assign(Da.prototype, {
            set: function(t) {
                this.mask = 1 << t | 0
            },
            enable: function(t) {
                this.mask |= 1 << t | 0
            },
            enableAll: function() {
                this.mask = -1
            },
            toggle: function(t) {
                this.mask ^= 1 << t | 0
            },
            disable: function(t) {
                this.mask &= ~(1 << t | 0)
            },
            disableAll: function() {
                this.mask = 0
            },
            test: function(t) {
                return 0 != (this.mask & t.mask)
            }
        });
        var Sa = 0,
            Ma = new Rr,
            Ta = new Pr,
            Aa = new ca,
            Ca = new Rr,
            Pa = new Rr,
            Fa = new Rr,
            La = new Pr,
            Ra = new Rr(1, 0, 0),
            Ia = new Rr(0, 1, 0),
            ka = new Rr(0, 0, 1),
            Oa = {
                type: "added"
            },
            Na = {
                type: "removed"
            };

        function Ba() {
            Object.defineProperty(this, "id", {
                value: Sa++
            }), this.uuid = Er.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Ba.DefaultUp.clone();
            var t = new Rr,
                e = new wa,
                n = new Pr,
                i = new Rr(1, 1, 1);
            e._onChange((function() {
                n.setFromEuler(e, !1)
            })), n._onChange((function() {
                e.setFromQuaternion(n, void 0, !1)
            })), Object.defineProperties(this, {
                position: {
                    configurable: !0,
                    enumerable: !0,
                    value: t
                },
                rotation: {
                    configurable: !0,
                    enumerable: !0,
                    value: e
                },
                quaternion: {
                    configurable: !0,
                    enumerable: !0,
                    value: n
                },
                scale: {
                    configurable: !0,
                    enumerable: !0,
                    value: i
                },
                modelViewMatrix: {
                    value: new ca
                },
                normalMatrix: {
                    value: new Sr
                }
            }), this.matrix = new ca, this.matrixWorld = new ca, this.matrixAutoUpdate = Ba.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Da, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
        }

        function za() {
            Ba.call(this), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }

        function Va() {
            var t = null,
                e = !1,
                n = null;

            function i(r, a) {
                !1 !== e && (n(r, a), t.requestAnimationFrame(i))
            }
            return {
                start: function() {
                    !0 !== e && null !== n && (t.requestAnimationFrame(i), e = !0)
                },
                stop: function() {
                    e = !1
                },
                setAnimationLoop: function(t) {
                    n = t
                },
                setContext: function(e) {
                    t = e
                }
            }
        }

        function Ua(t, e) {
            var n = e.isWebGL2,
                i = new WeakMap;
            return {
                get: function(t) {
                    return t.isInterleavedBufferAttribute && (t = t.data), i.get(t)
                },
                remove: function(e) {
                    e.isInterleavedBufferAttribute && (e = e.data);
                    var n = i.get(e);
                    n && (t.deleteBuffer(n.buffer), i.delete(e))
                },
                update: function(e, r) {
                    e.isInterleavedBufferAttribute && (e = e.data);
                    var a = i.get(e);
                    void 0 === a ? i.set(e, function(e, n) {
                        var i = e.array,
                            r = e.usage,
                            a = t.createBuffer();
                        t.bindBuffer(n, a), t.bufferData(n, i, r), e.onUploadCallback();
                        var s = t.FLOAT;
                        return i instanceof Float32Array ? s = t.FLOAT : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? s = t.UNSIGNED_SHORT : i instanceof Int16Array ? s = t.SHORT : i instanceof Uint32Array ? s = t.UNSIGNED_INT : i instanceof Int32Array ? s = t.INT : i instanceof Int8Array ? s = t.BYTE : i instanceof Uint8Array && (s = t.UNSIGNED_BYTE), {
                            buffer: a,
                            type: s,
                            bytesPerElement: i.BYTES_PER_ELEMENT,
                            version: e.version
                        }
                    }(e, r)) : a.version < e.version && (! function(e, i, r) {
                        var a = i.array,
                            s = i.updateRange;
                        t.bindBuffer(r, e), -1 === s.count ? t.bufferSubData(r, 0, a) : (n ? t.bufferSubData(r, s.offset * a.BYTES_PER_ELEMENT, a, s.offset, s.count) : t.bufferSubData(r, s.offset * a.BYTES_PER_ELEMENT, a.subarray(s.offset, s.offset + s.count)), s.count = -1)
                    }(a.buffer, e, r), a.version = e.version)
                }
            }
        }

        function Ga(t, e, n, i, r, a) {
            this.a = t, this.b = e, this.c = n, this.normal = i && i.isVector3 ? i : new Rr, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new ma, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== a ? a : 0
        }
        Ba.DefaultUp = new Rr(0, 1, 0), Ba.DefaultMatrixAutoUpdate = !0, Ba.prototype = Object.assign(Object.create(wr.prototype), {
            constructor: Ba,
            isObject3D: !0,
            onBeforeRender: function() {},
            onAfterRender: function() {},
            applyMatrix4: function(t) {
                this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
            },
            applyQuaternion: function(t) {
                return this.quaternion.premultiply(t), this
            },
            setRotationFromAxisAngle: function(t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            },
            setRotationFromEuler: function(t) {
                this.quaternion.setFromEuler(t, !0)
            },
            setRotationFromMatrix: function(t) {
                this.quaternion.setFromRotationMatrix(t)
            },
            setRotationFromQuaternion: function(t) {
                this.quaternion.copy(t)
            },
            rotateOnAxis: function(t, e) {
                return Ta.setFromAxisAngle(t, e), this.quaternion.multiply(Ta), this
            },
            rotateOnWorldAxis: function(t, e) {
                return Ta.setFromAxisAngle(t, e), this.quaternion.premultiply(Ta), this
            },
            rotateX: function(t) {
                return this.rotateOnAxis(Ra, t)
            },
            rotateY: function(t) {
                return this.rotateOnAxis(Ia, t)
            },
            rotateZ: function(t) {
                return this.rotateOnAxis(ka, t)
            },
            translateOnAxis: function(t, e) {
                return Ma.copy(t).applyQuaternion(this.quaternion), this.position.add(Ma.multiplyScalar(e)), this
            },
            translateX: function(t) {
                return this.translateOnAxis(Ra, t)
            },
            translateY: function(t) {
                return this.translateOnAxis(Ia, t)
            },
            translateZ: function(t) {
                return this.translateOnAxis(ka, t)
            },
            localToWorld: function(t) {
                return t.applyMatrix4(this.matrixWorld)
            },
            worldToLocal: function(t) {
                return t.applyMatrix4(Aa.getInverse(this.matrixWorld))
            },
            lookAt: function(t, e, n) {
                t.isVector3 ? Ca.copy(t) : Ca.set(t, e, n);
                var i = this.parent;
                this.updateWorldMatrix(!0, !1), Pa.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Aa.lookAt(Pa, Ca, this.up) : Aa.lookAt(Ca, Pa, this.up), this.quaternion.setFromRotationMatrix(Aa), i && (Aa.extractRotation(i.matrixWorld), Ta.setFromRotationMatrix(Aa), this.quaternion.premultiply(Ta.inverse()))
            },
            add: function(t) {
                if (arguments.length > 1) {
                    for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                    return this
                }
                return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(Oa)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
            },
            remove: function(t) {
                if (arguments.length > 1) {
                    for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                    return this
                }
                var n = this.children.indexOf(t);
                return -1 !== n && (t.parent = null, this.children.splice(n, 1), t.dispatchEvent(Na)), this
            },
            attach: function(t) {
                return this.updateWorldMatrix(!0, !1), Aa.getInverse(this.matrixWorld), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Aa.multiply(t.parent.matrixWorld)), t.applyMatrix4(Aa), t.updateWorldMatrix(!1, !1), this.add(t), this
            },
            getObjectById: function(t) {
                return this.getObjectByProperty("id", t)
            },
            getObjectByName: function(t) {
                return this.getObjectByProperty("name", t)
            },
            getObjectByProperty: function(t, e) {
                if (this[t] === e) return this;
                for (var n = 0, i = this.children.length; n < i; n++) {
                    var r = this.children[n].getObjectByProperty(t, e);
                    if (void 0 !== r) return r
                }
            },
            getWorldPosition: function(t) {
                return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new Rr), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
            },
            getWorldQuaternion: function(t) {
                return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new Pr), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Pa, t, Fa), t
            },
            getWorldScale: function(t) {
                return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new Rr), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Pa, La, t), t
            },
            getWorldDirection: function(t) {
                void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new Rr), this.updateMatrixWorld(!0);
                var e = this.matrixWorld.elements;
                return t.set(e[8], e[9], e[10]).normalize()
            },
            raycast: function() {},
            traverse: function(t) {
                t(this);
                for (var e = this.children, n = 0, i = e.length; n < i; n++) e[n].traverse(t)
            },
            traverseVisible: function(t) {
                if (!1 !== this.visible) {
                    t(this);
                    for (var e = this.children, n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
                }
            },
            traverseAncestors: function(t) {
                var e = this.parent;
                null !== e && (t(e), e.traverseAncestors(t))
            },
            updateMatrix: function() {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            },
            updateMatrixWorld: function(t) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                for (var e = this.children, n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t)
            },
            updateWorldMatrix: function(t, e) {
                var n = this.parent;
                if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e)
                    for (var i = this.children, r = 0, a = i.length; r < a; r++) i[r].updateWorldMatrix(!1, !0)
            },
            toJSON: function(t) {
                var e = void 0 === t || "string" == typeof t,
                    n = {};
                e && (t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {}
                }, n.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                var i = {};

                function r(e, n) {
                    return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
                }
                if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) {
                    i.geometry = r(t.geometries, this.geometry);
                    var a = this.geometry.parameters;
                    if (void 0 !== a && void 0 !== a.shapes) {
                        var s = a.shapes;
                        if (Array.isArray(s))
                            for (var o = 0, l = s.length; o < l; o++) {
                                var h = s[o];
                                r(t.shapes, h)
                            } else r(t.shapes, s)
                    }
                }
                if (void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        var u = [];
                        for (o = 0, l = this.material.length; o < l; o++) u.push(r(t.materials, this.material[o]));
                        i.material = u
                    } else i.material = r(t.materials, this.material);
                if (this.children.length > 0) {
                    i.children = [];
                    for (o = 0; o < this.children.length; o++) i.children.push(this.children[o].toJSON(t).object)
                }
                if (e) {
                    var c = m(t.geometries),
                        p = m(t.materials),
                        f = m(t.textures),
                        d = m(t.images);
                    s = m(t.shapes);
                    c.length > 0 && (n.geometries = c), p.length > 0 && (n.materials = p), f.length > 0 && (n.textures = f), d.length > 0 && (n.images = d), s.length > 0 && (n.shapes = s)
                }
                return n.object = i, n;

                function m(t) {
                    var e = [];
                    for (var n in t) {
                        var i = t[n];
                        delete i.metadata, e.push(i)
                    }
                    return e
                }
            },
            clone: function(t) {
                return (new this.constructor).copy(this, t)
            },
            copy: function(t, e) {
                if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                    for (var n = 0; n < t.children.length; n++) {
                        var i = t.children[n];
                        this.add(i.clone())
                    }
                return this
            }
        }), za.prototype = Object.assign(Object.create(Ba.prototype), {
            constructor: za,
            isScene: !0,
            copy: function(t, e) {
                return Ba.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
            },
            toJSON: function(t) {
                var e = Ba.prototype.toJSON.call(this, t);
                return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.environment && (e.object.environment = this.environment.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), Object.assign(Ga.prototype, {
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
                for (var e = 0, n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
                for (e = 0, n = t.vertexColors.length; e < n; e++) this.vertexColors[e] = t.vertexColors[e].clone();
                return this
            }
        });
        var Ha = 0,
            ja = new ca,
            Wa = new Ba,
            Xa = new Rr;

        function qa() {
            Object.defineProperty(this, "id", {
                value: Ha += 2
            }), this.uuid = Er.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
        }
        qa.prototype = Object.assign(Object.create(wr.prototype), {
            constructor: qa,
            isGeometry: !0,
            applyMatrix4: function(t) {
                for (var e = (new Sr).getNormalMatrix(t), n = 0, i = this.vertices.length; n < i; n++) {
                    this.vertices[n].applyMatrix4(t)
                }
                for (n = 0, i = this.faces.length; n < i; n++) {
                    var r = this.faces[n];
                    r.normal.applyMatrix3(e).normalize();
                    for (var a = 0, s = r.vertexNormals.length; a < s; a++) r.vertexNormals[a].applyMatrix3(e).normalize()
                }
                return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
            },
            rotateX: function(t) {
                return ja.makeRotationX(t), this.applyMatrix4(ja), this
            },
            rotateY: function(t) {
                return ja.makeRotationY(t), this.applyMatrix4(ja), this
            },
            rotateZ: function(t) {
                return ja.makeRotationZ(t), this.applyMatrix4(ja), this
            },
            translate: function(t, e, n) {
                return ja.makeTranslation(t, e, n), this.applyMatrix4(ja), this
            },
            scale: function(t, e, n) {
                return ja.makeScale(t, e, n), this.applyMatrix4(ja), this
            },
            lookAt: function(t) {
                return Wa.lookAt(t), Wa.updateMatrix(), this.applyMatrix4(Wa.matrix), this
            },
            fromBufferGeometry: function(t) {
                var e = this,
                    n = null !== t.index ? t.index.array : void 0,
                    i = t.attributes;
                if (void 0 === i.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
                var r = i.position.array,
                    a = void 0 !== i.normal ? i.normal.array : void 0,
                    s = void 0 !== i.color ? i.color.array : void 0,
                    o = void 0 !== i.uv ? i.uv.array : void 0,
                    l = void 0 !== i.uv2 ? i.uv2.array : void 0;
                void 0 !== l && (this.faceVertexUvs[1] = []);
                for (var h = 0; h < r.length; h += 3) e.vertices.push((new Rr).fromArray(r, h)), void 0 !== s && e.colors.push((new ma).fromArray(s, h));

                function u(t, n, i, r) {
                    var h = void 0 === s ? [] : [e.colors[t].clone(), e.colors[n].clone(), e.colors[i].clone()],
                        u = new Ga(t, n, i, void 0 === a ? [] : [(new Rr).fromArray(a, 3 * t), (new Rr).fromArray(a, 3 * n), (new Rr).fromArray(a, 3 * i)], h, r);
                    e.faces.push(u), void 0 !== o && e.faceVertexUvs[0].push([(new Dr).fromArray(o, 2 * t), (new Dr).fromArray(o, 2 * n), (new Dr).fromArray(o, 2 * i)]), void 0 !== l && e.faceVertexUvs[1].push([(new Dr).fromArray(l, 2 * t), (new Dr).fromArray(l, 2 * n), (new Dr).fromArray(l, 2 * i)])
                }
                var c = t.groups;
                if (c.length > 0)
                    for (h = 0; h < c.length; h++)
                        for (var p = c[h], f = p.start, d = f, m = f + p.count; d < m; d += 3) void 0 !== n ? u(n[d], n[d + 1], n[d + 2], p.materialIndex) : u(d, d + 1, d + 2, p.materialIndex);
                else if (void 0 !== n)
                    for (h = 0; h < n.length; h += 3) u(n[h], n[h + 1], n[h + 2]);
                else
                    for (h = 0; h < r.length / 3; h += 3) u(h, h + 1, h + 2);
                return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
            },
            center: function() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(Xa).negate(), this.translate(Xa.x, Xa.y, Xa.z), this
            },
            normalize: function() {
                this.computeBoundingSphere();
                var t = this.boundingSphere.center,
                    e = this.boundingSphere.radius,
                    n = 0 === e ? 1 : 1 / e,
                    i = new ca;
                return i.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix4(i), this
            },
            computeFaceNormals: function() {
                for (var t = new Rr, e = new Rr, n = 0, i = this.faces.length; n < i; n++) {
                    var r = this.faces[n],
                        a = this.vertices[r.a],
                        s = this.vertices[r.b],
                        o = this.vertices[r.c];
                    t.subVectors(o, s), e.subVectors(a, s), t.cross(e), t.normalize(), r.normal.copy(t)
                }
            },
            computeVertexNormals: function(t) {
                var e, n, i, r, a, s;
                for (void 0 === t && (t = !0), s = new Array(this.vertices.length), e = 0, n = this.vertices.length; e < n; e++) s[e] = new Rr;
                if (t) {
                    var o, l, h, u = new Rr,
                        c = new Rr;
                    for (i = 0, r = this.faces.length; i < r; i++) a = this.faces[i], o = this.vertices[a.a], l = this.vertices[a.b], h = this.vertices[a.c], u.subVectors(h, l), c.subVectors(o, l), u.cross(c), s[a.a].add(u), s[a.b].add(u), s[a.c].add(u)
                } else
                    for (this.computeFaceNormals(), i = 0, r = this.faces.length; i < r; i++) s[(a = this.faces[i]).a].add(a.normal), s[a.b].add(a.normal), s[a.c].add(a.normal);
                for (e = 0, n = this.vertices.length; e < n; e++) s[e].normalize();
                for (i = 0, r = this.faces.length; i < r; i++) {
                    var p = (a = this.faces[i]).vertexNormals;
                    3 === p.length ? (p[0].copy(s[a.a]), p[1].copy(s[a.b]), p[2].copy(s[a.c])) : (p[0] = s[a.a].clone(), p[1] = s[a.b].clone(), p[2] = s[a.c].clone())
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = !0)
            },
            computeFlatVertexNormals: function() {
                var t, e, n;
                for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
                    var i = (n = this.faces[t]).vertexNormals;
                    3 === i.length ? (i[0].copy(n.normal), i[1].copy(n.normal), i[2].copy(n.normal)) : (i[0] = n.normal.clone(), i[1] = n.normal.clone(), i[2] = n.normal.clone())
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = !0)
            },
            computeMorphNormals: function() {
                var t, e, n, i, r;
                for (n = 0, i = this.faces.length; n < i; n++)
                    for ((r = this.faces[n]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), t = 0, e = r.vertexNormals.length; t < e; t++) r.__originalVertexNormals[t] ? r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r.__originalVertexNormals[t] = r.vertexNormals[t].clone();
                var a = new qa;
                for (a.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
                    if (!this.morphNormals[t]) {
                        this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [];
                        var s = this.morphNormals[t].faceNormals,
                            o = this.morphNormals[t].vertexNormals;
                        for (n = 0, i = this.faces.length; n < i; n++) l = new Rr, h = {
                            a: new Rr,
                            b: new Rr,
                            c: new Rr
                        }, s.push(l), o.push(h)
                    }
                    var l, h, u = this.morphNormals[t];
                    for (a.vertices = this.morphTargets[t].vertices, a.computeFaceNormals(), a.computeVertexNormals(), n = 0, i = this.faces.length; n < i; n++) r = this.faces[n], l = u.faceNormals[n], h = u.vertexNormals[n], l.copy(r.normal), h.a.copy(r.vertexNormals[0]), h.b.copy(r.vertexNormals[1]), h.c.copy(r.vertexNormals[2])
                }
                for (n = 0, i = this.faces.length; n < i; n++)(r = this.faces[n]).normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
            },
            computeBoundingBox: function() {
                null === this.boundingBox && (this.boundingBox = new qr), this.boundingBox.setFromPoints(this.vertices)
            },
            computeBoundingSphere: function() {
                null === this.boundingSphere && (this.boundingSphere = new Jr), this.boundingSphere.setFromPoints(this.vertices)
            },
            merge: function(t, e, n) {
                if (t && t.isGeometry) {
                    var i, r = this.vertices.length,
                        a = this.vertices,
                        s = t.vertices,
                        o = this.faces,
                        l = t.faces,
                        h = this.colors,
                        u = t.colors;
                    void 0 === n && (n = 0), void 0 !== e && (i = (new Sr).getNormalMatrix(e));
                    for (var c = 0, p = s.length; c < p; c++) {
                        var f = s[c].clone();
                        void 0 !== e && f.applyMatrix4(e), a.push(f)
                    }
                    for (c = 0, p = u.length; c < p; c++) h.push(u[c].clone());
                    for (c = 0, p = l.length; c < p; c++) {
                        var d, m, g, v = l[c],
                            y = v.vertexNormals,
                            _ = v.vertexColors;
                        (d = new Ga(v.a + r, v.b + r, v.c + r)).normal.copy(v.normal), void 0 !== i && d.normal.applyMatrix3(i).normalize();
                        for (var x = 0, b = y.length; x < b; x++) m = y[x].clone(), void 0 !== i && m.applyMatrix3(i).normalize(), d.vertexNormals.push(m);
                        d.color.copy(v.color);
                        for (x = 0, b = _.length; x < b; x++) g = _[x], d.vertexColors.push(g.clone());
                        d.materialIndex = v.materialIndex + n, o.push(d)
                    }
                    for (c = 0, p = t.faceVertexUvs.length; c < p; c++) {
                        var E = t.faceVertexUvs[c];
                        void 0 === this.faceVertexUvs[c] && (this.faceVertexUvs[c] = []);
                        for (x = 0, b = E.length; x < b; x++) {
                            for (var w = E[x], D = [], S = 0, M = w.length; S < M; S++) D.push(w[S].clone());
                            this.faceVertexUvs[c].push(D)
                        }
                    }
                } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t)
            },
            mergeMesh: function(t) {
                t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
            },
            mergeVertices: function() {
                var t, e, n, i, r, a, s, o, l = {},
                    h = [],
                    u = [],
                    c = Math.pow(10, 4);
                for (n = 0, i = this.vertices.length; n < i; n++) t = this.vertices[n], void 0 === l[e = Math.round(t.x * c) + "_" + Math.round(t.y * c) + "_" + Math.round(t.z * c)] ? (l[e] = n, h.push(this.vertices[n]), u[n] = h.length - 1) : u[n] = u[l[e]];
                var p = [];
                for (n = 0, i = this.faces.length; n < i; n++) {
                    (r = this.faces[n]).a = u[r.a], r.b = u[r.b], r.c = u[r.c], a = [r.a, r.b, r.c];
                    for (var f = 0; f < 3; f++)
                        if (a[f] === a[(f + 1) % 3]) {
                            p.push(n);
                            break
                        }
                }
                for (n = p.length - 1; n >= 0; n--) {
                    var d = p[n];
                    for (this.faces.splice(d, 1), s = 0, o = this.faceVertexUvs.length; s < o; s++) this.faceVertexUvs[s].splice(d, 1)
                }
                var m = this.vertices.length - h.length;
                return this.vertices = h, m
            },
            setFromPoints: function(t) {
                this.vertices = [];
                for (var e = 0, n = t.length; e < n; e++) {
                    var i = t[e];
                    this.vertices.push(new Rr(i.x, i.y, i.z || 0))
                }
                return this
            },
            sortFacesByMaterialIndex: function() {
                for (var t = this.faces, e = t.length, n = 0; n < e; n++) t[n]._id = n;
                t.sort((function(t, e) {
                    return t.materialIndex - e.materialIndex
                }));
                var i, r, a = this.faceVertexUvs[0],
                    s = this.faceVertexUvs[1];
                a && a.length === e && (i = []), s && s.length === e && (r = []);
                for (n = 0; n < e; n++) {
                    var o = t[n]._id;
                    i && i.push(a[o]), r && r.push(s[o])
                }
                i && (this.faceVertexUvs[0] = i), r && (this.faceVertexUvs[1] = r)
            },
            toJSON: function() {
                var t = {
                    metadata: {
                        version: 4.5,
                        type: "Geometry",
                        generator: "Geometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                    var e = this.parameters;
                    for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
                    return t
                }
                for (var i = [], r = 0; r < this.vertices.length; r++) {
                    var a = this.vertices[r];
                    i.push(a.x, a.y, a.z)
                }
                var s = [],
                    o = [],
                    l = {},
                    h = [],
                    u = {},
                    c = [],
                    p = {};
                for (r = 0; r < this.faces.length; r++) {
                    var f = this.faces[r],
                        d = void 0 !== this.faceVertexUvs[0][r],
                        m = f.normal.length() > 0,
                        g = f.vertexNormals.length > 0,
                        v = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b,
                        y = f.vertexColors.length > 0,
                        _ = 0;
                    if (_ = w(_, 0, 0), _ = w(_, 1, !0), _ = w(_, 2, !1), _ = w(_, 3, d), _ = w(_, 4, m), _ = w(_, 5, g), _ = w(_, 6, v), _ = w(_, 7, y), s.push(_), s.push(f.a, f.b, f.c), s.push(f.materialIndex), d) {
                        var x = this.faceVertexUvs[0][r];
                        s.push(M(x[0]), M(x[1]), M(x[2]))
                    }
                    if (m && s.push(D(f.normal)), g) {
                        var b = f.vertexNormals;
                        s.push(D(b[0]), D(b[1]), D(b[2]))
                    }
                    if (v && s.push(S(f.color)), y) {
                        var E = f.vertexColors;
                        s.push(S(E[0]), S(E[1]), S(E[2]))
                    }
                }

                function w(t, e, n) {
                    return n ? t | 1 << e : t & ~(1 << e)
                }

                function D(t) {
                    var e = t.x.toString() + t.y.toString() + t.z.toString();
                    return void 0 !== l[e] || (l[e] = o.length / 3, o.push(t.x, t.y, t.z)), l[e]
                }

                function S(t) {
                    var e = t.r.toString() + t.g.toString() + t.b.toString();
                    return void 0 !== u[e] || (u[e] = h.length, h.push(t.getHex())), u[e]
                }

                function M(t) {
                    var e = t.x.toString() + t.y.toString();
                    return void 0 !== p[e] || (p[e] = c.length / 2, c.push(t.x, t.y)), p[e]
                }
                return t.data = {}, t.data.vertices = i, t.data.normals = o, h.length > 0 && (t.data.colors = h), c.length > 0 && (t.data.uvs = [c]), t.data.faces = s, t
            },
            clone: function() {
                return (new qa).copy(this)
            },
            copy: function(t) {
                var e, n, i, r, a, s;
                this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                var o = t.vertices;
                for (e = 0, n = o.length; e < n; e++) this.vertices.push(o[e].clone());
                var l = t.colors;
                for (e = 0, n = l.length; e < n; e++) this.colors.push(l[e].clone());
                var h = t.faces;
                for (e = 0, n = h.length; e < n; e++) this.faces.push(h[e].clone());
                for (e = 0, n = t.faceVertexUvs.length; e < n; e++) {
                    var u = t.faceVertexUvs[e];
                    for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), i = 0, r = u.length; i < r; i++) {
                        var c = u[i],
                            p = [];
                        for (a = 0, s = c.length; a < s; a++) {
                            var f = c[a];
                            p.push(f.clone())
                        }
                        this.faceVertexUvs[e].push(p)
                    }
                }
                var d = t.morphTargets;
                for (e = 0, n = d.length; e < n; e++) {
                    var m = {};
                    if (m.name = d[e].name, void 0 !== d[e].vertices)
                        for (m.vertices = [], i = 0, r = d[e].vertices.length; i < r; i++) m.vertices.push(d[e].vertices[i].clone());
                    if (void 0 !== d[e].normals)
                        for (m.normals = [], i = 0, r = d[e].normals.length; i < r; i++) m.normals.push(d[e].normals[i].clone());
                    this.morphTargets.push(m)
                }
                var g = t.morphNormals;
                for (e = 0, n = g.length; e < n; e++) {
                    var v = {};
                    if (void 0 !== g[e].vertexNormals)
                        for (v.vertexNormals = [], i = 0, r = g[e].vertexNormals.length; i < r; i++) {
                            var y = g[e].vertexNormals[i],
                                _ = {};
                            _.a = y.a.clone(), _.b = y.b.clone(), _.c = y.c.clone(), v.vertexNormals.push(_)
                        }
                    if (void 0 !== g[e].faceNormals)
                        for (v.faceNormals = [], i = 0, r = g[e].faceNormals.length; i < r; i++) v.faceNormals.push(g[e].faceNormals[i].clone());
                    this.morphNormals.push(v)
                }
                var x = t.skinWeights;
                for (e = 0, n = x.length; e < n; e++) this.skinWeights.push(x[e].clone());
                var b = t.skinIndices;
                for (e = 0, n = b.length; e < n; e++) this.skinIndices.push(b[e].clone());
                var E = t.lineDistances;
                for (e = 0, n = E.length; e < n; e++) this.lineDistances.push(E[e]);
                var w = t.boundingBox;
                null !== w && (this.boundingBox = w.clone());
                var D = t.boundingSphere;
                return null !== D && (this.boundingSphere = D.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        });
        var Ya = new Rr;

        function Za(t, e, n) {
            if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = 35044, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0
        }

        function Ja(t, e, n) {
            Za.call(this, new Int8Array(t), e, n)
        }

        function Ka(t, e, n) {
            Za.call(this, new Uint8Array(t), e, n)
        }

        function $a(t, e, n) {
            Za.call(this, new Uint8ClampedArray(t), e, n)
        }

        function Qa(t, e, n) {
            Za.call(this, new Int16Array(t), e, n)
        }

        function ts(t, e, n) {
            Za.call(this, new Uint16Array(t), e, n)
        }

        function es(t, e, n) {
            Za.call(this, new Int32Array(t), e, n)
        }

        function ns(t, e, n) {
            Za.call(this, new Uint32Array(t), e, n)
        }

        function is(t, e, n) {
            Za.call(this, new Float32Array(t), e, n)
        }

        function rs(t, e, n) {
            Za.call(this, new Float64Array(t), e, n)
        }

        function as() {
            this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
        }

        function ss(t) {
            if (0 === t.length) return -1 / 0;
            for (var e = t[0], n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
            return e
        }
        Object.defineProperty(Za.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }), Object.assign(Za.prototype, {
            isBufferAttribute: !0,
            onUploadCallback: function() {},
            setUsage: function(t) {
                return this.usage = t, this
            },
            copy: function(t) {
                return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this
            },
            copyAt: function(t, e, n) {
                t *= this.itemSize, n *= e.itemSize;
                for (var i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
                return this
            },
            copyArray: function(t) {
                return this.array.set(t), this
            },
            copyColorsArray: function(t) {
                for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                    var a = t[i];
                    void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), a = new ma), e[n++] = a.r, e[n++] = a.g, e[n++] = a.b
                }
                return this
            },
            copyVector2sArray: function(t) {
                for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                    var a = t[i];
                    void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), a = new Dr), e[n++] = a.x, e[n++] = a.y
                }
                return this
            },
            copyVector3sArray: function(t) {
                for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                    var a = t[i];
                    void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), a = new Rr), e[n++] = a.x, e[n++] = a.y, e[n++] = a.z
                }
                return this
            },
            copyVector4sArray: function(t) {
                for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                    var a = t[i];
                    void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), a = new xa), e[n++] = a.x, e[n++] = a.y, e[n++] = a.z, e[n++] = a.w
                }
                return this
            },
            applyMatrix3: function(t) {
                for (var e = 0, n = this.count; e < n; e++) Ya.x = this.getX(e), Ya.y = this.getY(e), Ya.z = this.getZ(e), Ya.applyMatrix3(t), this.setXYZ(e, Ya.x, Ya.y, Ya.z);
                return this
            },
            applyMatrix4: function(t) {
                for (var e = 0, n = this.count; e < n; e++) Ya.x = this.getX(e), Ya.y = this.getY(e), Ya.z = this.getZ(e), Ya.applyMatrix4(t), this.setXYZ(e, Ya.x, Ya.y, Ya.z);
                return this
            },
            applyNormalMatrix: function(t) {
                for (var e = 0, n = this.count; e < n; e++) Ya.x = this.getX(e), Ya.y = this.getY(e), Ya.z = this.getZ(e), Ya.applyNormalMatrix(t), this.setXYZ(e, Ya.x, Ya.y, Ya.z);
                return this
            },
            transformDirection: function(t) {
                for (var e = 0, n = this.count; e < n; e++) Ya.x = this.getX(e), Ya.y = this.getY(e), Ya.z = this.getZ(e), Ya.transformDirection(t), this.setXYZ(e, Ya.x, Ya.y, Ya.z);
                return this
            },
            set: function(t, e) {
                return void 0 === e && (e = 0), this.array.set(t, e), this
            },
            getX: function(t) {
                return this.array[t * this.itemSize]
            },
            setX: function(t, e) {
                return this.array[t * this.itemSize] = e, this
            },
            getY: function(t) {
                return this.array[t * this.itemSize + 1]
            },
            setY: function(t, e) {
                return this.array[t * this.itemSize + 1] = e, this
            },
            getZ: function(t) {
                return this.array[t * this.itemSize + 2]
            },
            setZ: function(t, e) {
                return this.array[t * this.itemSize + 2] = e, this
            },
            getW: function(t) {
                return this.array[t * this.itemSize + 3]
            },
            setW: function(t, e) {
                return this.array[t * this.itemSize + 3] = e, this
            },
            setXY: function(t, e, n) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
            },
            setXYZ: function(t, e, n, i) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this
            },
            setXYZW: function(t, e, n, i, r) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this
            },
            onUpload: function(t) {
                return this.onUploadCallback = t, this
            },
            clone: function() {
                return new this.constructor(this.array, this.itemSize).copy(this)
            },
            toJSON: function() {
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.prototype.slice.call(this.array),
                    normalized: this.normalized
                }
            }
        }), Ja.prototype = Object.create(Za.prototype), Ja.prototype.constructor = Ja, Ka.prototype = Object.create(Za.prototype), Ka.prototype.constructor = Ka, $a.prototype = Object.create(Za.prototype), $a.prototype.constructor = $a, Qa.prototype = Object.create(Za.prototype), Qa.prototype.constructor = Qa, ts.prototype = Object.create(Za.prototype), ts.prototype.constructor = ts, es.prototype = Object.create(Za.prototype), es.prototype.constructor = es, ns.prototype = Object.create(Za.prototype), ns.prototype.constructor = ns, is.prototype = Object.create(Za.prototype), is.prototype.constructor = is, rs.prototype = Object.create(Za.prototype), rs.prototype.constructor = rs, Object.assign(as.prototype, {
            computeGroups: function(t) {
                for (var e, n = [], i = void 0, r = t.faces, a = 0; a < r.length; a++) {
                    var s = r[a];
                    s.materialIndex !== i && (i = s.materialIndex, void 0 !== e && (e.count = 3 * a - e.start, n.push(e)), e = {
                        start: 3 * a,
                        materialIndex: i
                    })
                }
                void 0 !== e && (e.count = 3 * a - e.start, n.push(e)), this.groups = n
            },
            fromGeometry: function(t) {
                var e, n = t.faces,
                    i = t.vertices,
                    r = t.faceVertexUvs,
                    a = r[0] && r[0].length > 0,
                    s = r[1] && r[1].length > 0,
                    o = t.morphTargets,
                    l = o.length;
                if (l > 0) {
                    e = [];
                    for (var h = 0; h < l; h++) e[h] = {
                        name: o[h].name,
                        data: []
                    };
                    this.morphTargets.position = e
                }
                var u, c = t.morphNormals,
                    p = c.length;
                if (p > 0) {
                    u = [];
                    for (h = 0; h < p; h++) u[h] = {
                        name: c[h].name,
                        data: []
                    };
                    this.morphTargets.normal = u
                }
                var f = t.skinIndices,
                    d = t.skinWeights,
                    m = f.length === i.length,
                    g = d.length === i.length;
                i.length > 0 && 0 === n.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
                for (h = 0; h < n.length; h++) {
                    var v = n[h];
                    this.vertices.push(i[v.a], i[v.b], i[v.c]);
                    var y = v.vertexNormals;
                    if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
                    else {
                        var _ = v.normal;
                        this.normals.push(_, _, _)
                    }
                    var x, b = v.vertexColors;
                    if (3 === b.length) this.colors.push(b[0], b[1], b[2]);
                    else {
                        var E = v.color;
                        this.colors.push(E, E, E)
                    }
                    if (!0 === a) void 0 !== (x = r[0][h]) ? this.uvs.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h), this.uvs.push(new Dr, new Dr, new Dr));
                    if (!0 === s) void 0 !== (x = r[1][h]) ? this.uvs2.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h), this.uvs2.push(new Dr, new Dr, new Dr));
                    for (var w = 0; w < l; w++) {
                        var D = o[w].vertices;
                        e[w].data.push(D[v.a], D[v.b], D[v.c])
                    }
                    for (w = 0; w < p; w++) {
                        var S = c[w].vertexNormals[h];
                        u[w].data.push(S.a, S.b, S.c)
                    }
                    m && this.skinIndices.push(f[v.a], f[v.b], f[v.c]), g && this.skinWeights.push(d[v.a], d[v.b], d[v.c])
                }
                return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
            }
        });
        var os = 1,
            ls = new ca,
            hs = new Ba,
            us = new Rr,
            cs = new qr,
            ps = new qr,
            fs = new Rr;

        function ds() {
            Object.defineProperty(this, "id", {
                value: os += 2
            }), this.uuid = Er.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }, this.userData = {}
        }
        ds.prototype = Object.assign(Object.create(wr.prototype), {
            constructor: ds,
            isBufferGeometry: !0,
            getIndex: function() {
                return this.index
            },
            setIndex: function(t) {
                Array.isArray(t) ? this.index = new(ss(t) > 65535 ? ns : ts)(t, 1) : this.index = t
            },
            getAttribute: function(t) {
                return this.attributes[t]
            },
            setAttribute: function(t, e) {
                return this.attributes[t] = e, this
            },
            deleteAttribute: function(t) {
                return delete this.attributes[t], this
            },
            addGroup: function(t, e, n) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: void 0 !== n ? n : 0
                })
            },
            clearGroups: function() {
                this.groups = []
            },
            setDrawRange: function(t, e) {
                this.drawRange.start = t, this.drawRange.count = e
            },
            applyMatrix4: function(t) {
                var e = this.attributes.position;
                void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                var n = this.attributes.normal;
                if (void 0 !== n) {
                    var i = (new Sr).getNormalMatrix(t);
                    n.applyNormalMatrix(i), n.needsUpdate = !0
                }
                var r = this.attributes.tangent;
                return void 0 !== r && (r.transformDirection(t), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            },
            rotateX: function(t) {
                return ls.makeRotationX(t), this.applyMatrix4(ls), this
            },
            rotateY: function(t) {
                return ls.makeRotationY(t), this.applyMatrix4(ls), this
            },
            rotateZ: function(t) {
                return ls.makeRotationZ(t), this.applyMatrix4(ls), this
            },
            translate: function(t, e, n) {
                return ls.makeTranslation(t, e, n), this.applyMatrix4(ls), this
            },
            scale: function(t, e, n) {
                return ls.makeScale(t, e, n), this.applyMatrix4(ls), this
            },
            lookAt: function(t) {
                return hs.lookAt(t), hs.updateMatrix(), this.applyMatrix4(hs.matrix), this
            },
            center: function() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(us).negate(), this.translate(us.x, us.y, us.z), this
            },
            setFromObject: function(t) {
                var e = t.geometry;
                if (t.isPoints || t.isLine) {
                    var n = new is(3 * e.vertices.length, 3),
                        i = new is(3 * e.colors.length, 3);
                    if (this.setAttribute("position", n.copyVector3sArray(e.vertices)), this.setAttribute("color", i.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
                        var r = new is(e.lineDistances.length, 1);
                        this.setAttribute("lineDistance", r.copyArray(e.lineDistances))
                    }
                    null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
                } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
                return this
            },
            setFromPoints: function(t) {
                for (var e = [], n = 0, i = t.length; n < i; n++) {
                    var r = t[n];
                    e.push(r.x, r.y, r.z || 0)
                }
                return this.setAttribute("position", new is(e, 3)), this
            },
            updateFromObject: function(t) {
                var e, n = t.geometry;
                if (t.isMesh) {
                    var i = n.__directGeometry;
                    if (!0 === n.elementsNeedUpdate && (i = void 0, n.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(n);
                    i.verticesNeedUpdate = n.verticesNeedUpdate, i.normalsNeedUpdate = n.normalsNeedUpdate, i.colorsNeedUpdate = n.colorsNeedUpdate, i.uvsNeedUpdate = n.uvsNeedUpdate, i.groupsNeedUpdate = n.groupsNeedUpdate, n.verticesNeedUpdate = !1, n.normalsNeedUpdate = !1, n.colorsNeedUpdate = !1, n.uvsNeedUpdate = !1, n.groupsNeedUpdate = !1, n = i
                }
                return !0 === n.verticesNeedUpdate && (void 0 !== (e = this.attributes.position) && (e.copyVector3sArray(n.vertices), e.needsUpdate = !0), n.verticesNeedUpdate = !1), !0 === n.normalsNeedUpdate && (void 0 !== (e = this.attributes.normal) && (e.copyVector3sArray(n.normals), e.needsUpdate = !0), n.normalsNeedUpdate = !1), !0 === n.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e.copyColorsArray(n.colors), e.needsUpdate = !0), n.colorsNeedUpdate = !1), n.uvsNeedUpdate && (void 0 !== (e = this.attributes.uv) && (e.copyVector2sArray(n.uvs), e.needsUpdate = !0), n.uvsNeedUpdate = !1), n.lineDistancesNeedUpdate && (void 0 !== (e = this.attributes.lineDistance) && (e.copyArray(n.lineDistances), e.needsUpdate = !0), n.lineDistancesNeedUpdate = !1), n.groupsNeedUpdate && (n.computeGroups(t.geometry), this.groups = n.groups, n.groupsNeedUpdate = !1), this
            },
            fromGeometry: function(t) {
                return t.__directGeometry = (new as).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
            },
            fromDirectGeometry: function(t) {
                var e = new Float32Array(3 * t.vertices.length);
                if (this.setAttribute("position", new Za(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                    var n = new Float32Array(3 * t.normals.length);
                    this.setAttribute("normal", new Za(n, 3).copyVector3sArray(t.normals))
                }
                if (t.colors.length > 0) {
                    var i = new Float32Array(3 * t.colors.length);
                    this.setAttribute("color", new Za(i, 3).copyColorsArray(t.colors))
                }
                if (t.uvs.length > 0) {
                    var r = new Float32Array(2 * t.uvs.length);
                    this.setAttribute("uv", new Za(r, 2).copyVector2sArray(t.uvs))
                }
                if (t.uvs2.length > 0) {
                    var a = new Float32Array(2 * t.uvs2.length);
                    this.setAttribute("uv2", new Za(a, 2).copyVector2sArray(t.uvs2))
                }
                for (var s in this.groups = t.groups, t.morphTargets) {
                    for (var o = [], l = t.morphTargets[s], h = 0, u = l.length; h < u; h++) {
                        var c = l[h],
                            p = new is(3 * c.data.length, 3);
                        p.name = c.name, o.push(p.copyVector3sArray(c.data))
                    }
                    this.morphAttributes[s] = o
                }
                if (t.skinIndices.length > 0) {
                    var f = new is(4 * t.skinIndices.length, 4);
                    this.setAttribute("skinIndex", f.copyVector4sArray(t.skinIndices))
                }
                if (t.skinWeights.length > 0) {
                    var d = new is(4 * t.skinWeights.length, 4);
                    this.setAttribute("skinWeight", d.copyVector4sArray(t.skinWeights))
                }
                return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
            },
            computeBoundingBox: function() {
                null === this.boundingBox && (this.boundingBox = new qr);
                var t = this.attributes.position,
                    e = this.morphAttributes.position;
                if (void 0 !== t) {
                    if (this.boundingBox.setFromBufferAttribute(t), e)
                        for (var n = 0, i = e.length; n < i; n++) {
                            var r = e[n];
                            cs.setFromBufferAttribute(r), this.morphTargetsRelative ? (fs.addVectors(this.boundingBox.min, cs.min), this.boundingBox.expandByPoint(fs), fs.addVectors(this.boundingBox.max, cs.max), this.boundingBox.expandByPoint(fs)) : (this.boundingBox.expandByPoint(cs.min), this.boundingBox.expandByPoint(cs.max))
                        }
                } else this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            },
            computeBoundingSphere: function() {
                null === this.boundingSphere && (this.boundingSphere = new Jr);
                var t = this.attributes.position,
                    e = this.morphAttributes.position;
                if (t) {
                    var n = this.boundingSphere.center;
                    if (cs.setFromBufferAttribute(t), e)
                        for (var i = 0, r = e.length; i < r; i++) {
                            var a = e[i];
                            ps.setFromBufferAttribute(a), this.morphTargetsRelative ? (fs.addVectors(cs.min, ps.min), cs.expandByPoint(fs), fs.addVectors(cs.max, ps.max), cs.expandByPoint(fs)) : (cs.expandByPoint(ps.min), cs.expandByPoint(ps.max))
                        }
                    cs.getCenter(n);
                    var s = 0;
                    for (i = 0, r = t.count; i < r; i++) fs.fromBufferAttribute(t, i), s = Math.max(s, n.distanceToSquared(fs));
                    if (e)
                        for (i = 0, r = e.length; i < r; i++) {
                            a = e[i];
                            for (var o = this.morphTargetsRelative, l = 0, h = a.count; l < h; l++) fs.fromBufferAttribute(a, l), o && (us.fromBufferAttribute(t, l), fs.add(us)), s = Math.max(s, n.distanceToSquared(fs))
                        }
                    this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            },
            computeFaceNormals: function() {},
            computeVertexNormals: function() {
                var t = this.index,
                    e = this.attributes;
                if (e.position) {
                    var n = e.position.array;
                    if (void 0 === e.normal) this.setAttribute("normal", new Za(new Float32Array(n.length), 3));
                    else
                        for (var i = e.normal.array, r = 0, a = i.length; r < a; r++) i[r] = 0;
                    var s, o, l, h = e.normal.array,
                        u = new Rr,
                        c = new Rr,
                        p = new Rr,
                        f = new Rr,
                        d = new Rr;
                    if (t) {
                        var m = t.array;
                        for (r = 0, a = t.count; r < a; r += 3) s = 3 * m[r + 0], o = 3 * m[r + 1], l = 3 * m[r + 2], u.fromArray(n, s), c.fromArray(n, o), p.fromArray(n, l), f.subVectors(p, c), d.subVectors(u, c), f.cross(d), h[s] += f.x, h[s + 1] += f.y, h[s + 2] += f.z, h[o] += f.x, h[o + 1] += f.y, h[o + 2] += f.z, h[l] += f.x, h[l + 1] += f.y, h[l + 2] += f.z
                    } else
                        for (r = 0, a = n.length; r < a; r += 9) u.fromArray(n, r), c.fromArray(n, r + 3), p.fromArray(n, r + 6), f.subVectors(p, c), d.subVectors(u, c), f.cross(d), h[r] = f.x, h[r + 1] = f.y, h[r + 2] = f.z, h[r + 3] = f.x, h[r + 4] = f.y, h[r + 5] = f.z, h[r + 6] = f.x, h[r + 7] = f.y, h[r + 8] = f.z;
                    this.normalizeNormals(), e.normal.needsUpdate = !0
                }
            },
            merge: function(t, e) {
                if (t && t.isBufferGeometry) {
                    void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                    var n = this.attributes;
                    for (var i in n)
                        if (void 0 !== t.attributes[i])
                            for (var r = n[i].array, a = t.attributes[i], s = a.array, o = a.itemSize * e, l = Math.min(s.length, r.length - o), h = 0, u = o; h < l; h++, u++) r[u] = s[h];
                    return this
                }
                console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
            },
            normalizeNormals: function() {
                for (var t = this.attributes.normal, e = 0, n = t.count; e < n; e++) fs.x = t.getX(e), fs.y = t.getY(e), fs.z = t.getZ(e), fs.normalize(), t.setXYZ(e, fs.x, fs.y, fs.z)
            },
            toNonIndexed: function() {
                function t(t, e) {
                    for (var n = t.array, i = t.itemSize, r = new n.constructor(e.length * i), a = 0, s = 0, o = 0, l = e.length; o < l; o++) {
                        a = e[o] * i;
                        for (var h = 0; h < i; h++) r[s++] = n[a++]
                    }
                    return new Za(r, i)
                }
                if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                var e = new ds,
                    n = this.index.array,
                    i = this.attributes;
                for (var r in i) {
                    var a = t(i[r], n);
                    e.setAttribute(r, a)
                }
                var s = this.morphAttributes;
                for (r in s) {
                    for (var o = [], l = s[r], h = 0, u = l.length; h < u; h++) {
                        a = t(l[h], n);
                        o.push(a)
                    }
                    e.morphAttributes[r] = o
                }
                e.morphTargetsRelative = this.morphTargetsRelative;
                for (var c = this.groups, p = (h = 0, c.length); h < p; h++) {
                    var f = c[h];
                    e.addGroup(f.start, f.count, f.materialIndex)
                }
                return e
            },
            toJSON: function() {
                var t = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                    var e = this.parameters;
                    for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
                    return t
                }
                t.data = {
                    attributes: {}
                };
                var i = this.index;
                null !== i && (t.data.index = {
                    type: i.array.constructor.name,
                    array: Array.prototype.slice.call(i.array)
                });
                var r = this.attributes;
                for (var n in r) {
                    var a = (p = r[n]).toJSON();
                    "" !== p.name && (a.name = p.name), t.data.attributes[n] = a
                }
                var s = {},
                    o = !1;
                for (var n in this.morphAttributes) {
                    for (var l = this.morphAttributes[n], h = [], u = 0, c = l.length; u < c; u++) {
                        var p;
                        a = (p = l[u]).toJSON();
                        "" !== p.name && (a.name = p.name), h.push(a)
                    }
                    h.length > 0 && (s[n] = h, o = !0)
                }
                o && (t.data.morphAttributes = s, t.data.morphTargetsRelative = this.morphTargetsRelative);
                var f = this.groups;
                f.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(f)));
                var d = this.boundingSphere;
                return null !== d && (t.data.boundingSphere = {
                    center: d.center.toArray(),
                    radius: d.radius
                }), t
            },
            clone: function() {
                return (new ds).copy(this)
            },
            copy: function(t) {
                var e, n, i;
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                var r = t.index;
                null !== r && this.setIndex(r.clone());
                var a = t.attributes;
                for (e in a) {
                    var s = a[e];
                    this.setAttribute(e, s.clone())
                }
                var o = t.morphAttributes;
                for (e in o) {
                    var l = [],
                        h = o[e];
                    for (n = 0, i = h.length; n < i; n++) l.push(h[n].clone());
                    this.morphAttributes[e] = l
                }
                this.morphTargetsRelative = t.morphTargetsRelative;
                var u = t.groups;
                for (n = 0, i = u.length; n < i; n++) {
                    var c = u[n];
                    this.addGroup(c.start, c.count, c.materialIndex)
                }
                var p = t.boundingBox;
                null !== p && (this.boundingBox = p.clone());
                var f = t.boundingSphere;
                return null !== f && (this.boundingSphere = f.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        });
        class ms extends ds {
            constructor(t, e, n, i, r, a) {
                super(), this.type = "BoxBufferGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: a
                };
                var s = this;
                t = t || 1, e = e || 1, n = n || 1, i = Math.floor(i) || 1, r = Math.floor(r) || 1, a = Math.floor(a) || 1;
                var o = [],
                    l = [],
                    h = [],
                    u = [],
                    c = 0,
                    p = 0;

                function f(t, e, n, i, r, a, f, d, m, g, v) {
                    var y, _, x = a / m,
                        b = f / g,
                        E = a / 2,
                        w = f / 2,
                        D = d / 2,
                        S = m + 1,
                        M = g + 1,
                        T = 0,
                        A = 0,
                        C = new Rr;
                    for (_ = 0; _ < M; _++) {
                        var P = _ * b - w;
                        for (y = 0; y < S; y++) {
                            var F = y * x - E;
                            C[t] = F * i, C[e] = P * r, C[n] = D, l.push(C.x, C.y, C.z), C[t] = 0, C[e] = 0, C[n] = d > 0 ? 1 : -1, h.push(C.x, C.y, C.z), u.push(y / m), u.push(1 - _ / g), T += 1
                        }
                    }
                    for (_ = 0; _ < g; _++)
                        for (y = 0; y < m; y++) {
                            var L = c + y + S * _,
                                R = c + y + S * (_ + 1),
                                I = c + (y + 1) + S * (_ + 1),
                                k = c + (y + 1) + S * _;
                            o.push(L, R, k), o.push(R, I, k), A += 6
                        }
                    s.addGroup(p, A, v), p += A, c += T
                }
                f("z", "y", "x", -1, -1, n, e, t, a, r, 0), f("z", "y", "x", 1, -1, n, e, -t, a, r, 1), f("x", "z", "y", 1, 1, t, n, e, i, a, 2), f("x", "z", "y", 1, -1, t, n, -e, i, a, 3), f("x", "y", "z", 1, -1, t, e, n, i, r, 4), f("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(o), this.setAttribute("position", new is(l, 3)), this.setAttribute("normal", new is(h, 3)), this.setAttribute("uv", new is(u, 2))
            }
        }

        function gs(t, e, n, i) {
            qa.call(this), this.type = "PlaneGeometry", this.parameters = {
                width: t,
                height: e,
                widthSegments: n,
                heightSegments: i
            }, this.fromBufferGeometry(new vs(t, e, n, i)), this.mergeVertices()
        }

        function vs(t, e, n, i) {
            ds.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                width: t,
                height: e,
                widthSegments: n,
                heightSegments: i
            };
            var r, a, s = (t = t || 1) / 2,
                o = (e = e || 1) / 2,
                l = Math.floor(n) || 1,
                h = Math.floor(i) || 1,
                u = l + 1,
                c = h + 1,
                p = t / l,
                f = e / h,
                d = [],
                m = [],
                g = [],
                v = [];
            for (a = 0; a < c; a++) {
                var y = a * f - o;
                for (r = 0; r < u; r++) {
                    var _ = r * p - s;
                    m.push(_, -y, 0), g.push(0, 0, 1), v.push(r / l), v.push(1 - a / h)
                }
            }
            for (a = 0; a < h; a++)
                for (r = 0; r < l; r++) {
                    var x = r + u * a,
                        b = r + u * (a + 1),
                        E = r + 1 + u * (a + 1),
                        w = r + 1 + u * a;
                    d.push(x, b, w), d.push(b, E, w)
                }
            this.setIndex(d), this.setAttribute("position", new is(m, 3)), this.setAttribute("normal", new is(g, 3)), this.setAttribute("uv", new is(v, 2))
        }
        gs.prototype = Object.create(qa.prototype), gs.prototype.constructor = gs, vs.prototype = Object.create(ds.prototype), vs.prototype.constructor = vs;
        var ys = 0;

        function _s() {
            Object.defineProperty(this, "id", {
                value: ys++
            }), this.uuid = Er.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0
        }

        function xs(t) {
            var e = {};
            for (var n in t)
                for (var i in e[n] = {}, t[n]) {
                    var r = t[n][i];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                }
            return e
        }

        function bs(t) {
            for (var e = {}, n = 0; n < t.length; n++) {
                var i = xs(t[n]);
                for (var r in i) e[r] = i[r]
            }
            return e
        }
        _s.prototype = Object.assign(Object.create(wr.prototype), {
            constructor: _s,
            isMaterial: !0,
            onBeforeCompile: function() {},
            setValues: function(t) {
                if (void 0 !== t)
                    for (var e in t) {
                        var n = t[e];
                        if (void 0 !== n)
                            if ("shading" !== e) {
                                var i = this[e];
                                void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                            } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                        else console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                    }
            },
            toJSON: function(t) {
                var e = void 0 === t || "string" == typeof t;
                e && (t = {
                    textures: {},
                    images: {}
                });
                var n = {
                    metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };

                function i(t) {
                    var e = [];
                    for (var n in t) {
                        var i = t[n];
                        delete i.metadata, e.push(i)
                    }
                    return e
                }
                if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                    var r = i(t.textures),
                        a = i(t.images);
                    r.length > 0 && (n.textures = r), a.length > 0 && (n.images = a)
                }
                return n
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                var e = t.clippingPlanes,
                    n = null;
                if (null !== e) {
                    var i = e.length;
                    n = new Array(i);
                    for (var r = 0; r !== i; ++r) n[r] = e[r].clone()
                }
                return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), Object.defineProperty(_s.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        });
        var Es = {
            clone: xs,
            merge: bs
        };

        function ws(t) {
            _s.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "\nvoid main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n", this.fragmentShader = "\nvoid main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}\n", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            }, this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
        }
        ws.prototype = Object.create(_s.prototype), ws.prototype.constructor = ws, ws.prototype.isShaderMaterial = !0, ws.prototype.copy = function(t) {
            return _s.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = xs(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this
        }, ws.prototype.toJSON = function(t) {
            var e = _s.prototype.toJSON.call(this, t);
            for (var n in e.uniforms = {}, this.uniforms) {
                var i = this.uniforms[n].value;
                i && i.isTexture ? e.uniforms[n] = {
                    type: "t",
                    value: i.toJSON(t).uuid
                } : i && i.isColor ? e.uniforms[n] = {
                    type: "c",
                    value: i.getHex()
                } : i && i.isVector2 ? e.uniforms[n] = {
                    type: "v2",
                    value: i.toArray()
                } : i && i.isVector3 ? e.uniforms[n] = {
                    type: "v3",
                    value: i.toArray()
                } : i && i.isVector4 ? e.uniforms[n] = {
                    type: "v4",
                    value: i.toArray()
                } : i && i.isMatrix3 ? e.uniforms[n] = {
                    type: "m3",
                    value: i.toArray()
                } : i && i.isMatrix4 ? e.uniforms[n] = {
                    type: "m4",
                    value: i.toArray()
                } : e.uniforms[n] = {
                    value: i
                }
            }
            Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
            var r = {};
            for (var a in this.extensions) !0 === this.extensions[a] && (r[a] = !0);
            return Object.keys(r).length > 0 && (e.extensions = r), e
        };
        var Ds = new Rr,
            Ss = new Rr,
            Ms = new Rr,
            Ts = new Rr,
            As = new Rr,
            Cs = new Rr,
            Ps = new Rr;

        function Fs(t, e) {
            this.origin = void 0 !== t ? t : new Rr, this.direction = void 0 !== e ? e : new Rr(0, 0, -1)
        }
        Object.assign(Fs.prototype, {
            set: function(t, e) {
                return this.origin.copy(t), this.direction.copy(e), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.origin.copy(t.origin), this.direction.copy(t.direction), this
            },
            at: function(t, e) {
                return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new Rr), e.copy(this.direction).multiplyScalar(t).add(this.origin)
            },
            lookAt: function(t) {
                return this.direction.copy(t).sub(this.origin).normalize(), this
            },
            recast: function(t) {
                return this.origin.copy(this.at(t, Ds)), this
            },
            closestPointToPoint: function(t, e) {
                void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new Rr), e.subVectors(t, this.origin);
                var n = e.dot(this.direction);
                return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
            },
            distanceToPoint: function(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            },
            distanceSqToPoint: function(t) {
                var e = Ds.subVectors(t, this.origin).dot(this.direction);
                return e < 0 ? this.origin.distanceToSquared(t) : (Ds.copy(this.direction).multiplyScalar(e).add(this.origin), Ds.distanceToSquared(t))
            },
            distanceSqToSegment: function(t, e, n, i) {
                Ss.copy(t).add(e).multiplyScalar(.5), Ms.copy(e).sub(t).normalize(), Ts.copy(this.origin).sub(Ss);
                var r, a, s, o, l = .5 * t.distanceTo(e),
                    h = -this.direction.dot(Ms),
                    u = Ts.dot(this.direction),
                    c = -Ts.dot(Ms),
                    p = Ts.lengthSq(),
                    f = Math.abs(1 - h * h);
                if (f > 0)
                    if (a = h * u - c, o = l * f, (r = h * c - u) >= 0)
                        if (a >= -o)
                            if (a <= o) {
                                var d = 1 / f;
                                s = (r *= d) * (r + h * (a *= d) + 2 * u) + a * (h * r + a + 2 * c) + p
                            } else a = l, s = -(r = Math.max(0, -(h * a + u))) * r + a * (a + 2 * c) + p;
                else a = -l, s = -(r = Math.max(0, -(h * a + u))) * r + a * (a + 2 * c) + p;
                else a <= -o ? s = -(r = Math.max(0, -(-h * l + u))) * r + (a = r > 0 ? -l : Math.min(Math.max(-l, -c), l)) * (a + 2 * c) + p : a <= o ? (r = 0, s = (a = Math.min(Math.max(-l, -c), l)) * (a + 2 * c) + p) : s = -(r = Math.max(0, -(h * l + u))) * r + (a = r > 0 ? l : Math.min(Math.max(-l, -c), l)) * (a + 2 * c) + p;
                else a = h > 0 ? -l : l, s = -(r = Math.max(0, -(h * a + u))) * r + a * (a + 2 * c) + p;
                return n && n.copy(this.direction).multiplyScalar(r).add(this.origin), i && i.copy(Ms).multiplyScalar(a).add(Ss), s
            },
            intersectSphere: function(t, e) {
                Ds.subVectors(t.center, this.origin);
                var n = Ds.dot(this.direction),
                    i = Ds.dot(Ds) - n * n,
                    r = t.radius * t.radius;
                if (i > r) return null;
                var a = Math.sqrt(r - i),
                    s = n - a,
                    o = n + a;
                return s < 0 && o < 0 ? null : s < 0 ? this.at(o, e) : this.at(s, e)
            },
            intersectsSphere: function(t) {
                return this.distanceSqToPoint(t.center) <= t.radius * t.radius
            },
            distanceToPlane: function(t) {
                var e = t.normal.dot(this.direction);
                if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                var n = -(this.origin.dot(t.normal) + t.constant) / e;
                return n >= 0 ? n : null
            },
            intersectPlane: function(t, e) {
                var n = this.distanceToPlane(t);
                return null === n ? null : this.at(n, e)
            },
            intersectsPlane: function(t) {
                var e = t.distanceToPoint(this.origin);
                return 0 === e || t.normal.dot(this.direction) * e < 0
            },
            intersectBox: function(t, e) {
                var n, i, r, a, s, o, l = 1 / this.direction.x,
                    h = 1 / this.direction.y,
                    u = 1 / this.direction.z,
                    c = this.origin;
                return l >= 0 ? (n = (t.min.x - c.x) * l, i = (t.max.x - c.x) * l) : (n = (t.max.x - c.x) * l, i = (t.min.x - c.x) * l), h >= 0 ? (r = (t.min.y - c.y) * h, a = (t.max.y - c.y) * h) : (r = (t.max.y - c.y) * h, a = (t.min.y - c.y) * h), n > a || r > i ? null : ((r > n || n != n) && (n = r), (a < i || i != i) && (i = a), u >= 0 ? (s = (t.min.z - c.z) * u, o = (t.max.z - c.z) * u) : (s = (t.max.z - c.z) * u, o = (t.min.z - c.z) * u), n > o || s > i ? null : ((s > n || n != n) && (n = s), (o < i || i != i) && (i = o), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
            },
            intersectsBox: function(t) {
                return null !== this.intersectBox(t, Ds)
            },
            intersectTriangle: function(t, e, n, i, r) {
                As.subVectors(e, t), Cs.subVectors(n, t), Ps.crossVectors(As, Cs);
                var a, s = this.direction.dot(Ps);
                if (s > 0) {
                    if (i) return null;
                    a = 1
                } else {
                    if (!(s < 0)) return null;
                    a = -1, s = -s
                }
                Ts.subVectors(this.origin, t);
                var o = a * this.direction.dot(Cs.crossVectors(Ts, Cs));
                if (o < 0) return null;
                var l = a * this.direction.dot(As.cross(Ts));
                if (l < 0) return null;
                if (o + l > s) return null;
                var h = -a * Ts.dot(Ps);
                return h < 0 ? null : this.at(h / s, r)
            },
            applyMatrix4: function(t) {
                return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
            },
            equals: function(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
        });
        var Ls = new Rr,
            Rs = new Rr,
            Is = new Rr,
            ks = new Rr,
            Os = new Rr,
            Ns = new Rr,
            Bs = new Rr,
            zs = new Rr,
            Vs = new Rr,
            Us = new Rr;

        function Gs(t, e, n) {
            this.a = void 0 !== t ? t : new Rr, this.b = void 0 !== e ? e : new Rr, this.c = void 0 !== n ? n : new Rr
        }

        function Hs(t) {
            _s.call(this), this.type = "MeshBasicMaterial", this.color = new ma(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t)
        }
        Object.assign(Gs, {
            getNormal: function(t, e, n, i) {
                void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"), i = new Rr), i.subVectors(n, e), Ls.subVectors(t, e), i.cross(Ls);
                var r = i.lengthSq();
                return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
            },
            getBarycoord: function(t, e, n, i, r) {
                Ls.subVectors(i, e), Rs.subVectors(n, e), Is.subVectors(t, e);
                var a = Ls.dot(Ls),
                    s = Ls.dot(Rs),
                    o = Ls.dot(Is),
                    l = Rs.dot(Rs),
                    h = Rs.dot(Is),
                    u = a * l - s * s;
                if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), r = new Rr), 0 === u) return r.set(-2, -1, -1);
                var c = 1 / u,
                    p = (l * o - s * h) * c,
                    f = (a * h - s * o) * c;
                return r.set(1 - p - f, f, p)
            },
            containsPoint: function(t, e, n, i) {
                return Gs.getBarycoord(t, e, n, i, ks), ks.x >= 0 && ks.y >= 0 && ks.x + ks.y <= 1
            },
            getUV: function(t, e, n, i, r, a, s, o) {
                return this.getBarycoord(t, e, n, i, ks), o.set(0, 0), o.addScaledVector(r, ks.x), o.addScaledVector(a, ks.y), o.addScaledVector(s, ks.z), o
            },
            isFrontFacing: function(t, e, n, i) {
                return Ls.subVectors(n, e), Rs.subVectors(t, e), Ls.cross(Rs).dot(i) < 0
            }
        }), Object.assign(Gs.prototype, {
            set: function(t, e, n) {
                return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
            },
            setFromPointsAndIndices: function(t, e, n, i) {
                return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
            },
            getArea: function() {
                return Ls.subVectors(this.c, this.b), Rs.subVectors(this.a, this.b), .5 * Ls.cross(Rs).length()
            },
            getMidpoint: function(t) {
                return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new Rr), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            },
            getNormal: function(t) {
                return Gs.getNormal(this.a, this.b, this.c, t)
            },
            getPlane: function(t) {
                return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new ta), t.setFromCoplanarPoints(this.a, this.b, this.c)
            },
            getBarycoord: function(t, e) {
                return Gs.getBarycoord(t, this.a, this.b, this.c, e)
            },
            getUV: function(t, e, n, i, r) {
                return Gs.getUV(t, this.a, this.b, this.c, e, n, i, r)
            },
            containsPoint: function(t) {
                return Gs.containsPoint(t, this.a, this.b, this.c)
            },
            isFrontFacing: function(t) {
                return Gs.isFrontFacing(this.a, this.b, this.c, t)
            },
            intersectsBox: function(t) {
                return t.intersectsTriangle(this)
            },
            closestPointToPoint: function(t, e) {
                void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new Rr);
                var n, i, r = this.a,
                    a = this.b,
                    s = this.c;
                Os.subVectors(a, r), Ns.subVectors(s, r), zs.subVectors(t, r);
                var o = Os.dot(zs),
                    l = Ns.dot(zs);
                if (o <= 0 && l <= 0) return e.copy(r);
                Vs.subVectors(t, a);
                var h = Os.dot(Vs),
                    u = Ns.dot(Vs);
                if (h >= 0 && u <= h) return e.copy(a);
                var c = o * u - h * l;
                if (c <= 0 && o >= 0 && h <= 0) return n = o / (o - h), e.copy(r).addScaledVector(Os, n);
                Us.subVectors(t, s);
                var p = Os.dot(Us),
                    f = Ns.dot(Us);
                if (f >= 0 && p <= f) return e.copy(s);
                var d = p * l - o * f;
                if (d <= 0 && l >= 0 && f <= 0) return i = l / (l - f), e.copy(r).addScaledVector(Ns, i);
                var m = h * f - p * u;
                if (m <= 0 && u - h >= 0 && p - f >= 0) return Bs.subVectors(s, a), i = (u - h) / (u - h + (p - f)), e.copy(a).addScaledVector(Bs, i);
                var g = 1 / (m + d + c);
                return n = d * g, i = c * g, e.copy(r).addScaledVector(Os, n).addScaledVector(Ns, i)
            },
            equals: function(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        }), Hs.prototype = Object.create(_s.prototype), Hs.prototype.constructor = Hs, Hs.prototype.isMeshBasicMaterial = !0, Hs.prototype.copy = function(t) {
            return _s.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
        };
        var js = new ca,
            Ws = new Fs,
            Xs = new Jr,
            qs = new Rr,
            Ys = new Rr,
            Zs = new Rr,
            Js = new Rr,
            Ks = new Rr,
            $s = new Rr,
            Qs = new Rr,
            to = new Rr,
            eo = new Rr,
            no = new Dr,
            io = new Dr,
            ro = new Dr,
            ao = new Rr,
            so = new Rr;

        function oo(t, e) {
            Ba.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new ds, this.material = void 0 !== e ? e : new Hs, this.updateMorphTargets()
        }

        function lo(t, e, n, i, r, a, s, o) {
            if (null === (1 === e.side ? i.intersectTriangle(s, a, r, !0, o) : i.intersectTriangle(r, a, s, 2 !== e.side, o))) return null;
            so.copy(o), so.applyMatrix4(t.matrixWorld);
            var l = n.ray.origin.distanceTo(so);
            return l < n.near || l > n.far ? null : {
                distance: l,
                point: so.clone(),
                object: t
            }
        }

        function ho(t, e, n, i, r, a, s, o, l, h, u, c) {
            qs.fromBufferAttribute(r, h), Ys.fromBufferAttribute(r, u), Zs.fromBufferAttribute(r, c);
            var p = t.morphTargetInfluences;
            if (e.morphTargets && a && p) {
                Qs.set(0, 0, 0), to.set(0, 0, 0), eo.set(0, 0, 0);
                for (var f = 0, d = a.length; f < d; f++) {
                    var m = p[f],
                        g = a[f];
                    0 !== m && (Js.fromBufferAttribute(g, h), Ks.fromBufferAttribute(g, u), $s.fromBufferAttribute(g, c), s ? (Qs.addScaledVector(Js, m), to.addScaledVector(Ks, m), eo.addScaledVector($s, m)) : (Qs.addScaledVector(Js.sub(qs), m), to.addScaledVector(Ks.sub(Ys), m), eo.addScaledVector($s.sub(Zs), m)))
                }
                qs.add(Qs), Ys.add(to), Zs.add(eo)
            }
            t.isSkinnedMesh && (t.boneTransform(h, qs), t.boneTransform(u, Ys), t.boneTransform(c, Zs));
            var v = lo(t, e, n, i, qs, Ys, Zs, ao);
            if (v) {
                o && (no.fromBufferAttribute(o, h), io.fromBufferAttribute(o, u), ro.fromBufferAttribute(o, c), v.uv = Gs.getUV(ao, qs, Ys, Zs, no, io, ro, new Dr)), l && (no.fromBufferAttribute(l, h), io.fromBufferAttribute(l, u), ro.fromBufferAttribute(l, c), v.uv2 = Gs.getUV(ao, qs, Ys, Zs, no, io, ro, new Dr));
                var y = new Ga(h, u, c);
                Gs.getNormal(qs, Ys, Zs, y.normal), v.face = y
            }
            return v
        }
        oo.prototype = Object.assign(Object.create(Ba.prototype), {
            constructor: oo,
            isMesh: !0,
            copy: function(t) {
                return Ba.prototype.copy.call(this, t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this
            },
            updateMorphTargets: function() {
                var t, e, n, i = this.geometry;
                if (i.isBufferGeometry) {
                    var r = i.morphAttributes,
                        a = Object.keys(r);
                    if (a.length > 0) {
                        var s = r[a[0]];
                        if (void 0 !== s)
                            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = s.length; t < e; t++) n = s[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                    }
                } else {
                    var o = i.morphTargets;
                    void 0 !== o && o.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            },
            raycast: function(t, e) {
                var n, i = this.geometry,
                    r = this.material,
                    a = this.matrixWorld;
                if (void 0 !== r && (null === i.boundingSphere && i.computeBoundingSphere(), Xs.copy(i.boundingSphere), Xs.applyMatrix4(a), !1 !== t.ray.intersectsSphere(Xs) && (js.getInverse(a), Ws.copy(t.ray).applyMatrix4(js), null === i.boundingBox || !1 !== Ws.intersectsBox(i.boundingBox))))
                    if (i.isBufferGeometry) {
                        var s, o, l, h, u, c, p, f, d, m = i.index,
                            g = i.attributes.position,
                            v = i.morphAttributes.position,
                            y = i.morphTargetsRelative,
                            _ = i.attributes.uv,
                            x = i.attributes.uv2,
                            b = i.groups,
                            E = i.drawRange;
                        if (null !== m)
                            if (Array.isArray(r))
                                for (h = 0, c = b.length; h < c; h++)
                                    for (d = r[(f = b[h]).materialIndex], u = Math.max(f.start, E.start), p = Math.min(f.start + f.count, E.start + E.count); u < p; u += 3) s = m.getX(u), o = m.getX(u + 1), l = m.getX(u + 2), (n = ho(this, d, t, Ws, g, v, y, _, x, s, o, l)) && (n.faceIndex = Math.floor(u / 3), n.face.materialIndex = f.materialIndex, e.push(n));
                            else
                                for (h = Math.max(0, E.start), c = Math.min(m.count, E.start + E.count); h < c; h += 3) s = m.getX(h), o = m.getX(h + 1), l = m.getX(h + 2), (n = ho(this, r, t, Ws, g, v, y, _, x, s, o, l)) && (n.faceIndex = Math.floor(h / 3), e.push(n));
                        else if (void 0 !== g)
                            if (Array.isArray(r))
                                for (h = 0, c = b.length; h < c; h++)
                                    for (d = r[(f = b[h]).materialIndex], u = Math.max(f.start, E.start), p = Math.min(f.start + f.count, E.start + E.count); u < p; u += 3)(n = ho(this, d, t, Ws, g, v, y, _, x, s = u, o = u + 1, l = u + 2)) && (n.faceIndex = Math.floor(u / 3), n.face.materialIndex = f.materialIndex, e.push(n));
                            else
                                for (h = Math.max(0, E.start), c = Math.min(g.count, E.start + E.count); h < c; h += 3)(n = ho(this, r, t, Ws, g, v, y, _, x, s = h, o = h + 1, l = h + 2)) && (n.faceIndex = Math.floor(h / 3), e.push(n))
                    } else if (i.isGeometry) {
                    var w, D, S, M, T = Array.isArray(r),
                        A = i.vertices,
                        C = i.faces,
                        P = i.faceVertexUvs[0];
                    P.length > 0 && (M = P);
                    for (var F = 0, L = C.length; F < L; F++) {
                        var R = C[F],
                            I = T ? r[R.materialIndex] : r;
                        if (void 0 !== I && (w = A[R.a], D = A[R.b], S = A[R.c], n = lo(this, I, t, Ws, w, D, S, ao))) {
                            if (M && M[F]) {
                                var k = M[F];
                                no.copy(k[0]), io.copy(k[1]), ro.copy(k[2]), n.uv = Gs.getUV(ao, w, D, S, no, io, ro, new Dr)
                            }
                            n.face = R, n.faceIndex = F, e.push(n)
                        }
                    }
                }
            },
            clone: function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        });
        var uo = {
                alphamap_fragment: "\n#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n",
                alphamap_pars_fragment: "\n#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n",
                alphatest_fragment: "\n#ifdef ALPHATEST\n\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n",
                aomap_fragment: "\n#ifdef USE_AOMAP\n\n\t// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\n\t#endif\n\n#endif\n",
                aomap_pars_fragment: "\n#ifdef USE_AOMAP\n\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n\n#endif\n",
                begin_vertex: "\nvec3 transformed = vec3( position );\n",
                beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n\n#ifdef USE_TANGENT\n\n\tvec3 objectTangent = vec3( tangent.xyz );\n\n#endif\n",
                bsdfs: '\n\n// Analytical approximation of the DFG LUT, one half of the\n// split-sum approximation used in indirect specular lighting.\n// via \'environmentBRDF\' from "Physically Based Shading on Mobile"\n// https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n\tvec4 r = roughness * c0 + c1;\n\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n}\n\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t// page 32, equation 26: E[window1]\n\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t// this is intended to be used on spot and point lights who are represented as luminous intensity\n\t// but who must be converted to luminous irradiance for surface lighting calculation\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\n\tif( cutoffDistance > 0.0 ) {\n\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\n\t}\n\n\treturn distanceFalloff;\n\n#else\n\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n\t}\n\n\treturn 1.0;\n\n#endif\n\n}\n\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\n\treturn RECIPROCAL_PI * diffuseColor;\n\n} // validated\n\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\n\t// Original approximation by Christophe Schlick \'94\n\t// float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH \'13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n\n} // validated\n\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\n\t// See F_Schlick\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\n\treturn Fr * fresnel + F0;\n\n}\n\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (34)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is "roughness squared" in Disney’s reparameterization\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\t// geometry term (normalized) = G(l)⋅G(v) / 4(n⋅l)(n⋅v)\n\t// also see #12151\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\n\treturn 1.0 / ( gl * gv );\n\n} // validated\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\tfloat a2 = pow2( alpha );\n\n\t// dotNL and dotNV are explicitly swapped. This is not a mistake.\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n\treturn 0.5 / max( gv + gl, EPSILON );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is "roughness squared" in Disney’s reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat alpha = pow2( roughness ); // UE4\'s roughness\n\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n\tfloat D = D_GGX( alpha, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n\tfloat dotNV = saturate( dot( N, V ) );\n\n\t// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\treturn uv;\n\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\n\t// Real-Time Area Lighting: a Journey from Research to Production (p.102)\n\t// An approximation of the form factor of a horizon-clipped rectangle.\n\n\tfloat l = length( f );\n\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\n\tfloat x = dot( v1, v2 );\n\n\tfloat y = abs( x );\n\n\t// rational polynomial approximation to theta / sin( theta ) / 2PI\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\n\treturn cross( v1, v2 ) * theta_sintheta;\n\n}\n\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\n\t// bail if point is on back side of plane of light\n\t// assumes ccw winding order of light vertices\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\n\t// construct orthonormal basis around N\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n\n\t// compute transform\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\n\t// transform rect\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\n\t// project rect onto sphere\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\n\t// calculate vector form factor\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\n\t// adjust for horizon clipping\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n/*\n\t// alternate method of adjusting for horizon clipping (see referece)\n\t// refactoring required\n\tfloat len = length( vectorFormFactor );\n\tfloat z = vectorFormFactor.z / len;\n\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n\t// tabulated horizon-clipped sphere, apparently...\n\tvec2 uv = vec2( z * 0.5 + 0.5, len );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\tfloat scale = texture2D( ltc_2, uv ).w;\n\n\tfloat result = len * scale;\n*/\n\n\treturn vec3( result );\n\n}\n\n// End Rect Area Light\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\n\treturn specularColor * brdf.x + brdf.y;\n\n} // validated\n\n// Fdez-Agüera\'s "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"\n// Approximates multiscattering in order to preserve energy.\n// http://www.jcgt.org/published/0008/01/03/\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619; // 1/21\n\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n\n\t// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n\treturn 0.25;\n\n}\n\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n\t//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\t//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\n\tfloat G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\n\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n\n#if defined( USE_SHEEN )\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L94\nfloat D_Charlie(float roughness, float NoH) {\n\t// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125); // 2^(-14/2), so sin2h^2 > 0 in fp16\n\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L136\nfloat V_Neubelt(float NoV, float NoL) {\n\t// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\n\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n\n}\n\n#endif\n',
                bumpmap_pars_fragment: "\n#ifdef USE_BUMPMAP\n\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\n\t// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n\t// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\tvec2 dHdxy_fwd() {\n\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n\t\treturn vec2( dBx, dBy );\n\n\t}\n\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\t\t// normalized\n\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\n\t}\n\n#endif\n",
                clipping_planes_fragment: "\n#if NUM_CLIPPING_PLANES > 0\n\n\tvec4 plane;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\n\t\tbool clipped = true;\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t\tif ( clipped ) discard;\n\n\t#endif\n\n#endif\n",
                clipping_planes_pars_fragment: "\n#if NUM_CLIPPING_PLANES > 0\n\n\tvarying vec3 vClipPosition;\n\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n\n#endif\n",
                clipping_planes_pars_vertex: "\n#if NUM_CLIPPING_PLANES > 0\n\n\tvarying vec3 vClipPosition;\n\n#endif\n",
                clipping_planes_vertex: "\n#if NUM_CLIPPING_PLANES > 0\n\n\tvClipPosition = - mvPosition.xyz;\n\n#endif\n",
                color_fragment: "\n#ifdef USE_COLOR\n\n\tdiffuseColor.rgb *= vColor;\n\n#endif\n",
                color_pars_fragment: "\n#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif\n",
                color_pars_vertex: "\n#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif\n",
                color_vertex: "\n#ifdef USE_COLOR\n\n\tvColor.xyz = color.xyz;\n\n#endif\n",
                common: "\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#ifndef saturate\n// <tonemapping_pars_fragment> may have defined saturate() already\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\n\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\n\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t// dir can be either a direction vector or a normal vector\n\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\n\treturn - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nmat3 transposeMat3( const in mat3 m ) {\n\n\tmat3 tmp;\n\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\n\treturn tmp;\n\n}\n\n// https://en.wikipedia.org/wiki/Relative_luminance\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\n\treturn dot( weights, color.rgb );\n\n}\n\nbool isPerspectiveMatrix( mat4 m ) {\n\n  return m[ 2 ][ 3 ] == - 1.0;\n\n}\n",
                cube_uv_reflection_fragment: "\n#ifdef ENVMAP_TYPE_CUBE_UV\n\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\n\n// These shader functions convert between the UV coordinates of a single face of\n// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n// sampling a textureCube (not generally normalized).\n\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\n\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1.0) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2.0) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4.0) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\n\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n\n// These defines must match with PMREMGenerator\n\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\n\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25\n  }\n  return mip;\n}\n\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif\n",
                defaultnormal_vertex: "\nvec3 transformedNormal = objectNormal;\n\n#ifdef USE_INSTANCING\n\n\t// this is in lieu of a per-instance normal-matrix\n\t// shear transforms in the instance matrix are not supported\n\n\tmat3 m = mat3( instanceMatrix );\n\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\n\ttransformedNormal = m * transformedNormal;\n\n#endif\n\ntransformedNormal = normalMatrix * transformedNormal;\n\n#ifdef FLIP_SIDED\n\n\ttransformedNormal = - transformedNormal;\n\n#endif\n\n#ifdef USE_TANGENT\n\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n\t#ifdef FLIP_SIDED\n\n\t\ttransformedTangent = - transformedTangent;\n\n\t#endif\n\n#endif\n",
                displacementmap_pars_vertex: "\n#ifdef USE_DISPLACEMENTMAP\n\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n\n#endif\n",
                displacementmap_vertex: "\n#ifdef USE_DISPLACEMENTMAP\n\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n\n#endif\n",
                emissivemap_fragment: "\n#ifdef USE_EMISSIVEMAP\n\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n\n#endif\n",
                emissivemap_pars_fragment: "\n#ifdef USE_EMISSIVEMAP\n\n\tuniform sampler2D emissiveMap;\n\n#endif\n",
                encodings_fragment: "\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n",
                encodings_pars_fragment: "\n// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\n\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\n\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\n\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\n\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\n\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\n\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\n\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\n\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\n\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\t// NOTE: The implementation with min causes the shader to not compile on\n\t// a common Alcatel A502DL in Chrome 78/Android 8.1. Some research suggests \n\t// that the chipset is Mediatek MT6739 w/ IMG PowerVR GE8100 GPU.\n\t// D = min( floor( D ) / 255.0, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\n\n// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\n\n// M matrix, for encoding\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\n\n// Inverse M matrix, for decoding\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}\n",
                envmap_fragment: "\n#ifdef USE_ENVMAP\n\n\t#ifdef ENV_WORLDPOS\n\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\n\t\t}  else {\n\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\n\t\t}\n\n\t\t// Transforming Normal Vectors with the Inverse Transformation\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#else\n\n\t\tvec3 reflectVec = vReflect;\n\n\t#endif\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\n\t\tvec2 sampleUV;\n\n\t\treflectVec = normalize( reflectVec );\n\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\n\t\treflectVec = normalize( reflectVec );\n\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\n\t#else\n\n\t\tvec4 envColor = vec4( 0.0 );\n\n\t#endif\n\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\n\t\tenvColor = envMapTexelToLinear( envColor );\n\n\t#endif\n\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n\t#endif\n\n#endif\n",
                envmap_common_pars_fragment: "\n#ifdef USE_ENVMAP\n\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n",
                envmap_pars_fragment: "\n#ifdef USE_ENVMAP\n\n\tuniform float reflectivity;\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\t#define ENV_WORLDPOS\n\n\t#endif\n\n\t#ifdef ENV_WORLDPOS\n\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n\n#endif\n",
                envmap_pars_vertex: "\n#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\n\t\t#define ENV_WORLDPOS\n\n\t#endif\n\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\n\t#else\n\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\n\t#endif\n\n#endif\n",
                envmap_physical_pars_fragment: "\n#if defined( USE_ENVMAP )\n\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\n\tvec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\n\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\n\t\t\t// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\n\t\t\t// of a specular cubemap, or just the default level of a specially created irradiance cubemap.\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\n\t\t\t#else\n\n\t\t\t\t// force the bias high to get the last LOD level as it is the most blurred.\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\n\t\t#else\n\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\n\t\t#endif\n\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\n\t}\n\n\t// Trowbridge-Reitz distribution to Mip level, following the logic of http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\n\t\t// clamp to allowable LOD ranges.\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n\t}\n\n\tvec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\n\t\t  // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\n\t\t#else\n\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\n\t\t#endif\n\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#endif\n\n\t\treturn envMapColor.rgb * envMapIntensity;\n\n\t}\n\n#endif\n",
                envmap_vertex: "\n#ifdef USE_ENVMAP\n\n\t#ifdef ENV_WORLDPOS\n\n\t\tvWorldPosition = worldPosition.xyz;\n\n\t#else\n\n\t\tvec3 cameraToVertex;\n\n\t\tif ( isOrthographic ) { \n\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\n\t\t} else {\n\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n\t\t}\n\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#endif\n\n#endif\n",
                fog_vertex: "\n#ifdef USE_FOG\n\n\tfogDepth = -mvPosition.z;\n\n#endif\n",
                fog_pars_vertex: "\n#ifdef USE_FOG\n\n\tvarying float fogDepth;\n\n#endif\n",
                fog_fragment: "\n#ifdef USE_FOG\n\n\t#ifdef FOG_EXP2\n\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\n\t#else\n\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\n\t#endif\n\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\n#endif\n",
                fog_pars_fragment: "\n#ifdef USE_FOG\n\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\n\t#ifdef FOG_EXP2\n\n\t\tuniform float fogDensity;\n\n\t#else\n\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\n\t#endif\n\n#endif\n",
                gradientmap_pars_fragment: "\n\n#ifdef USE_GRADIENTMAP\n\n\tuniform sampler2D gradientMap;\n\n#endif\n\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\n\t// dotNL will be from -1.0 to 1.0\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\n\t#ifdef USE_GRADIENTMAP\n\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\n\t#else\n\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\n\t#endif\n\n}\n\n",
                lightmap_fragment: "\n#ifdef USE_LIGHTMAP\n\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage\n\n#endif\n",
                lightmap_pars_fragment: "\n#ifdef USE_LIGHTMAP\n\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n\n#endif\n",
                lights_lambert_vertex: "\nvec3 diffuse = vec3( 1.0 );\n\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\n\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\n\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\n\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\n\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n\n#ifdef DOUBLE_SIDED\n\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n\n#endif\n\n#if NUM_POINT_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if NUM_SPOT_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n/*\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\t// TODO (abelnation): implement\n\n\t}\n\n#endif\n*/\n\n#if NUM_DIR_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if NUM_HEMI_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\n\t\t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n",
                lights_pars_begin: "\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\n\n// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\n\t// normal is assumed to have unit length\n\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\n\t// band 0\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\n\t// band 1\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\n\t// band 2\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\n\treturn result;\n\n}\n\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\n\treturn irradiance;\n\n}\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n\tvec3 irradiance = ambientLightColor;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI;\n\n\t#endif\n\n\treturn irradiance;\n\n}\n\n#if NUM_DIR_LIGHTS > 0\n\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\n\t}\n\n#endif\n\n\n#if NUM_POINT_LIGHTS > 0\n\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\n\t}\n\n#endif\n\n\n#if NUM_SPOT_LIGHTS > 0\n\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\n\t\tif ( angleCos > spotLight.coneCos ) {\n\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\n\t\t} else {\n\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\n\t\t}\n\t}\n\n#endif\n\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\n\t// Pre-computed values of LinearTransformedCosine approximation of BRDF\n\t// BRDF approximation Texture is 64x64\n\tuniform sampler2D ltc_1; // RGBA Float\n\tuniform sampler2D ltc_2; // RGBA Float\n\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n\n#endif\n\n\n#if NUM_HEMI_LIGHTS > 0\n\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\tirradiance *= PI;\n\n\t\t#endif\n\n\t\treturn irradiance;\n\n\t}\n\n#endif\n",
                lights_toon_fragment: "\nToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
                lights_toon_pars_fragment: "\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n\nstruct ToonMaterial {\n\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n\n};\n\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI; // punctual light\n\n\t#endif\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n\n#define Material_LightProbeLOD( material )\t(0)\n",
                lights_phong_fragment: "\nBlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
                lights_phong_pars_fragment: "\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n\nstruct BlinnPhongMaterial {\n\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n\n};\n\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI; // punctual light\n\n\t#endif\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n\n#define Material_LightProbeLOD( material )\t(0)\n",
                lights_physical_fragment: "\nPhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\n\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\n\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.\nmaterial.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n\n#ifdef REFLECTIVITY\n\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\n#else\n\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n\n#endif\n\n#ifdef CLEARCOAT\n\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\n\t#ifdef USE_CLEARCOATMAP\n\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\n\t#endif\n\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\n\t#endif\n\n\tmaterial.clearcoat = saturate( material.clearcoat ); // Burley clearcoat model\n\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n\n#endif\n\n#ifdef USE_SHEEN\n\n\tmaterial.sheenColor = sheen;\n\n#endif\n",
                lights_physical_pars_fragment: "\nstruct PhysicalMaterial {\n\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n\n};\n\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n// Clear coat directional hemishperical reflectance (this approximation should be improved)\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n\n}\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction\n\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\n\t\t// LTC Fresnel Approximation by Stephen Hill\n\t\t// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\n\t}\n\n#endif\n\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n\tvec3 irradiance = dotNL * directLight.color;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI; // punctual light\n\n\t#endif\n\n\t#ifdef CLEARCOAT\n\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\tccIrradiance *= PI; // punctual light\n\n\t\t#endif\n\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\n\t#else\n\n\t\tfloat clearcoatDHR = 0.0;\n\n\t#endif\n\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\n\t#ifdef CLEARCOAT\n\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\n\t#else\n\n\t\tfloat clearcoatDHR = 0.0;\n\n\t#endif\n\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\n\t// Both indirect specular and indirect diffuse light accumulate here\n\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n\n// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n",
                lights_fragment_begin: "\n/**\n * This is a template that can be used to light a material, it uses pluggable\n * RenderEquations (RE)for specific lighting scenarios.\n *\n * Instructions for use:\n * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???\n * - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n *\n * TODO:\n * - Add area light support.\n * - Add sphere light support.\n * - Add diffuse light probe (irradiance cubemap) support.\n */\n\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n#ifdef CLEARCOAT\n\n\tgeometry.clearcoatNormal = clearcoatNormal;\n\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 iblIrradiance = vec3( 0.0 );\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n\n#endif\n",
                lights_fragment_maps: "\n#if defined( RE_IndirectDiffuse )\n\n\t#ifdef USE_LIGHTMAP\n\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\tlightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\n\n\t\t#endif\n\n\t\tirradiance += lightMapIrradiance;\n\n\t#endif\n\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, maxMipLevel );\n\n\t#endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\n\tradiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\n\t#ifdef CLEARCOAT\n\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\n\t#endif\n\n#endif\n",
                lights_fragment_end: "\n#if defined( RE_IndirectDiffuse )\n\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n\n#endif\n",
                logdepthbuf_fragment: "\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\t// Doing a strict comparison with == 1.0 can cause noise artifacts\n\t// on some platforms. See issue #17623.\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n\n#endif\n",
                logdepthbuf_pars_fragment: "\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n\n#endif\n",
                logdepthbuf_pars_vertex: "\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\n\t#else\n\n\t\tuniform float logDepthBufFC;\n\n\t#endif\n\n#endif\n",
                logdepthbuf_vertex: "\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\n\t#else\n\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\n\t\t\tgl_Position.z *= gl_Position.w;\n\n\t\t}\n\n\t#endif\n\n#endif\n",
                map_fragment: "\n#ifdef USE_MAP\n\n\tvec4 texelColor = texture2D( map, vUv );\n\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n\n#endif\n",
                map_pars_fragment: "\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif\n",
                map_particle_fragment: "\n#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\n#endif\n\n#ifdef USE_MAP\n\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n\n#endif\n\n#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n\n#endif\n",
                map_particle_pars_fragment: "\n#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\n\tuniform mat3 uvTransform;\n\n#endif\n\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif\n\n#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n",
                metalnessmap_fragment: "\nfloat metalnessFactor = metalness;\n\n#ifdef USE_METALNESSMAP\n\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\n\t// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tmetalnessFactor *= texelMetalness.b;\n\n#endif\n",
                metalnessmap_pars_fragment: "\n#ifdef USE_METALNESSMAP\n\n\tuniform sampler2D metalnessMap;\n\n#endif\n",
                morphnormal_vertex: "\n#ifdef USE_MORPHNORMALS\n\n\t// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n\t// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)\n\t// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\n#endif\n",
                morphtarget_pars_vertex: "\n#ifdef USE_MORPHTARGETS\n\n\tuniform float morphTargetBaseInfluence;\n\n\t#ifndef USE_MORPHNORMALS\n\n\tuniform float morphTargetInfluences[ 8 ];\n\n\t#else\n\n\tuniform float morphTargetInfluences[ 4 ];\n\n\t#endif\n\n#endif\n",
                morphtarget_vertex: "\n#ifdef USE_MORPHTARGETS\n\n\t// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n\t// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)\n\t// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\n\t#ifndef USE_MORPHNORMALS\n\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\n\t#endif\n\n#endif\n",
                normal_fragment_begin: "\n#ifdef FLAT_SHADED\n\n\t// Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n\n#else\n\n\tvec3 normal = normalize( vNormal );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t#endif\n\n\t#ifdef USE_TANGENT\n\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\t#endif\n\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t#endif\n\n\t#endif\n\n#endif\n\n// non perturbed normal for clearcoat among others\n\nvec3 geometryNormal = normal;\n\n",
                normal_fragment_maps: "\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n\t#ifdef FLIP_SIDED\n\n\t\tnormal = - normal;\n\n\t#endif\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t#endif\n\n\tnormal = normalize( normalMatrix * normal );\n\n#elif defined( TANGENTSPACE_NORMALMAP )\n\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\n\t#ifdef USE_TANGENT\n\n\t\tnormal = normalize( vTBN * mapN );\n\n\t#else\n\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\n\t#endif\n\n#elif defined( USE_BUMPMAP )\n\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n",
                normalmap_pars_fragment: "\n#ifdef USE_NORMALMAP\n\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\n#endif\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n\tuniform mat3 normalMatrix;\n\n#endif\n\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\n\t// Per-Pixel Tangent Space Normal Mapping\n\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\n\t\tmat3 tsn = mat3( S, T, N );\n\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\treturn normalize( tsn * mapN );\n\n\t}\n\n#endif\n",
                clearcoat_normal_fragment_begin: "\n#ifdef CLEARCOAT\n\n\tvec3 clearcoatNormal = geometryNormal;\n\n#endif\n",
                clearcoat_normal_fragment_maps: "\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\n\t#ifdef USE_TANGENT\n\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\n\t#else\n\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\n\t#endif\n\n#endif\n",
                clearcoat_pars_fragment: "\n\n#ifdef USE_CLEARCOATMAP\n\n\tuniform sampler2D clearcoatMap;\n\n#endif\n\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\tuniform sampler2D clearcoatRoughnessMap;\n\n#endif\n\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n\n#endif\n",
                packing: "\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\n\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\n\treturn r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\n\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\n\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\n\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
                premultiplied_alpha_fragment: "\n#ifdef PREMULTIPLIED_ALPHA\n\n\t// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\n\tgl_FragColor.rgb *= gl_FragColor.a;\n\n#endif\n",
                project_vertex: "\nvec4 mvPosition = vec4( transformed, 1.0 );\n\n#ifdef USE_INSTANCING\n\n\tmvPosition = instanceMatrix * mvPosition;\n\n#endif\n\nmvPosition = modelViewMatrix * mvPosition;\n\ngl_Position = projectionMatrix * mvPosition;\n",
                dithering_fragment: "\n#ifdef DITHERING\n\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\n#endif\n",
                dithering_pars_fragment: "\n#ifdef DITHERING\n\n\t// based on https://www.shadertoy.com/view/MslGR8\n\tvec3 dithering( vec3 color ) {\n\t\t//Calculate grid position\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\n\t\t//Shift the individual colors differently, thus making it even harder to see the dithering pattern\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\n\t\t//modify shift acording to grid position.\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\n\t\t//shift the color by dither_shift\n\t\treturn color + dither_shift_RGB;\n\t}\n\n#endif\n",
                roughnessmap_fragment: "\nfloat roughnessFactor = roughness;\n\n#ifdef USE_ROUGHNESSMAP\n\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\n\t// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\troughnessFactor *= texelRoughness.g;\n\n#endif\n",
                roughnessmap_pars_fragment: "\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform sampler2D roughnessMap;\n\n#endif\n",
                shadowmap_pars_fragment: "\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): create uniforms for area light shadows\n\n\t#endif\n\t*/\n\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n\t}\n\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n\t}\n\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n\t\tfloat occlusion = 1.0;\n\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\n\t\tfloat hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n\t\tif (hard_shadow != 1.0 ) {\n\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n\t\t}\n\t\treturn occlusion;\n\n\t}\n\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n\t\tfloat shadow = 1.0;\n\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\n\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t// if ( all( something, something ) ) using this instead\n\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\tbool frustumTest = all( frustumTestVec );\n\n\t\tif ( frustumTest ) {\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#else // no percentage-closer filtering:\n\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#endif\n\n\t\t}\n\n\t\treturn shadow;\n\n\t}\n\n\t// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n\t// vector suitable for 2D texture mapping. This code uses the following layout for the\n\t// 2D texture:\n\t//\n\t// xzXZ\n\t//  y Y\n\t//\n\t// Y - Positive y direction\n\t// y - Negative y direction\n\t// X - Positive x direction\n\t// x - Negative x direction\n\t// Z - Positive z direction\n\t// z - Negative z direction\n\t//\n\t// Source and test bed:\n\t// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\t\t// Number of texels to avoid at the edge of each square\n\n\t\tvec3 absV = abs( v );\n\n\t\t// Intersect unit cube\n\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\n\t\t// Apply scale to avoid seams\n\n\t\t// two texels less per square (one texel will do for NEAREST)\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\t\t// Unwrap\n\n\t\t// space: -1 ... 1 range for each square\n\t\t//\n\t\t// #X##\t\tdim    := ( 4 , 2 )\n\t\t//  # #\t\tcenter := ( 1 , 1 )\n\n\t\tvec2 planar = v.xy;\n\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\n\t\tif ( absV.z >= almostOne ) {\n\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\n\t\t} else if ( absV.x >= almostOne ) {\n\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\n\t\t} else if ( absV.y >= almostOne ) {\n\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\n\t\t}\n\n\t\t// Transform to UV space\n\n\t\t// scale := 0.5 / dim\n\t\t// translate := ( center + 0.5 ) / dim\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n\t}\n\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n\t\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t\t// the vector from the light to the world-space position of the fragment.\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\n\t\t// dp = normalized distance from light to fragment position\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n\t\tdp += shadowBias;\n\n\t\t// bd3D = base direction 3D\n\t\tvec3 bd3D = normalize( lightToPosition );\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#else // no percentage-closer filtering\n\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n\t\t#endif\n\n\t}\n\n#endif\n",
                shadowmap_pars_vertex: "\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): uniforms for area light shadows\n\n\t#endif\n\t*/\n\n#endif\n",
                shadowmap_vertex: "\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): update vAreaShadowCoord with area light info\n\n\t#endif\n\t*/\n\n#endif\n",
                shadowmask_pars_fragment: "\nfloat getShadowMask() {\n\n\tfloat shadow = 1.0;\n\n\t#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\tDirectionalLightShadow directionalLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\tSpotLightShadow spotLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\tPointLightShadow pointLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): update shadow for Area light\n\n\t#endif\n\t*/\n\n\t#endif\n\n\treturn shadow;\n\n}\n",
                skinbase_vertex: "\n#ifdef USE_SKINNING\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif\n",
                skinning_pars_vertex: "\n#ifdef USE_SKINNING\n\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\n\t#ifdef BONE_TEXTURE\n\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\n\t\t\ty = dy * ( y + 0.5 );\n\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t#else\n\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\n\t\t}\n\n\t#endif\n\n#endif\n",
                skinning_vertex: "\n#ifdef USE_SKINNING\n\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n\n#endif\n",
                skinnormal_vertex: "\n#ifdef USE_SKINNING\n\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n\t#ifdef USE_TANGENT\n\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n\t#endif\n\n#endif\n",
                specularmap_fragment: "\nfloat specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n\n#else\n\n\tspecularStrength = 1.0;\n\n#endif\n",
                specularmap_pars_fragment: "\n#ifdef USE_SPECULARMAP\n\n\tuniform sampler2D specularMap;\n\n#endif\n",
                tonemapping_fragment: "\n#if defined( TONE_MAPPING )\n\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\n#endif\n",
                tonemapping_pars_fragment: "\n#ifndef saturate\n// <common> may have defined saturate() already\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\n\n// exposure only\nvec3 LinearToneMapping( vec3 color ) {\n\n\treturn toneMappingExposure * color;\n\n}\n\n// source: https://www.cs.utah.edu/~reinhard/cdrom/\nvec3 ReinhardToneMapping( vec3 color ) {\n\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\n\t// John Hable's filmic operator from Uncharted 2 video game\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\n\t// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n\n}\n\n// source: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n\n}\n",
                uv_pars_fragment: "\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\n\tvarying vec2 vUv;\n\n#endif\n",
                uv_pars_vertex: "\n#ifdef USE_UV\n\n\t#ifdef UVS_VERTEX_ONLY\n\n\t\tvec2 vUv;\n\n\t#else\n\n\t\tvarying vec2 vUv;\n\n\t#endif\n\n\tuniform mat3 uvTransform;\n\n#endif\n",
                uv_vertex: "\n#ifdef USE_UV\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n#endif\n",
                uv2_pars_fragment: "\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvarying vec2 vUv2;\n\n#endif\n",
                uv2_pars_vertex: "\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\n\tuniform mat3 uv2Transform;\n\n#endif\n",
                uv2_vertex: "\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n\n#endif\n",
                worldpos_vertex: "\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\n\t#ifdef USE_INSTANCING\n\n\t\tworldPosition = instanceMatrix * worldPosition;\n\n\t#endif\n\n\tworldPosition = modelMatrix * worldPosition;\n\n#endif\n",
                background_frag: "\nuniform sampler2D t2D;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n\tvec4 texColor = texture2D( t2D, vUv );\n\n\tgl_FragColor = mapTexelToLinear( texColor );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n",
                background_vert: "\nvarying vec2 vUv;\nuniform mat3 uvTransform;\n\nvoid main() {\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n\n}\n",
                cube_frag: "\n\n#include <envmap_common_pars_fragment>\nuniform float opacity;\n\nvarying vec3 vWorldDirection;\n\n#include <cube_uv_reflection_fragment>\n\nvoid main() {\n\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n",
                cube_vert: "\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n\tgl_Position.z = gl_Position.w; // set z to camera.far\n\n}\n",
                depth_frag: "\n#if DEPTH_PACKING == 3200\n\n\tuniform float opacity;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tdiffuseColor.a = opacity;\n\n\t#endif\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\t#include <logdepthbuf_fragment>\n\n\t// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\n\t#elif DEPTH_PACKING == 3201\n\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\n\t#endif\n\n}\n",
                depth_vert: "\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.\n// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for\n// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvHighPrecisionZW = gl_Position.zw;\n\n}\n",
                distanceRGBA_frag: "\n#define DISTANCE\n\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main () {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\n\n\tgl_FragColor = packDepthToRGBA( dist );\n\n}\n",
                distanceRGBA_vert: "\n#define DISTANCE\n\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvWorldPosition = worldPosition.xyz;\n\n}\n",
                equirect_frag: "\nuniform sampler2D tEquirect;\n\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvec3 direction = normalize( vWorldDirection );\n\n\tvec2 sampleUV;\n\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\n\tgl_FragColor = mapTexelToLinear( texColor );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n",
                equirect_vert: "\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n}\n",
                linedashed_frag: "\nuniform vec3 diffuse;\nuniform float opacity;\n\nuniform float dashSize;\nuniform float totalSize;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\n\t\tdiscard;\n\n\t}\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\n\toutgoingLight = diffuseColor.rgb; // simple shader\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\n}\n",
                linedashed_vert: "\nuniform float scale;\nattribute float lineDistance;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\tvLineDistance = scale * lineDistance;\n\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n}\n",
                meshbasic_frag: "\nuniform vec3 diffuse;\nuniform float opacity;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n\t// accumulation (baked indirect lighting only)\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\n\t#else\n\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\n\t#endif\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
                meshbasic_vert: "\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_ENVMAP\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n\n}\n",
                meshlambert_frag: "\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\n\t#ifdef DOUBLE_SIDED\n\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\n\t#else\n\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\n\t#endif\n\n\t#include <lightmap_fragment>\n\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\n\t#else\n\n\t\treflectedLight.directDiffuse = vLightFront;\n\n\t#endif\n\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\n\t// modulation\n\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                meshlambert_vert: "\n#define LAMBERT\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                meshmatcap_frag: "\n#define MATCAP\n\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n\n\t#ifdef USE_MATCAP\n\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\n\t#else\n\n\t\tvec4 matcapColor = vec4( 1.0 );\n\n\t#endif\n\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
                meshmatcap_vert: "\n#define MATCAP\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\t\tvNormal = normalize( transformedNormal );\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n}\n",
                meshtoon_frag: "\n#define TOON\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
                meshtoon_vert: "\n#define TOON\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n",
                meshphong_frag: "\n#define PHONG\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
                meshphong_vert: "\n#define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n",
                meshphysical_frag: "\n#define STANDARD\n\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t// this is a stub for the transparency model\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
                meshphysical_vert: "\n#define STANDARD\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n\t#ifdef USE_TANGENT\n\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\n\t#endif\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n",
                normal_frag: "\n#define NORMAL\n\nuniform float opacity;\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n\tvarying vec3 vViewPosition;\n\n#endif\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\n}\n",
                normal_vert: "\n#define NORMAL\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n\tvarying vec3 vViewPosition;\n\n#endif\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n\t#ifdef USE_TANGENT\n\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\n\t#endif\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n\tvViewPosition = - mvPosition.xyz;\n\n#endif\n\n}\n",
                points_frag: "\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\n\toutgoingLight = diffuseColor.rgb;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\n}\n",
                points_vert: "\nuniform float size;\nuniform float scale;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\n\tgl_PointSize = size;\n\n\t#ifdef USE_SIZEATTENUATION\n\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\n\t#endif\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n\n}\n",
                shadow_frag: "\nuniform vec3 color;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n\nvoid main() {\n\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n",
                shadow_vert: "\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n\nvoid main() {\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n",
                sprite_frag: "\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\toutgoingLight = diffuseColor.rgb;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n",
                sprite_vert: "\nuniform float rotation;\nuniform vec2 center;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n\t#ifndef USE_SIZEATTENUATION\n\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\n\t#endif\n\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\n\tmvPosition.xy += rotatedPosition;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n}\n"
            },
            co = {
                basic: {
                    uniforms: bs([_a.common, _a.specularmap, _a.envmap, _a.aomap, _a.lightmap, _a.fog]),
                    vertexShader: uo.meshbasic_vert,
                    fragmentShader: uo.meshbasic_frag
                },
                lambert: {
                    uniforms: bs([_a.common, _a.specularmap, _a.envmap, _a.aomap, _a.lightmap, _a.emissivemap, _a.fog, _a.lights, {
                        emissive: {
                            value: new ma(0)
                        }
                    }]),
                    vertexShader: uo.meshlambert_vert,
                    fragmentShader: uo.meshlambert_frag
                },
                phong: {
                    uniforms: bs([_a.common, _a.specularmap, _a.envmap, _a.aomap, _a.lightmap, _a.emissivemap, _a.bumpmap, _a.normalmap, _a.displacementmap, _a.fog, _a.lights, {
                        emissive: {
                            value: new ma(0)
                        },
                        specular: {
                            value: new ma(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: uo.meshphong_vert,
                    fragmentShader: uo.meshphong_frag
                },
                standard: {
                    uniforms: bs([_a.common, _a.envmap, _a.aomap, _a.lightmap, _a.emissivemap, _a.bumpmap, _a.normalmap, _a.displacementmap, _a.roughnessmap, _a.metalnessmap, _a.fog, _a.lights, {
                        emissive: {
                            value: new ma(0)
                        },
                        roughness: {
                            value: 1
                        },
                        metalness: {
                            value: 0
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: uo.meshphysical_vert,
                    fragmentShader: uo.meshphysical_frag
                },
                toon: {
                    uniforms: bs([_a.common, _a.specularmap, _a.aomap, _a.lightmap, _a.emissivemap, _a.bumpmap, _a.normalmap, _a.displacementmap, _a.gradientmap, _a.fog, _a.lights, {
                        emissive: {
                            value: new ma(0)
                        },
                        specular: {
                            value: new ma(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: uo.meshtoon_vert,
                    fragmentShader: uo.meshtoon_frag
                },
                matcap: {
                    uniforms: bs([_a.common, _a.bumpmap, _a.normalmap, _a.displacementmap, _a.fog, {
                        matcap: {
                            value: null
                        }
                    }]),
                    vertexShader: uo.meshmatcap_vert,
                    fragmentShader: uo.meshmatcap_frag
                },
                points: {
                    uniforms: bs([_a.points, _a.fog]),
                    vertexShader: uo.points_vert,
                    fragmentShader: uo.points_frag
                },
                dashed: {
                    uniforms: bs([_a.common, _a.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: uo.linedashed_vert,
                    fragmentShader: uo.linedashed_frag
                },
                depth: {
                    uniforms: bs([_a.common, _a.displacementmap]),
                    vertexShader: uo.depth_vert,
                    fragmentShader: uo.depth_frag
                },
                normal: {
                    uniforms: bs([_a.common, _a.bumpmap, _a.normalmap, _a.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: uo.normal_vert,
                    fragmentShader: uo.normal_frag
                },
                sprite: {
                    uniforms: bs([_a.sprite, _a.fog]),
                    vertexShader: uo.sprite_vert,
                    fragmentShader: uo.sprite_frag
                },
                background: {
                    uniforms: {
                        uvTransform: {
                            value: new Sr
                        },
                        t2D: {
                            value: null
                        }
                    },
                    vertexShader: uo.background_vert,
                    fragmentShader: uo.background_frag
                },
                cube: {
                    uniforms: bs([_a.envmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: uo.cube_vert,
                    fragmentShader: uo.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: uo.equirect_vert,
                    fragmentShader: uo.equirect_frag
                },
                distanceRGBA: {
                    uniforms: bs([_a.common, _a.displacementmap, {
                        referencePosition: {
                            value: new Rr
                        },
                        nearDistance: {
                            value: 1
                        },
                        farDistance: {
                            value: 1e3
                        }
                    }]),
                    vertexShader: uo.distanceRGBA_vert,
                    fragmentShader: uo.distanceRGBA_frag
                },
                shadow: {
                    uniforms: bs([_a.lights, _a.fog, {
                        color: {
                            value: new ma(0)
                        },
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: uo.shadow_vert,
                    fragmentShader: uo.shadow_frag
                }
            };

        function po(t, e, n, i) {
            var r, a, s = new ma(0),
                o = 0,
                l = null,
                h = 0,
                u = null;

            function c(t, n) {
                e.buffers.color.setClear(t.r, t.g, t.b, n, i)
            }
            return {
                getClearColor: function() {
                    return s
                },
                setClearColor: function(t, e) {
                    s.set(t), c(s, o = void 0 !== e ? e : 1)
                },
                getClearAlpha: function() {
                    return o
                },
                setClearAlpha: function(t) {
                    c(s, o = t)
                },
                render: function(e, i, p, f) {
                    var d = i.background,
                        m = t.xr,
                        g = m.getSession && m.getSession();
                    if (g && "additive" === g.environmentBlendMode && (d = null), null === d ? c(s, o) : d && d.isColor && (c(d, 1), f = !0), (t.autoClear || f) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), d && (d.isCubeTexture || d.isWebGLCubeRenderTarget || 306 === d.mapping)) {
                        void 0 === a && ((a = new oo(new ms(1, 1, 1), new ws({
                            type: "BackgroundCubeMaterial",
                            uniforms: xs(co.cube.uniforms),
                            vertexShader: co.cube.vertexShader,
                            fragmentShader: co.cube.fragmentShader,
                            side: 1,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.deleteAttribute("normal"), a.geometry.deleteAttribute("uv"), a.onBeforeRender = function(t, e, n) {
                            this.matrixWorld.copyPosition(n.matrixWorld)
                        }, Object.defineProperty(a.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }), n.update(a));
                        var v = d.isWebGLCubeRenderTarget ? d.texture : d;
                        a.material.uniforms.envMap.value = v, a.material.uniforms.flipEnvMap.value = v.isCubeTexture ? -1 : 1, l === d && h === v.version && u === t.toneMapping || (a.material.needsUpdate = !0, l = d, h = v.version, u = t.toneMapping), e.unshift(a, a.geometry, a.material, 0, 0, null)
                    } else d && d.isTexture && (void 0 === r && ((r = new oo(new vs(2, 2), new ws({
                        type: "BackgroundMaterial",
                        uniforms: xs(co.background.uniforms),
                        vertexShader: co.background.vertexShader,
                        fragmentShader: co.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))).geometry.deleteAttribute("normal"), Object.defineProperty(r.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }), n.update(r)), r.material.uniforms.t2D.value = d, !0 === d.matrixAutoUpdate && d.updateMatrix(), r.material.uniforms.uvTransform.value.copy(d.matrix), l === d && h === d.version && u === t.toneMapping || (r.material.needsUpdate = !0, l = d, h = d.version, u = t.toneMapping), e.unshift(r, r.geometry, r.material, 0, 0, null))
                }
            }
        }

        function fo(t, e, n, i) {
            var r, a = i.isWebGL2;
            this.setMode = function(t) {
                r = t
            }, this.render = function(e, i) {
                t.drawArrays(r, e, i), n.update(i, r)
            }, this.renderInstances = function(i, s, o, l) {
                if (0 !== l) {
                    var h, u;
                    if (a) h = t, u = "drawArraysInstanced";
                    else if (u = "drawArraysInstancedANGLE", null === (h = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    h[u](r, s, o, l), n.update(o, r, l)
                }
            }
        }

        function mo(t, e, n) {
            var i;

            function r(e) {
                if ("highp" === e) {
                    if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp";
                    e = "mediump"
                }
                return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
            }
            var a = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext,
                s = void 0 !== n.precision ? n.precision : "highp",
                o = r(s);
            o !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", o, "instead."), s = o);
            var l = !0 === n.logarithmicDepthBuffer,
                h = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
                u = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                c = t.getParameter(t.MAX_TEXTURE_SIZE),
                p = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
                f = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                d = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
                m = t.getParameter(t.MAX_VARYING_VECTORS),
                g = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
                v = u > 0,
                y = a || !!e.get("OES_texture_float");
            return {
                isWebGL2: a,
                getMaxAnisotropy: function() {
                    if (void 0 !== i) return i;
                    var n = e.get("EXT_texture_filter_anisotropic");
                    return i = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                },
                getMaxPrecision: r,
                precision: s,
                logarithmicDepthBuffer: l,
                maxTextures: h,
                maxVertexTextures: u,
                maxTextureSize: c,
                maxCubemapSize: p,
                maxAttributes: f,
                maxVertexUniforms: d,
                maxVaryings: m,
                maxFragmentUniforms: g,
                vertexTextures: v,
                floatFragmentTextures: y,
                floatVertexTextures: v && y,
                maxSamples: a ? t.getParameter(t.MAX_SAMPLES) : 0
            }
        }

        function go() {
            var t = this,
                e = null,
                n = 0,
                i = !1,
                r = !1,
                a = new ta,
                s = new Sr,
                o = {
                    value: null,
                    needsUpdate: !1
                };

            function l() {
                o.value !== e && (o.value = e, o.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0
            }

            function h(e, n, i, r) {
                var l = null !== e ? e.length : 0,
                    h = null;
                if (0 !== l) {
                    if (h = o.value, !0 !== r || null === h) {
                        var u = i + 4 * l,
                            c = n.matrixWorldInverse;
                        s.getNormalMatrix(c), (null === h || h.length < u) && (h = new Float32Array(u));
                        for (var p = 0, f = i; p !== l; ++p, f += 4) a.copy(e[p]).applyMatrix4(c, s), a.normal.toArray(h, f), h[f + 3] = a.constant
                    }
                    o.value = h, o.needsUpdate = !0
                }
                return t.numPlanes = l, t.numIntersection = 0, h
            }
            this.uniform = o, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, r, a) {
                var s = 0 !== t.length || r || 0 !== n || i;
                return i = r, e = h(t, a, 0), n = t.length, s
            }, this.beginShadows = function() {
                r = !0, h(null)
            }, this.endShadows = function() {
                r = !1, l()
            }, this.setState = function(t, a, s, u, c, p) {
                if (!i || null === t || 0 === t.length || r && !s) r ? h(null) : l();
                else {
                    var f = r ? 0 : n,
                        d = 4 * f,
                        m = c.clippingState || null;
                    o.value = m, m = h(t, u, d, p);
                    for (var g = 0; g !== d; ++g) m[g] = e[g];
                    c.clippingState = m, this.numIntersection = a ? this.numPlanes : 0, this.numPlanes += f
                }
            }
        }

        function vo(t) {
            var e = {};
            return {
                get: function(n) {
                    if (void 0 !== e[n]) return e[n];
                    var i;
                    switch (n) {
                        case "WEBGL_depth_texture":
                            i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            i = t.getExtension(n)
                    }
                    return null === i && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), e[n] = i, i
                }
            }
        }

        function yo(t, e, n) {
            var i = new WeakMap,
                r = new WeakMap;

            function a(t) {
                var s = t.target,
                    o = i.get(s);
                for (var l in null !== o.index && e.remove(o.index), o.attributes) e.remove(o.attributes[l]);
                s.removeEventListener("dispose", a), i.delete(s);
                var h = r.get(o);
                h && (e.remove(h), r.delete(o)), n.memory.geometries--
            }

            function s(n) {
                var i = [],
                    a = n.index,
                    s = n.attributes.position,
                    o = 0;
                if (null !== a) {
                    var l = a.array;
                    o = a.version;
                    for (var h = 0, u = l.length; h < u; h += 3) {
                        var c = l[h + 0],
                            p = l[h + 1],
                            f = l[h + 2];
                        i.push(c, p, p, f, f, c)
                    }
                } else {
                    l = s.array;
                    o = s.version;
                    for (h = 0, u = l.length / 3 - 1; h < u; h += 3) {
                        c = h + 0, p = h + 1, f = h + 2;
                        i.push(c, p, p, f, f, c)
                    }
                }
                var d = new(ss(i) > 65535 ? ns : ts)(i, 1);
                d.version = o, e.update(d, t.ELEMENT_ARRAY_BUFFER);
                var m = r.get(n);
                m && e.remove(m), r.set(n, d)
            }
            return {
                get: function(t, e) {
                    var r = i.get(e);
                    return r || (e.addEventListener("dispose", a), e.isBufferGeometry ? r = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new ds).setFromObject(t)), r = e._bufferGeometry), i.set(e, r), n.memory.geometries++, r)
                },
                update: function(n) {
                    var i = n.index,
                        r = n.attributes;
                    for (var a in null !== i && e.update(i, t.ELEMENT_ARRAY_BUFFER), r) e.update(r[a], t.ARRAY_BUFFER);
                    var s = n.morphAttributes;
                    for (var a in s)
                        for (var o = s[a], l = 0, h = o.length; l < h; l++) e.update(o[l], t.ARRAY_BUFFER)
                },
                getWireframeAttribute: function(t) {
                    var e = r.get(t);
                    if (e) {
                        var n = t.index;
                        null !== n && e.version < n.version && s(t)
                    } else s(t);
                    return r.get(t)
                }
            }
        }

        function _o(t, e, n, i) {
            var r, a, s, o = i.isWebGL2;
            this.setMode = function(t) {
                r = t
            }, this.setIndex = function(t) {
                a = t.type, s = t.bytesPerElement
            }, this.render = function(e, i) {
                t.drawElements(r, i, a, e * s), n.update(i, r)
            }, this.renderInstances = function(i, l, h, u) {
                if (0 !== u) {
                    var c, p;
                    if (o) c = t, p = "drawElementsInstanced";
                    else if (p = "drawElementsInstancedANGLE", null === (c = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    c[p](r, h, a, l * s, u), n.update(h, r, u)
                }
            }
        }

        function xo(t) {
            var e = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: e,
                programs: null,
                autoReset: !0,
                reset: function() {
                    e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                },
                update: function(n, i, r) {
                    switch (r = r || 1, e.calls++, i) {
                        case t.TRIANGLES:
                            e.triangles += r * (n / 3);
                            break;
                        case t.LINES:
                            e.lines += r * (n / 2);
                            break;
                        case t.LINE_STRIP:
                            e.lines += r * (n - 1);
                            break;
                        case t.LINE_LOOP:
                            e.lines += r * n;
                            break;
                        case t.POINTS:
                            e.points += r * n;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                    }
                }
            }
        }

        function bo(t, e) {
            return Math.abs(e[1]) - Math.abs(t[1])
        }

        function Eo(t) {
            var e = {},
                n = new Float32Array(8);
            return {
                update: function(i, r, a, s) {
                    var o = i.morphTargetInfluences,
                        l = void 0 === o ? 0 : o.length,
                        h = e[r.id];
                    if (void 0 === h) {
                        h = [];
                        for (var u = 0; u < l; u++) h[u] = [u, 0];
                        e[r.id] = h
                    }
                    var c = a.morphTargets && r.morphAttributes.position,
                        p = a.morphNormals && r.morphAttributes.normal;
                    for (u = 0; u < l; u++) {
                        0 !== (d = h[u])[1] && (c && r.deleteAttribute("morphTarget" + u), p && r.deleteAttribute("morphNormal" + u))
                    }
                    for (u = 0; u < l; u++) {
                        (d = h[u])[0] = u, d[1] = o[u]
                    }
                    h.sort(bo);
                    var f = 0;
                    for (u = 0; u < 8; u++) {
                        var d;
                        if (d = h[u]) {
                            var m = d[0],
                                g = d[1];
                            if (g) {
                                c && r.setAttribute("morphTarget" + u, c[m]), p && r.setAttribute("morphNormal" + u, p[m]), n[u] = g, f += g;
                                continue
                            }
                        }
                        n[u] = 0
                    }
                    var v = r.morphTargetsRelative ? 1 : 1 - f;
                    s.getUniforms().setValue(t, "morphTargetBaseInfluence", v), s.getUniforms().setValue(t, "morphTargetInfluences", n)
                }
            }
        }

        function wo(t, e, n, i) {
            var r = new WeakMap;
            return {
                update: function(a) {
                    var s = i.render.frame,
                        o = a.geometry,
                        l = e.get(a, o);
                    return r.get(l) !== s && (o.isGeometry && l.updateFromObject(a), e.update(l), r.set(l, s)), a.isInstancedMesh && n.update(a.instanceMatrix, t.ARRAY_BUFFER), l
                },
                dispose: function() {
                    r = new WeakMap
                }
            }
        }

        function Do(t, e, n, i, r, a, s, o, l, h) {
            t = void 0 !== t ? t : [], e = void 0 !== e ? e : 301, s = void 0 !== s ? s : 1022, Ar.call(this, t, e, n, i, r, a, s, o, l, h), this.flipY = !1
        }

        function So(t, e, n, i) {
            Ar.call(this, null), this.image = {
                data: t || null,
                width: e || 1,
                height: n || 1,
                depth: i || 1
            }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
        }

        function Mo(t, e, n, i) {
            Ar.call(this, null), this.image = {
                data: t || null,
                width: e || 1,
                height: n || 1,
                depth: i || 1
            }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
        }
        co.physical = {
            uniforms: bs([co.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatNormalScale: {
                    value: new Dr(1, 1)
                },
                clearcoatNormalMap: {
                    value: null
                },
                sheen: {
                    value: new ma(0)
                },
                transparency: {
                    value: 0
                }
            }]),
            vertexShader: uo.meshphysical_vert,
            fragmentShader: uo.meshphysical_frag
        }, Do.prototype = Object.create(Ar.prototype), Do.prototype.constructor = Do, Do.prototype.isCubeTexture = !0, Object.defineProperty(Do.prototype, "images", {
            get: function() {
                return this.image
            },
            set: function(t) {
                this.image = t
            }
        }), So.prototype = Object.create(Ar.prototype), So.prototype.constructor = So, So.prototype.isDataTexture2DArray = !0, Mo.prototype = Object.create(Ar.prototype), Mo.prototype.constructor = Mo, Mo.prototype.isDataTexture3D = !0;
        var To = new Ar,
            Ao = new So,
            Co = new Mo,
            Po = new Do,
            Fo = [],
            Lo = [],
            Ro = new Float32Array(16),
            Io = new Float32Array(9),
            ko = new Float32Array(4);

        function Oo(t, e, n) {
            var i = t[0];
            if (i <= 0 || i > 0) return t;
            var r = e * n,
                a = Fo[r];
            if (void 0 === a && (a = new Float32Array(r), Fo[r] = a), 0 !== e) {
                i.toArray(a, 0);
                for (var s = 1, o = 0; s !== e; ++s) o += n, t[s].toArray(a, o)
            }
            return a
        }

        function No(t, e) {
            if (t.length !== e.length) return !1;
            for (var n = 0, i = t.length; n < i; n++)
                if (t[n] !== e[n]) return !1;
            return !0
        }

        function Bo(t, e) {
            for (var n = 0, i = e.length; n < i; n++) t[n] = e[n]
        }

        function zo(t, e) {
            var n = Lo[e];
            void 0 === n && (n = new Int32Array(e), Lo[e] = n);
            for (var i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
            return n
        }

        function Vo(t, e) {
            var n = this.cache;
            n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
        }

        function Uo(t, e) {
            var n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
            else {
                if (No(n, e)) return;
                t.uniform2fv(this.addr, e), Bo(n, e)
            }
        }

        function Go(t, e) {
            var n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
            else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
            else {
                if (No(n, e)) return;
                t.uniform3fv(this.addr, e), Bo(n, e)
            }
        }

        function Ho(t, e) {
            var n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
            else {
                if (No(n, e)) return;
                t.uniform4fv(this.addr, e), Bo(n, e)
            }
        }

        function jo(t, e) {
            var n = this.cache,
                i = e.elements;
            if (void 0 === i) {
                if (No(n, e)) return;
                t.uniformMatrix2fv(this.addr, !1, e), Bo(n, e)
            } else {
                if (No(n, i)) return;
                ko.set(i), t.uniformMatrix2fv(this.addr, !1, ko), Bo(n, i)
            }
        }

        function Wo(t, e) {
            var n = this.cache,
                i = e.elements;
            if (void 0 === i) {
                if (No(n, e)) return;
                t.uniformMatrix3fv(this.addr, !1, e), Bo(n, e)
            } else {
                if (No(n, i)) return;
                Io.set(i), t.uniformMatrix3fv(this.addr, !1, Io), Bo(n, i)
            }
        }

        function Xo(t, e) {
            var n = this.cache,
                i = e.elements;
            if (void 0 === i) {
                if (No(n, e)) return;
                t.uniformMatrix4fv(this.addr, !1, e), Bo(n, e)
            } else {
                if (No(n, i)) return;
                Ro.set(i), t.uniformMatrix4fv(this.addr, !1, Ro), Bo(n, i)
            }
        }

        function qo(t, e, n) {
            var i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || To, r)
        }

        function Yo(t, e, n) {
            var i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || Ao, r)
        }

        function Zo(t, e, n) {
            var i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || Co, r)
        }

        function Jo(t, e, n) {
            var i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || Po, r)
        }

        function Ko(t, e) {
            var n = this.cache;
            n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
        }

        function $o(t, e) {
            var n = this.cache;
            No(n, e) || (t.uniform2iv(this.addr, e), Bo(n, e))
        }

        function Qo(t, e) {
            var n = this.cache;
            No(n, e) || (t.uniform3iv(this.addr, e), Bo(n, e))
        }

        function tl(t, e) {
            var n = this.cache;
            No(n, e) || (t.uniform4iv(this.addr, e), Bo(n, e))
        }

        function el(t, e) {
            var n = this.cache;
            n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
        }

        function nl(t, e) {
            t.uniform1fv(this.addr, e)
        }

        function il(t, e) {
            t.uniform1iv(this.addr, e)
        }

        function rl(t, e) {
            t.uniform2iv(this.addr, e)
        }

        function al(t, e) {
            t.uniform3iv(this.addr, e)
        }

        function sl(t, e) {
            t.uniform4iv(this.addr, e)
        }

        function ol(t, e) {
            var n = Oo(e, this.size, 2);
            t.uniform2fv(this.addr, n)
        }

        function ll(t, e) {
            var n = Oo(e, this.size, 3);
            t.uniform3fv(this.addr, n)
        }

        function hl(t, e) {
            var n = Oo(e, this.size, 4);
            t.uniform4fv(this.addr, n)
        }

        function ul(t, e) {
            var n = Oo(e, this.size, 4);
            t.uniformMatrix2fv(this.addr, !1, n)
        }

        function cl(t, e) {
            var n = Oo(e, this.size, 9);
            t.uniformMatrix3fv(this.addr, !1, n)
        }

        function pl(t, e) {
            var n = Oo(e, this.size, 16);
            t.uniformMatrix4fv(this.addr, !1, n)
        }

        function fl(t, e, n) {
            var i = e.length,
                r = zo(n, i);
            t.uniform1iv(this.addr, r);
            for (var a = 0; a !== i; ++a) n.safeSetTexture2D(e[a] || To, r[a])
        }

        function dl(t, e, n) {
            var i = e.length,
                r = zo(n, i);
            t.uniform1iv(this.addr, r);
            for (var a = 0; a !== i; ++a) n.safeSetTextureCube(e[a] || Po, r[a])
        }

        function ml(t, e, n) {
            this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
                switch (t) {
                    case 5126:
                        return Vo;
                    case 35664:
                        return Uo;
                    case 35665:
                        return Go;
                    case 35666:
                        return Ho;
                    case 35674:
                        return jo;
                    case 35675:
                        return Wo;
                    case 35676:
                        return Xo;
                    case 5124:
                    case 35670:
                        return Ko;
                    case 35667:
                    case 35671:
                        return $o;
                    case 35668:
                    case 35672:
                        return Qo;
                    case 35669:
                    case 35673:
                        return tl;
                    case 5125:
                        return el;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return qo;
                    case 35679:
                    case 36299:
                    case 36307:
                        return Zo;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return Jo;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return Yo
                }
            }(e.type)
        }

        function gl(t, e, n) {
            this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
                switch (t) {
                    case 5126:
                        return nl;
                    case 35664:
                        return ol;
                    case 35665:
                        return ll;
                    case 35666:
                        return hl;
                    case 35674:
                        return ul;
                    case 35675:
                        return cl;
                    case 35676:
                        return pl;
                    case 5124:
                    case 35670:
                        return il;
                    case 35667:
                    case 35671:
                        return rl;
                    case 35668:
                    case 35672:
                        return al;
                    case 35669:
                    case 35673:
                        return sl;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return fl;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return dl
                }
            }(e.type)
        }

        function vl(t) {
            this.id = t, this.seq = [], this.map = {}
        }
        gl.prototype.updateCache = function(t) {
            var e = this.cache;
            t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Bo(e, t)
        }, vl.prototype.setValue = function(t, e, n) {
            for (var i = this.seq, r = 0, a = i.length; r !== a; ++r) {
                var s = i[r];
                s.setValue(t, e[s.id], n)
            }
        };
        var yl = /([\w\d_]+)(\])?(\[|\.)?/g;

        function _l(t, e) {
            t.seq.push(e), t.map[e.id] = e
        }

        function xl(t, e, n) {
            var i = t.name,
                r = i.length;
            for (yl.lastIndex = 0;;) {
                var a = yl.exec(i),
                    s = yl.lastIndex,
                    o = a[1],
                    l = "]" === a[2],
                    h = a[3];
                if (l && (o |= 0), void 0 === h || "[" === h && s + 2 === r) {
                    _l(n, void 0 === h ? new ml(o, t, e) : new gl(o, t, e));
                    break
                }
                var u = n.map[o];
                void 0 === u && _l(n, u = new vl(o)), n = u
            }
        }

        function bl(t, e) {
            this.seq = [], this.map = {};
            for (var n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), i = 0; i < n; ++i) {
                var r = t.getActiveUniform(e, i);
                xl(r, t.getUniformLocation(e, r.name), this)
            }
        }

        function El(t, e, n) {
            var i = t.createShader(e);
            return t.shaderSource(i, n), t.compileShader(i), i
        }
        bl.prototype.setValue = function(t, e, n, i) {
            var r = this.map[e];
            void 0 !== r && r.setValue(t, n, i)
        }, bl.prototype.setOptional = function(t, e, n) {
            var i = e[n];
            void 0 !== i && this.setValue(t, n, i)
        }, bl.upload = function(t, e, n, i) {
            for (var r = 0, a = e.length; r !== a; ++r) {
                var s = e[r],
                    o = n[s.id];
                !1 !== o.needsUpdate && s.setValue(t, o.value, i)
            }
        }, bl.seqWithValue = function(t, e) {
            for (var n = [], i = 0, r = t.length; i !== r; ++i) {
                var a = t[i];
                a.id in e && n.push(a)
            }
            return n
        };
        var wl = 0;

        function Dl(t) {
            switch (t) {
                case 3e3:
                    return ["Linear", "( value )"];
                case 3001:
                    return ["sRGB", "( value )"];
                case 3002:
                    return ["RGBE", "( value )"];
                case 3004:
                    return ["RGBM", "( value, 7.0 )"];
                case 3005:
                    return ["RGBM", "( value, 16.0 )"];
                case 3006:
                    return ["RGBD", "( value, 256.0 )"];
                case 3007:
                    return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                case 3003:
                    return ["LogLuv", "( value )"];
                default:
                    throw new Error("unsupported encoding: " + t)
            }
        }

        function Sl(t, e, n) {
            var i = t.getShaderParameter(e, t.COMPILE_STATUS),
                r = t.getShaderInfoLog(e).trim();
            return i && "" === r ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + function(t) {
                for (var e = t.split("\n"), n = 0; n < e.length; n++) e[n] = n + 1 + ": " + e[n];
                return e.join("\n")
            }(t.getShaderSource(e))
        }

        function Ml(t, e) {
            var n = Dl(e);
            return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
        }

        function Tl(t, e) {
            var n;
            switch (e) {
                case 1:
                    n = "Linear";
                    break;
                case 2:
                    n = "Reinhard";
                    break;
                case 3:
                    n = "Uncharted2";
                    break;
                case 4:
                    n = "OptimizedCineon";
                    break;
                case 5:
                    n = "ACESFilmic";
                    break;
                default:
                    throw new Error("unsupported toneMapping: " + e)
            }
            return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }

        function Al(t) {
            return "" !== t
        }

        function Cl(t, e) {
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }

        function Pl(t, e) {
            return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }
        var Fl = /^[ \t]*#include +<([\w\d./]+)>/gm;

        function Ll(t) {
            return t.replace(Fl, Rl)
        }

        function Rl(t, e) {
            var n = uo[e];
            if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
            return Ll(n)
        }
        var Il = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
            kl = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;

        function Ol(t) {
            return t.replace(kl, Bl).replace(Il, Nl)
        }

        function Nl(t, e, n, i) {
            return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Bl(t, e, n, i)
        }

        function Bl(t, e, n, i) {
            for (var r = "", a = parseInt(e); a < parseInt(n); a++) r += i.replace(/\[ i \]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
            return r
        }

        function zl(t) {
            var e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
            return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
        }

        function Vl(t, e, n) {
            var i, r, a, s, o, l = t.getContext(),
                h = n.defines,
                u = n.vertexShader,
                c = n.fragmentShader,
                p = function(t) {
                    var e = "SHADOWMAP_TYPE_BASIC";
                    return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e
                }(n),
                f = function(t) {
                    var e = "ENVMAP_TYPE_CUBE";
                    if (t.envMap) switch (t.envMapMode) {
                        case 301:
                        case 302:
                            e = "ENVMAP_TYPE_CUBE";
                            break;
                        case 306:
                        case 307:
                            e = "ENVMAP_TYPE_CUBE_UV";
                            break;
                        case 303:
                        case 304:
                            e = "ENVMAP_TYPE_EQUIREC";
                            break;
                        case 305:
                            e = "ENVMAP_TYPE_SPHERE"
                    }
                    return e
                }(n),
                d = function(t) {
                    var e = "ENVMAP_MODE_REFLECTION";
                    if (t.envMap) switch (t.envMapMode) {
                        case 302:
                        case 304:
                            e = "ENVMAP_MODE_REFRACTION"
                    }
                    return e
                }(n),
                m = function(t) {
                    var e = "ENVMAP_BLENDING_NONE";
                    if (t.envMap) switch (t.combine) {
                        case 0:
                            e = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case 1:
                            e = "ENVMAP_BLENDING_MIX";
                            break;
                        case 2:
                            e = "ENVMAP_BLENDING_ADD"
                    }
                    return e
                }(n),
                g = t.gammaFactor > 0 ? t.gammaFactor : 1,
                v = n.isWebGL2 ? "" : function(t) {
                    return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Al).join("\n")
                }(n),
                y = function(t) {
                    var e = [];
                    for (var n in t) {
                        var i = t[n];
                        !1 !== i && e.push("#define " + n + " " + i)
                    }
                    return e.join("\n")
                }(h),
                _ = l.createProgram();
            if (n.isRawShaderMaterial ? ((i = [y].filter(Al).join("\n")).length > 0 && (i += "\n"), (r = [v, y].filter(Al).join("\n")).length > 0 && (r += "\n")) : (i = [zl(n), "#define SHADER_NAME " + n.shaderName, y, n.instancing ? "#define USE_INSTANCING" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + g, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + d : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + p : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Al).join("\n"), r = [v, zl(n), "#define SHADER_NAME " + n.shaderName, y, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + g, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + f : "", n.envMap ? "#define " + d : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + p : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? uo.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? Tl("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.outputEncoding || n.mapEncoding || n.matcapEncoding || n.envMapEncoding || n.emissiveMapEncoding || n.lightMapEncoding ? uo.encodings_pars_fragment : "", n.mapEncoding ? Ml("mapTexelToLinear", n.mapEncoding) : "", n.matcapEncoding ? Ml("matcapTexelToLinear", n.matcapEncoding) : "", n.envMapEncoding ? Ml("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMapEncoding ? Ml("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMapEncoding ? Ml("lightMapTexelToLinear", n.lightMapEncoding) : "", n.outputEncoding ? (a = "linearToOutputTexel", s = n.outputEncoding, o = Dl(s), "vec4 " + a + "( vec4 value ) { return LinearTo" + o[0] + o[1] + "; }") : "", n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Al).join("\n")), u = Pl(u = Cl(u = Ll(u), n), n), c = Pl(c = Cl(c = Ll(c), n), n), u = Ol(u), c = Ol(c), n.isWebGL2 && !n.isRawShaderMaterial) {
                var x = !1,
                    b = /^\s*#version\s+300\s+es\s*\n/;
                n.isShaderMaterial && null !== u.match(b) && null !== c.match(b) && (x = !0, u = u.replace(b, ""), c = c.replace(b, "")), i = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + i, r = ["#version 300 es\n", "#define varying in", x ? "" : "out highp vec4 pc_fragColor;", x ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + r
            }
            var E, w, D = i + u,
                S = r + c,
                M = El(l, l.VERTEX_SHADER, D),
                T = El(l, l.FRAGMENT_SHADER, S);
            if (l.attachShader(_, M), l.attachShader(_, T), void 0 !== n.index0AttributeName ? l.bindAttribLocation(_, 0, n.index0AttributeName) : !0 === n.morphTargets && l.bindAttribLocation(_, 0, "position"), l.linkProgram(_), t.debug.checkShaderErrors) {
                var A = l.getProgramInfoLog(_).trim(),
                    C = l.getShaderInfoLog(M).trim(),
                    P = l.getShaderInfoLog(T).trim(),
                    F = !0,
                    L = !0;
                if (!1 === l.getProgramParameter(_, l.LINK_STATUS)) {
                    F = !1;
                    var R = Sl(l, M, "vertex"),
                        I = Sl(l, T, "fragment");
                    console.error("THREE.WebGLProgram: shader error: ", l.getError(), "gl.VALIDATE_STATUS", l.getProgramParameter(_, l.VALIDATE_STATUS), "gl.getProgramInfoLog", A, R, I)
                } else "" !== A ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", A) : "" !== C && "" !== P || (L = !1);
                L && (this.diagnostics = {
                    runnable: F,
                    programLog: A,
                    vertexShader: {
                        log: C,
                        prefix: i
                    },
                    fragmentShader: {
                        log: P,
                        prefix: r
                    }
                })
            }
            return l.deleteShader(M), l.deleteShader(T), this.getUniforms = function() {
                return void 0 === E && (E = new bl(l, _)), E
            }, this.getAttributes = function() {
                return void 0 === w && (w = function(t, e) {
                    for (var n = {}, i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), r = 0; r < i; r++) {
                        var a = t.getActiveAttrib(e, r).name;
                        n[a] = t.getAttribLocation(e, a)
                    }
                    return n
                }(l, _)), w
            }, this.destroy = function() {
                l.deleteProgram(_), this.program = void 0
            }, this.name = n.shaderName, this.id = wl++, this.cacheKey = e, this.usedTimes = 1, this.program = _, this.vertexShader = M, this.fragmentShader = T, this
        }

        function Ul(t, e, n) {
            var i = [],
                r = n.isWebGL2,
                a = n.logarithmicDepthBuffer,
                s = n.floatVertexTextures,
                o = n.precision,
                l = n.maxVertexUniforms,
                h = n.vertexTextures,
                u = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "toon",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    MeshMatcapMaterial: "matcap",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow",
                    SpriteMaterial: "sprite"
                },
                c = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen"];

            function p(t) {
                var e;
                return t ? t.isTexture ? e = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = 3e3, e
            }
            this.getParameters = function(i, c, f, d, m, g, v) {
                var y = d.fog,
                    _ = i.isMeshStandardMaterial ? d.environment : null,
                    x = i.envMap || _,
                    b = u[i.type],
                    E = v.isSkinnedMesh ? function(t) {
                        var e = t.skeleton.bones;
                        if (s) return 1024;
                        var n = l,
                            i = Math.floor((n - 20) / 4),
                            r = Math.min(i, e.length);
                        return r < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + r + "."), 0) : r
                    }(v) : 0;
                null !== i.precision && (o = n.getMaxPrecision(i.precision)) !== i.precision && console.warn("THREE.WebGLProgram.getParameters:", i.precision, "not supported, using", o, "instead.");
                var w = function(t, e) {
                    var n;
                    if (e) {
                        var i = co[e];
                        n = {
                            name: t.type,
                            uniforms: Es.clone(i.uniforms),
                            vertexShader: i.vertexShader,
                            fragmentShader: i.fragmentShader
                        }
                    } else n = {
                        name: t.type,
                        uniforms: t.uniforms,
                        vertexShader: t.vertexShader,
                        fragmentShader: t.fragmentShader
                    };
                    return n
                }(i, b);
                i.onBeforeCompile(w, t);
                var D = t.getRenderTarget();
                return {
                    isWebGL2: r,
                    shaderID: b,
                    shaderName: w.name,
                    uniforms: w.uniforms,
                    vertexShader: w.vertexShader,
                    fragmentShader: w.fragmentShader,
                    defines: i.defines,
                    isRawShaderMaterial: i.isRawShaderMaterial,
                    isShaderMaterial: i.isShaderMaterial,
                    precision: o,
                    instancing: !0 === v.isInstancedMesh,
                    supportsVertexTextures: h,
                    outputEncoding: null !== D ? p(D.texture) : t.outputEncoding,
                    map: !!i.map,
                    mapEncoding: p(i.map),
                    matcap: !!i.matcap,
                    matcapEncoding: p(i.matcap),
                    envMap: !!x,
                    envMapMode: x && x.mapping,
                    envMapEncoding: p(x),
                    envMapCubeUV: !!x && (306 === x.mapping || 307 === x.mapping),
                    lightMap: !!i.lightMap,
                    lightMapEncoding: p(i.lightMap),
                    aoMap: !!i.aoMap,
                    emissiveMap: !!i.emissiveMap,
                    emissiveMapEncoding: p(i.emissiveMap),
                    bumpMap: !!i.bumpMap,
                    normalMap: !!i.normalMap,
                    objectSpaceNormalMap: 1 === i.normalMapType,
                    tangentSpaceNormalMap: 0 === i.normalMapType,
                    clearcoatMap: !!i.clearcoatMap,
                    clearcoatRoughnessMap: !!i.clearcoatRoughnessMap,
                    clearcoatNormalMap: !!i.clearcoatNormalMap,
                    displacementMap: !!i.displacementMap,
                    roughnessMap: !!i.roughnessMap,
                    metalnessMap: !!i.metalnessMap,
                    specularMap: !!i.specularMap,
                    alphaMap: !!i.alphaMap,
                    gradientMap: !!i.gradientMap,
                    sheen: !!i.sheen,
                    combine: i.combine,
                    vertexTangents: i.normalMap && i.vertexTangents,
                    vertexColors: i.vertexColors,
                    vertexUvs: !!(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatMap || i.clearcoatRoughnessMap || i.clearcoatNormalMap || i.displacementMap),
                    uvsVertexOnly: !(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatNormalMap || !i.displacementMap),
                    fog: !!y,
                    useFog: i.fog,
                    fogExp2: y && y.isFogExp2,
                    flatShading: i.flatShading,
                    sizeAttenuation: i.sizeAttenuation,
                    logarithmicDepthBuffer: a,
                    skinning: i.skinning && E > 0,
                    maxBones: E,
                    useVertexTexture: s,
                    morphTargets: i.morphTargets,
                    morphNormals: i.morphNormals,
                    maxMorphTargets: t.maxMorphTargets,
                    maxMorphNormals: t.maxMorphNormals,
                    numDirLights: c.directional.length,
                    numPointLights: c.point.length,
                    numSpotLights: c.spot.length,
                    numRectAreaLights: c.rectArea.length,
                    numHemiLights: c.hemi.length,
                    numDirLightShadows: c.directionalShadowMap.length,
                    numPointLightShadows: c.pointShadowMap.length,
                    numSpotLightShadows: c.spotShadowMap.length,
                    numClippingPlanes: m,
                    numClipIntersection: g,
                    dithering: i.dithering,
                    shadowMapEnabled: t.shadowMap.enabled && f.length > 0,
                    shadowMapType: t.shadowMap.type,
                    toneMapping: i.toneMapped ? t.toneMapping : 0,
                    physicallyCorrectLights: t.physicallyCorrectLights,
                    premultipliedAlpha: i.premultipliedAlpha,
                    alphaTest: i.alphaTest,
                    doubleSided: 2 === i.side,
                    flipSided: 1 === i.side,
                    depthPacking: void 0 !== i.depthPacking && i.depthPacking,
                    index0AttributeName: i.index0AttributeName,
                    extensionDerivatives: i.extensions && i.extensions.derivatives,
                    extensionFragDepth: i.extensions && i.extensions.fragDepth,
                    extensionDrawBuffers: i.extensions && i.extensions.drawBuffers,
                    extensionShaderTextureLOD: i.extensions && i.extensions.shaderTextureLOD,
                    rendererExtensionFragDepth: r || null !== e.get("EXT_frag_depth"),
                    rendererExtensionDrawBuffers: r || null !== e.get("WEBGL_draw_buffers"),
                    rendererExtensionShaderTextureLod: r || null !== e.get("EXT_shader_texture_lod"),
                    onBeforeCompile: i.onBeforeCompile
                }
            }, this.getProgramCacheKey = function(e) {
                var n = [];
                if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
                    for (var i in e.defines) n.push(i), n.push(e.defines[i]);
                if (void 0 === e.isRawShaderMaterial) {
                    for (var r = 0; r < c.length; r++) n.push(e[c[r]]);
                    n.push(t.outputEncoding), n.push(t.gammaFactor)
                }
                return n.push(e.onBeforeCompile.toString()), n.join()
            }, this.acquireProgram = function(e, n) {
                for (var r, a = 0, s = i.length; a < s; a++) {
                    var o = i[a];
                    if (o.cacheKey === n) {
                        ++(r = o).usedTimes;
                        break
                    }
                }
                return void 0 === r && (r = new Vl(t, n, e), i.push(r)), r
            }, this.releaseProgram = function(t) {
                if (0 == --t.usedTimes) {
                    var e = i.indexOf(t);
                    i[e] = i[i.length - 1], i.pop(), t.destroy()
                }
            }, this.programs = i
        }

        function Gl() {
            var t = new WeakMap;
            return {
                get: function(e) {
                    var n = t.get(e);
                    return void 0 === n && (n = {}, t.set(e, n)), n
                },
                remove: function(e) {
                    t.delete(e)
                },
                update: function(e, n, i) {
                    t.get(e)[n] = i
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }

        function Hl(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }

        function jl(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }

        function Wl() {
            var t = [],
                e = 0,
                n = [],
                i = [],
                r = {
                    id: -1
                };

            function a(n, i, a, s, o, l) {
                var h = t[e];
                return void 0 === h ? (h = {
                    id: n.id,
                    object: n,
                    geometry: i,
                    material: a,
                    program: a.program || r,
                    groupOrder: s,
                    renderOrder: n.renderOrder,
                    z: o,
                    group: l
                }, t[e] = h) : (h.id = n.id, h.object = n, h.geometry = i, h.material = a, h.program = a.program || r, h.groupOrder = s, h.renderOrder = n.renderOrder, h.z = o, h.group = l), e++, h
            }
            return {
                opaque: n,
                transparent: i,
                init: function() {
                    e = 0, n.length = 0, i.length = 0
                },
                push: function(t, e, r, s, o, l) {
                    var h = a(t, e, r, s, o, l);
                    (!0 === r.transparent ? i : n).push(h)
                },
                unshift: function(t, e, r, s, o, l) {
                    var h = a(t, e, r, s, o, l);
                    (!0 === r.transparent ? i : n).unshift(h)
                },
                finish: function() {
                    for (var n = e, i = t.length; n < i; n++) {
                        var r = t[n];
                        if (null === r.id) break;
                        r.id = null, r.object = null, r.geometry = null, r.material = null, r.program = null, r.group = null
                    }
                },
                sort: function(t, e) {
                    n.length > 1 && n.sort(t || Hl), i.length > 1 && i.sort(e || jl)
                }
            }
        }

        function Xl() {
            var t = new WeakMap;

            function e(n) {
                var i = n.target;
                i.removeEventListener("dispose", e), t.delete(i)
            }
            return {
                get: function(n, i) {
                    var r, a = t.get(n);
                    return void 0 === a ? (r = new Wl, t.set(n, new WeakMap), t.get(n).set(i, r), n.addEventListener("dispose", e)) : void 0 === (r = a.get(i)) && (r = new Wl, a.set(i, r)), r
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }

        function ql() {
            var t = {};
            return {
                get: function(e) {
                    if (void 0 !== t[e.id]) return t[e.id];
                    var n;
                    switch (e.type) {
                        case "DirectionalLight":
                            n = {
                                direction: new Rr,
                                color: new ma
                            };
                            break;
                        case "SpotLight":
                            n = {
                                position: new Rr,
                                direction: new Rr,
                                color: new ma,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;
                        case "PointLight":
                            n = {
                                position: new Rr,
                                color: new ma,
                                distance: 0,
                                decay: 0
                            };
                            break;
                        case "HemisphereLight":
                            n = {
                                direction: new Rr,
                                skyColor: new ma,
                                groundColor: new ma
                            };
                            break;
                        case "RectAreaLight":
                            n = {
                                color: new ma,
                                position: new Rr,
                                halfWidth: new Rr,
                                halfHeight: new Rr
                            }
                    }
                    return t[e.id] = n, n
                }
            }
        }
        var Yl = 0;

        function Zl(t, e) {
            return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
        }

        function Jl() {
            for (var t, e = new ql, n = (t = {}, {
                    get: function(e) {
                        if (void 0 !== t[e.id]) return t[e.id];
                        var n;
                        switch (e.type) {
                            case "DirectionalLight":
                            case "SpotLight":
                                n = {
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Dr
                                };
                                break;
                            case "PointLight":
                                n = {
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Dr,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                }
                        }
                        return t[e.id] = n, n
                    }
                }), i = {
                    version: 0,
                    hash: {
                        directionalLength: -1,
                        pointLength: -1,
                        spotLength: -1,
                        rectAreaLength: -1,
                        hemiLength: -1,
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1
                    },
                    ambient: [0, 0, 0],
                    probe: [],
                    directional: [],
                    directionalShadow: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotShadow: [],
                    spotShadowMap: [],
                    spotShadowMatrix: [],
                    rectArea: [],
                    point: [],
                    pointShadow: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: []
                }, r = 0; r < 9; r++) i.probe.push(new Rr);
            var a = new Rr,
                s = new ca,
                o = new ca;
            return {
                setup: function(t, r, l) {
                    for (var h = 0, u = 0, c = 0, p = 0; p < 9; p++) i.probe[p].set(0, 0, 0);
                    var f = 0,
                        d = 0,
                        m = 0,
                        g = 0,
                        v = 0,
                        y = 0,
                        _ = 0,
                        x = 0,
                        b = l.matrixWorldInverse;
                    t.sort(Zl), p = 0;
                    for (var E = t.length; p < E; p++) {
                        var w = t[p],
                            D = w.color,
                            S = w.intensity,
                            M = w.distance,
                            T = w.shadow && w.shadow.map ? w.shadow.map.texture : null;
                        if (w.isAmbientLight) h += D.r * S, u += D.g * S, c += D.b * S;
                        else if (w.isLightProbe)
                            for (var A = 0; A < 9; A++) i.probe[A].addScaledVector(w.sh.coefficients[A], S);
                        else if (w.isDirectionalLight) {
                            if ((F = e.get(w)).color.copy(w.color).multiplyScalar(w.intensity), F.direction.setFromMatrixPosition(w.matrixWorld), a.setFromMatrixPosition(w.target.matrixWorld), F.direction.sub(a), F.direction.transformDirection(b), w.castShadow) {
                                var C = w.shadow;
                                (P = n.get(w)).shadowBias = C.bias, P.shadowRadius = C.radius, P.shadowMapSize = C.mapSize, i.directionalShadow[f] = P, i.directionalShadowMap[f] = T, i.directionalShadowMatrix[f] = w.shadow.matrix, y++
                            }
                            i.directional[f] = F, f++
                        } else if (w.isSpotLight) {
                            if ((F = e.get(w)).position.setFromMatrixPosition(w.matrixWorld), F.position.applyMatrix4(b), F.color.copy(D).multiplyScalar(S), F.distance = M, F.direction.setFromMatrixPosition(w.matrixWorld), a.setFromMatrixPosition(w.target.matrixWorld), F.direction.sub(a), F.direction.transformDirection(b), F.coneCos = Math.cos(w.angle), F.penumbraCos = Math.cos(w.angle * (1 - w.penumbra)), F.decay = w.decay, w.castShadow) {
                                C = w.shadow;
                                (P = n.get(w)).shadowBias = C.bias, P.shadowRadius = C.radius, P.shadowMapSize = C.mapSize, i.spotShadow[m] = P, i.spotShadowMap[m] = T, i.spotShadowMatrix[m] = w.shadow.matrix, x++
                            }
                            i.spot[m] = F, m++
                        } else if (w.isRectAreaLight) {
                            (F = e.get(w)).color.copy(D).multiplyScalar(S), F.position.setFromMatrixPosition(w.matrixWorld), F.position.applyMatrix4(b), o.identity(), s.copy(w.matrixWorld), s.premultiply(b), o.extractRotation(s), F.halfWidth.set(.5 * w.width, 0, 0), F.halfHeight.set(0, .5 * w.height, 0), F.halfWidth.applyMatrix4(o), F.halfHeight.applyMatrix4(o), i.rectArea[g] = F, g++
                        } else if (w.isPointLight) {
                            if ((F = e.get(w)).position.setFromMatrixPosition(w.matrixWorld), F.position.applyMatrix4(b), F.color.copy(w.color).multiplyScalar(w.intensity), F.distance = w.distance, F.decay = w.decay, w.castShadow) {
                                var P;
                                C = w.shadow;
                                (P = n.get(w)).shadowBias = C.bias, P.shadowRadius = C.radius, P.shadowMapSize = C.mapSize, P.shadowCameraNear = C.camera.near, P.shadowCameraFar = C.camera.far, i.pointShadow[d] = P, i.pointShadowMap[d] = T, i.pointShadowMatrix[d] = w.shadow.matrix, _++
                            }
                            i.point[d] = F, d++
                        } else if (w.isHemisphereLight) {
                            var F;
                            (F = e.get(w)).direction.setFromMatrixPosition(w.matrixWorld), F.direction.transformDirection(b), F.direction.normalize(), F.skyColor.copy(w.color).multiplyScalar(S), F.groundColor.copy(w.groundColor).multiplyScalar(S), i.hemi[v] = F, v++
                        }
                    }
                    i.ambient[0] = h, i.ambient[1] = u, i.ambient[2] = c;
                    var L = i.hash;
                    L.directionalLength === f && L.pointLength === d && L.spotLength === m && L.rectAreaLength === g && L.hemiLength === v && L.numDirectionalShadows === y && L.numPointShadows === _ && L.numSpotShadows === x || (i.directional.length = f, i.spot.length = m, i.rectArea.length = g, i.point.length = d, i.hemi.length = v, i.directionalShadow.length = y, i.directionalShadowMap.length = y, i.pointShadow.length = _, i.pointShadowMap.length = _, i.spotShadow.length = x, i.spotShadowMap.length = x, i.directionalShadowMatrix.length = y, i.pointShadowMatrix.length = _, i.spotShadowMatrix.length = x, L.directionalLength = f, L.pointLength = d, L.spotLength = m, L.rectAreaLength = g, L.hemiLength = v, L.numDirectionalShadows = y, L.numPointShadows = _, L.numSpotShadows = x, i.version = Yl++)
                },
                state: i
            }
        }

        function Kl() {
            var t = new Jl,
                e = [],
                n = [];
            return {
                init: function() {
                    e.length = 0, n.length = 0
                },
                state: {
                    lightsArray: e,
                    shadowsArray: n,
                    lights: t
                },
                setupLights: function(i) {
                    t.setup(e, n, i)
                },
                pushLight: function(t) {
                    e.push(t)
                },
                pushShadow: function(t) {
                    n.push(t)
                }
            }
        }

        function $l() {
            var t = new WeakMap;

            function e(n) {
                var i = n.target;
                i.removeEventListener("dispose", e), t.delete(i)
            }
            return {
                get: function(n, i) {
                    var r;
                    return !1 === t.has(n) ? (r = new Kl, t.set(n, new WeakMap), t.get(n).set(i, r), n.addEventListener("dispose", e)) : !1 === t.get(n).has(i) ? (r = new Kl, t.get(n).set(i, r)) : r = t.get(n).get(i), r
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }

        function Ql(t, e, n) {
            this.width = t, this.height = e, this.scissor = new xa(0, 0, t, e), this.scissorTest = !1, this.viewport = new xa(0, 0, t, e), n = n || {}, this.texture = new Ar(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
        }

        function th(t) {
            _s.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
        }

        function eh(t) {
            _s.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Rr, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
        }
        Ql.prototype = Object.assign(Object.create(wr.prototype), {
            constructor: Ql,
            isWebGLRenderTarget: !0,
            setSize: function(t, e) {
                this.width === t && this.height === e || (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), th.prototype = Object.create(_s.prototype), th.prototype.constructor = th, th.prototype.isMeshDepthMaterial = !0, th.prototype.copy = function(t) {
            return _s.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
        }, eh.prototype = Object.create(_s.prototype), eh.prototype.constructor = eh, eh.prototype.isMeshDistanceMaterial = !0, eh.prototype.copy = function(t) {
            return _s.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
        };

        function nh(t, e, n) {
            var i = new ia,
                r = new Dr,
                a = new Dr,
                s = new xa,
                o = [],
                l = [],
                h = {},
                u = {
                    0: 1,
                    1: 0,
                    2: 2
                },
                c = new ws({
                    defines: {
                        SAMPLE_RATE: 2 / 8,
                        HALF_SAMPLE_RATE: 1 / 8
                    },
                    uniforms: {
                        shadow_pass: {
                            value: null
                        },
                        resolution: {
                            value: new Dr
                        },
                        radius: {
                            value: 4
                        }
                    },
                    vertexShader: "\n\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}\n\n",
                    fragmentShader: "\nuniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n\n#include <packing>\n\nvoid main() {\n\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\n\t// This seems totally useless but it's a crazy work around for a Adreno compiler bug\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\n    #ifdef HORIZONAL_PASS\n\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\n    #else\n\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n\n    #endif\n\n  }\n\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n\n  float std_dev = sqrt( squared_mean - mean * mean );\n\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n\n}\n"
                }),
                p = c.clone();
            p.defines.HORIZONAL_PASS = 1;
            var f = new ds;
            f.setAttribute("position", new Za(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
            var d = new oo(f, c),
                m = this;

            function g(n, i) {
                var r = e.update(d);
                c.uniforms.shadow_pass.value = n.map.texture, c.uniforms.resolution.value = n.mapSize, c.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, c, d, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, p, d, null)
            }

            function v(t, e, n) {
                var i = t << 0 | e << 1 | n << 2,
                    r = o[i];
                return void 0 === r && (r = new th({
                    depthPacking: 3201,
                    morphTargets: t,
                    skinning: e
                }), o[i] = r), r
            }

            function y(t, e, n) {
                var i = t << 0 | e << 1 | n << 2,
                    r = l[i];
                return void 0 === r && (r = new eh({
                    morphTargets: t,
                    skinning: e
                }), l[i] = r), r
            }

            function _(e, n, i, r, a, s, o) {
                var l = null,
                    c = v,
                    p = e.customDepthMaterial;
                if (!0 === r.isPointLight && (c = y, p = e.customDistanceMaterial), void 0 === p) {
                    var f = !1;
                    !0 === i.morphTargets && (f = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0);
                    var d = !1;
                    !0 === e.isSkinnedMesh && (!0 === i.skinning ? d = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e)), l = c(f, d, !0 === e.isInstancedMesh)
                } else l = p;
                if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                    var m = l.uuid,
                        g = i.uuid,
                        _ = h[m];
                    void 0 === _ && (_ = {}, h[m] = _);
                    var x = _[g];
                    void 0 === x && (x = l.clone(), _[g] = x), l = x
                }
                return l.visible = i.visible, l.wireframe = i.wireframe, l.side = 3 === o ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : u[i.side], l.clipShadows = i.clipShadows, l.clippingPlanes = i.clippingPlanes, l.clipIntersection = i.clipIntersection, l.wireframeLinewidth = i.wireframeLinewidth, l.linewidth = i.linewidth, !0 === r.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(r.matrixWorld), l.nearDistance = a, l.farDistance = s), l
            }

            function x(n, r, a, s, o) {
                if (!1 !== n.visible) {
                    if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === o) && (!n.frustumCulled || i.intersectsObject(n))) {
                        n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld);
                        var l = e.update(n),
                            h = n.material;
                        if (Array.isArray(h))
                            for (var u = l.groups, c = 0, p = u.length; c < p; c++) {
                                var f = u[c],
                                    d = h[f.materialIndex];
                                if (d && d.visible) {
                                    var m = _(n, l, d, s, a.near, a.far, o);
                                    t.renderBufferDirect(a, null, l, m, n, f)
                                }
                            } else if (h.visible) {
                                m = _(n, l, h, s, a.near, a.far, o);
                                t.renderBufferDirect(a, null, l, m, n, null)
                            }
                    }
                    for (var g = n.children, v = 0, y = g.length; v < y; v++) x(g[v], r, a, s, o)
                }
            }
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(e, o, l) {
                if (!1 !== m.enabled && (!1 !== m.autoUpdate || !1 !== m.needsUpdate) && 0 !== e.length) {
                    var h = t.getRenderTarget(),
                        u = t.getActiveCubeFace(),
                        c = t.getActiveMipmapLevel(),
                        p = t.state;
                    p.setBlending(0), p.buffers.color.setClear(1, 1, 1, 1), p.buffers.depth.setTest(!0), p.setScissorTest(!1);
                    for (var f = 0, d = e.length; f < d; f++) {
                        var v = e[f],
                            y = v.shadow;
                        if (void 0 !== y) {
                            r.copy(y.mapSize);
                            var _ = y.getFrameExtents();
                            if (r.multiply(_), a.copy(y.mapSize), (r.x > n || r.y > n) && (r.x > n && (a.x = Math.floor(n / _.x), r.x = a.x * _.x, y.mapSize.x = a.x), r.y > n && (a.y = Math.floor(n / _.y), r.y = a.y * _.y, y.mapSize.y = a.y)), null === y.map && !y.isPointLightShadow && 3 === this.type) {
                                var b = {
                                    minFilter: 1006,
                                    magFilter: 1006,
                                    format: 1023
                                };
                                y.map = new Ql(r.x, r.y, b), y.map.texture.name = v.name + ".shadowMap", y.mapPass = new Ql(r.x, r.y, b), y.camera.updateProjectionMatrix()
                            }
                            if (null === y.map) {
                                b = {
                                    minFilter: 1003,
                                    magFilter: 1003,
                                    format: 1023
                                };
                                y.map = new Ql(r.x, r.y, b), y.map.texture.name = v.name + ".shadowMap", y.camera.updateProjectionMatrix()
                            }
                            t.setRenderTarget(y.map), t.clear();
                            for (var E = y.getViewportCount(), w = 0; w < E; w++) {
                                var D = y.getViewport(w);
                                s.set(a.x * D.x, a.y * D.y, a.x * D.z, a.y * D.w), p.viewport(s), y.updateMatrices(v, w), i = y.getFrustum(), x(o, l, y.camera, v, this.type)
                            }
                            y.isPointLightShadow || 3 !== this.type || g(y, l)
                        } else console.warn("THREE.WebGLShadowMap:", v, "has no shadow.")
                    }
                    m.needsUpdate = !1, t.setRenderTarget(h, u, c)
                }
            }
        }

        function ih(t, e, n) {
            var i = n.isWebGL2;
            var r = new function() {
                    var e = !1,
                        n = new xa,
                        i = null,
                        r = new xa(0, 0, 0, 0);
                    return {
                        setMask: function(n) {
                            i === n || e || (t.colorMask(n, n, n, n), i = n)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e, i, a, s, o) {
                            !0 === o && (e *= s, i *= s, a *= s), n.set(e, i, a, s), !1 === r.equals(n) && (t.clearColor(e, i, a, s), r.copy(n))
                        },
                        reset: function() {
                            e = !1, i = null, r.set(-1, 0, 0, 0)
                        }
                    }
                },
                a = new function() {
                    var e = !1,
                        n = null,
                        i = null,
                        r = null;
                    return {
                        setTest: function(e) {
                            e ? B(t.DEPTH_TEST) : z(t.DEPTH_TEST)
                        },
                        setMask: function(i) {
                            n === i || e || (t.depthMask(i), n = i)
                        },
                        setFunc: function(e) {
                            if (i !== e) {
                                if (e) switch (e) {
                                    case 0:
                                        t.depthFunc(t.NEVER);
                                        break;
                                    case 1:
                                        t.depthFunc(t.ALWAYS);
                                        break;
                                    case 2:
                                        t.depthFunc(t.LESS);
                                        break;
                                    case 3:
                                        t.depthFunc(t.LEQUAL);
                                        break;
                                    case 4:
                                        t.depthFunc(t.EQUAL);
                                        break;
                                    case 5:
                                        t.depthFunc(t.GEQUAL);
                                        break;
                                    case 6:
                                        t.depthFunc(t.GREATER);
                                        break;
                                    case 7:
                                        t.depthFunc(t.NOTEQUAL);
                                        break;
                                    default:
                                        t.depthFunc(t.LEQUAL)
                                } else t.depthFunc(t.LEQUAL);
                                i = e
                            }
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e) {
                            r !== e && (t.clearDepth(e), r = e)
                        },
                        reset: function() {
                            e = !1, n = null, i = null, r = null
                        }
                    }
                },
                s = new function() {
                    var e = !1,
                        n = null,
                        i = null,
                        r = null,
                        a = null,
                        s = null,
                        o = null,
                        l = null,
                        h = null;
                    return {
                        setTest: function(n) {
                            e || (n ? B(t.STENCIL_TEST) : z(t.STENCIL_TEST))
                        },
                        setMask: function(i) {
                            n === i || e || (t.stencilMask(i), n = i)
                        },
                        setFunc: function(e, n, s) {
                            i === e && r === n && a === s || (t.stencilFunc(e, n, s), i = e, r = n, a = s)
                        },
                        setOp: function(e, n, i) {
                            s === e && o === n && l === i || (t.stencilOp(e, n, i), s = e, o = n, l = i)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e) {
                            h !== e && (t.clearStencil(e), h = e)
                        },
                        reset: function() {
                            e = !1, n = null, i = null, r = null, a = null, s = null, o = null, l = null, h = null
                        }
                    }
                },
                o = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                l = new Uint8Array(o),
                h = new Uint8Array(o),
                u = new Uint8Array(o),
                c = {},
                p = null,
                f = null,
                d = null,
                m = null,
                g = null,
                v = null,
                y = null,
                _ = null,
                x = null,
                b = !1,
                E = null,
                w = null,
                D = null,
                S = null,
                M = null,
                T = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
                A = !1,
                C = 0,
                P = t.getParameter(t.VERSION); - 1 !== P.indexOf("WebGL") ? (C = parseFloat(/^WebGL\ ([0-9])/.exec(P)[1]), A = C >= 1) : -1 !== P.indexOf("OpenGL ES") && (C = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(P)[1]), A = C >= 2);
            var F = null,
                L = {},
                R = new xa,
                I = new xa;

            function k(e, n, i) {
                var r = new Uint8Array(4),
                    a = t.createTexture();
                t.bindTexture(e, a), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                for (var s = 0; s < i; s++) t.texImage2D(n + s, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, r);
                return a
            }
            var O = {};

            function N(n, r) {
                (l[n] = 1, 0 === h[n] && (t.enableVertexAttribArray(n), h[n] = 1), u[n] !== r) && ((i ? t : e.get("ANGLE_instanced_arrays"))[i ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), u[n] = r)
            }

            function B(e) {
                !0 !== c[e] && (t.enable(e), c[e] = !0)
            }

            function z(e) {
                !1 !== c[e] && (t.disable(e), c[e] = !1)
            }
            O[t.TEXTURE_2D] = k(t.TEXTURE_2D, t.TEXTURE_2D, 1), O[t.TEXTURE_CUBE_MAP] = k(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), r.setClear(0, 0, 0, 1), a.setClear(1), s.setClear(0), B(t.DEPTH_TEST), a.setFunc(3), j(!1), W(1), B(t.CULL_FACE), H(0);
            var V = {
                100: t.FUNC_ADD,
                101: t.FUNC_SUBTRACT,
                102: t.FUNC_REVERSE_SUBTRACT
            };
            if (i) V[103] = t.MIN, V[104] = t.MAX;
            else {
                var U = e.get("EXT_blend_minmax");
                null !== U && (V[103] = U.MIN_EXT, V[104] = U.MAX_EXT)
            }
            var G = {
                200: t.ZERO,
                201: t.ONE,
                202: t.SRC_COLOR,
                204: t.SRC_ALPHA,
                210: t.SRC_ALPHA_SATURATE,
                208: t.DST_COLOR,
                206: t.DST_ALPHA,
                203: t.ONE_MINUS_SRC_COLOR,
                205: t.ONE_MINUS_SRC_ALPHA,
                209: t.ONE_MINUS_DST_COLOR,
                207: t.ONE_MINUS_DST_ALPHA
            };

            function H(e, n, i, r, a, s, o, l) {
                if (0 !== e) {
                    if (f || (B(t.BLEND), f = !0), 5 === e) a = a || n, s = s || i, o = o || r, n === m && a === y || (t.blendEquationSeparate(V[n], V[a]), m = n, y = a), i === g && r === v && s === _ && o === x || (t.blendFuncSeparate(G[i], G[r], G[s], G[o]), g = i, v = r, _ = s, x = o), d = e, b = null;
                    else if (e !== d || l !== b) {
                        if (100 === m && 100 === y || (t.blendEquation(t.FUNC_ADD), m = 100, y = 100), l) switch (e) {
                            case 1:
                                t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 2:
                                t.blendFunc(t.ONE, t.ONE);
                                break;
                            case 3:
                                t.blendFuncSeparate(t.ZERO, t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 4:
                                t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                        } else switch (e) {
                            case 1:
                                t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 2:
                                t.blendFunc(t.SRC_ALPHA, t.ONE);
                                break;
                            case 3:
                                t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR);
                                break;
                            case 4:
                                t.blendFunc(t.ZERO, t.SRC_COLOR);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                        }
                        g = null, v = null, _ = null, x = null, d = e, b = l
                    }
                } else f && (z(t.BLEND), f = !1)
            }

            function j(e) {
                E !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), E = e)
            }

            function W(e) {
                0 !== e ? (B(t.CULL_FACE), e !== w && (1 === e ? t.cullFace(t.BACK) : 2 === e ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : z(t.CULL_FACE), w = e
            }

            function X(e, n, i) {
                e ? (B(t.POLYGON_OFFSET_FILL), S === n && M === i || (t.polygonOffset(n, i), S = n, M = i)) : z(t.POLYGON_OFFSET_FILL)
            }

            function q(e) {
                void 0 === e && (e = t.TEXTURE0 + T - 1), F !== e && (t.activeTexture(e), F = e)
            }
            return {
                buffers: {
                    color: r,
                    depth: a,
                    stencil: s
                },
                initAttributes: function() {
                    for (var t = 0, e = l.length; t < e; t++) l[t] = 0
                },
                enableAttribute: function(t) {
                    N(t, 0)
                },
                enableAttributeAndDivisor: N,
                disableUnusedAttributes: function() {
                    for (var e = 0, n = h.length; e !== n; ++e) h[e] !== l[e] && (t.disableVertexAttribArray(e), h[e] = 0)
                },
                vertexAttribPointer: function(e, n, r, a, s, o) {
                    !0 !== i || r !== t.INT && r !== t.UNSIGNED_INT ? t.vertexAttribPointer(e, n, r, a, s, o) : t.vertexAttribIPointer(e, n, r, a, s, o)
                },
                enable: B,
                disable: z,
                useProgram: function(e) {
                    return p !== e && (t.useProgram(e), p = e, !0)
                },
                setBlending: H,
                setMaterial: function(e, n) {
                    2 === e.side ? z(t.CULL_FACE) : B(t.CULL_FACE);
                    var i = 1 === e.side;
                    n && (i = !i), j(i), 1 === e.blending && !1 === e.transparent ? H(0) : H(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), a.setFunc(e.depthFunc), a.setTest(e.depthTest), a.setMask(e.depthWrite), r.setMask(e.colorWrite);
                    var o = e.stencilWrite;
                    s.setTest(o), o && (s.setMask(e.stencilWriteMask), s.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), s.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), X(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
                },
                setFlipSided: j,
                setCullFace: W,
                setLineWidth: function(e) {
                    e !== D && (A && t.lineWidth(e), D = e)
                },
                setPolygonOffset: X,
                setScissorTest: function(e) {
                    e ? B(t.SCISSOR_TEST) : z(t.SCISSOR_TEST)
                },
                activeTexture: q,
                bindTexture: function(e, n) {
                    null === F && q();
                    var i = L[F];
                    void 0 === i && (i = {
                        type: void 0,
                        texture: void 0
                    }, L[F] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || O[e]), i.type = e, i.texture = n)
                },
                unbindTexture: function() {
                    var e = L[F];
                    void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                },
                compressedTexImage2D: function() {
                    try {
                        t.compressedTexImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage2D: function() {
                    try {
                        t.texImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage3D: function() {
                    try {
                        t.texImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                scissor: function(e) {
                    !1 === R.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), R.copy(e))
                },
                viewport: function(e) {
                    !1 === I.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), I.copy(e))
                },
                reset: function() {
                    for (var e = 0; e < h.length; e++) 1 === h[e] && (t.disableVertexAttribArray(e), h[e] = 0);
                    c = {}, F = null, L = {}, p = null, d = null, E = null, w = null, r.reset(), a.reset(), s.reset()
                }
            }
        }

        function rh(t, e, n, i, r, a, s) {
            var o, l = r.isWebGL2,
                h = r.maxTextures,
                u = r.maxCubemapSize,
                c = r.maxTextureSize,
                p = r.maxSamples,
                f = new WeakMap,
                d = !1;
            try {
                d = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
            } catch (t) {}

            function m(t, e) {
                return d ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
            }

            function g(t, e, n, i) {
                var r = 1;
                if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                    if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                        var a = e ? Er.floorPowerOfTwo : Math.floor,
                            s = a(r * t.width),
                            l = a(r * t.height);
                        void 0 === o && (o = m(s, l));
                        var h = n ? m(s, l) : o;
                        return h.width = s, h.height = l, h.getContext("2d").drawImage(t, 0, 0, s, l), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + l + ")."), h
                    }
                    return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
                }
                return t
            }

            function v(t) {
                return Er.isPowerOfTwo(t.width) && Er.isPowerOfTwo(t.height)
            }

            function y(t, e) {
                return t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter
            }

            function _(e, n, r, a) {
                t.generateMipmap(e), i.get(n).__maxMipLevel = Math.log(Math.max(r, a)) * Math.LOG2E
            }

            function x(n, i, r) {
                if (!1 === l) return i;
                if (null !== n) {
                    if (void 0 !== t[n]) return t[n];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                }
                var a = i;
                return i === t.RED && (r === t.FLOAT && (a = t.R32F), r === t.HALF_FLOAT && (a = t.R16F), r === t.UNSIGNED_BYTE && (a = t.R8)), i === t.RGB && (r === t.FLOAT && (a = t.RGB32F), r === t.HALF_FLOAT && (a = t.RGB16F), r === t.UNSIGNED_BYTE && (a = t.RGB8)), i === t.RGBA && (r === t.FLOAT && (a = t.RGBA32F), r === t.HALF_FLOAT && (a = t.RGBA16F), r === t.UNSIGNED_BYTE && (a = t.RGBA8)), a !== t.R16F && a !== t.R32F && a !== t.RGBA16F && a !== t.RGBA32F || e.get("EXT_color_buffer_float"), a
            }

            function b(e) {
                return 1003 === e || 1004 === e || 1005 === e ? t.NEAREST : t.LINEAR
            }

            function E(e) {
                var n = e.target;
                n.removeEventListener("dispose", E),
                    function(e) {
                        var n = i.get(e);
                        if (void 0 === n.__webglInit) return;
                        t.deleteTexture(n.__webglTexture), i.remove(e)
                    }(n), n.isVideoTexture && f.delete(n), s.memory.textures--
            }

            function w(e) {
                var n = e.target;
                n.removeEventListener("dispose", w),
                    function(e) {
                        var n = i.get(e),
                            r = i.get(e.texture);
                        if (!e) return;
                        void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture);
                        e.depthTexture && e.depthTexture.dispose();
                        if (e.isWebGLCubeRenderTarget)
                            for (var a = 0; a < 6; a++) t.deleteFramebuffer(n.__webglFramebuffer[a]), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[a]);
                        else t.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && t.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer && t.deleteRenderbuffer(n.__webglColorRenderbuffer), n.__webglDepthRenderbuffer && t.deleteRenderbuffer(n.__webglDepthRenderbuffer);
                        i.remove(e.texture), i.remove(e)
                    }(n), s.memory.textures--
            }
            var D = 0;

            function S(e, r) {
                var a = i.get(e);
                if (e.isVideoTexture && function(t) {
                        var e = s.render.frame;
                        f.get(t) !== e && (f.set(t, e), t.update())
                    }(e), e.version > 0 && a.__version !== e.version) {
                    var o = e.image;
                    if (void 0 === o) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                    else {
                        if (!1 !== o.complete) return void L(a, e, r);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_2D, a.__webglTexture)
            }

            function M(e, r) {
                if (6 === e.image.length) {
                    var s = i.get(e);
                    if (e.version > 0 && s.__version !== e.version) {
                        F(s, e), n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_CUBE_MAP, s.__webglTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY);
                        for (var o = e && (e.isCompressedTexture || e.image[0].isCompressedTexture), h = e.image[0] && e.image[0].isDataTexture, c = [], p = 0; p < 6; p++) c[p] = o || h ? h ? e.image[p].image : e.image[p] : g(e.image[p], !1, !0, u);
                        var f, d = c[0],
                            m = v(d) || l,
                            b = a.convert(e.format),
                            E = a.convert(e.type),
                            w = x(e.internalFormat, b, E);
                        if (P(t.TEXTURE_CUBE_MAP, e, m), o) {
                            for (p = 0; p < 6; p++) {
                                f = c[p].mipmaps;
                                for (var D = 0; D < f.length; D++) {
                                    var S = f[D];
                                    1023 !== e.format && 1022 !== e.format ? null !== b ? n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + p, D, w, S.width, S.height, 0, S.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + p, D, w, S.width, S.height, 0, b, E, S.data)
                                }
                            }
                            s.__maxMipLevel = f.length - 1
                        } else {
                            f = e.mipmaps;
                            for (p = 0; p < 6; p++)
                                if (h) {
                                    n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + p, 0, w, c[p].width, c[p].height, 0, b, E, c[p].data);
                                    for (D = 0; D < f.length; D++) {
                                        var M = (S = f[D]).image[p].image;
                                        n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + p, D + 1, w, M.width, M.height, 0, b, E, M.data)
                                    }
                                } else {
                                    n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + p, 0, w, b, E, c[p]);
                                    for (D = 0; D < f.length; D++) {
                                        S = f[D];
                                        n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + p, D + 1, w, b, E, S.image[p])
                                    }
                                }
                            s.__maxMipLevel = f.length
                        }
                        y(e, m) && _(t.TEXTURE_CUBE_MAP, e, d.width, d.height), s.__version = e.version, e.onUpdate && e.onUpdate(e)
                    } else n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_CUBE_MAP, s.__webglTexture)
                }
            }

            function T(e, r) {
                n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_CUBE_MAP, i.get(e).__webglTexture)
            }
            var A = {
                    1e3: t.REPEAT,
                    1001: t.CLAMP_TO_EDGE,
                    1002: t.MIRRORED_REPEAT
                },
                C = {
                    1003: t.NEAREST,
                    1004: t.NEAREST_MIPMAP_NEAREST,
                    1005: t.NEAREST_MIPMAP_LINEAR,
                    1006: t.LINEAR,
                    1007: t.LINEAR_MIPMAP_NEAREST,
                    1008: t.LINEAR_MIPMAP_LINEAR
                };

            function P(n, a, s) {
                s ? (t.texParameteri(n, t.TEXTURE_WRAP_S, A[a.wrapS]), t.texParameteri(n, t.TEXTURE_WRAP_T, A[a.wrapT]), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, A[a.wrapR]), t.texParameteri(n, t.TEXTURE_MAG_FILTER, C[a.magFilter]), t.texParameteri(n, t.TEXTURE_MIN_FILTER, C[a.minFilter])) : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE), 1001 === a.wrapS && 1001 === a.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, t.TEXTURE_MAG_FILTER, b(a.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, b(a.minFilter)), 1003 !== a.minFilter && 1006 !== a.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
                var o = e.get("EXT_texture_filter_anisotropic");
                if (o) {
                    if (1015 === a.type && null === e.get("OES_texture_float_linear")) return;
                    if (1016 === a.type && null === (l || e.get("OES_texture_half_float_linear"))) return;
                    (a.anisotropy > 1 || i.get(a).__currentAnisotropy) && (t.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), i.get(a).__currentAnisotropy = a.anisotropy)
                }
            }

            function F(e, n) {
                void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", E), e.__webglTexture = t.createTexture(), s.memory.textures++)
            }

            function L(e, i, r) {
                var s = t.TEXTURE_2D;
                i.isDataTexture2DArray && (s = t.TEXTURE_2D_ARRAY), i.isDataTexture3D && (s = t.TEXTURE_3D), F(e, i), n.activeTexture(t.TEXTURE0 + r), n.bindTexture(s, e.__webglTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, i.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, i.unpackAlignment);
                var o = function(t) {
                        return !l && (1001 !== t.wrapS || 1001 !== t.wrapT || 1003 !== t.minFilter && 1006 !== t.minFilter)
                    }(i) && !1 === v(i.image),
                    h = g(i.image, o, !1, c),
                    u = v(h) || l,
                    p = a.convert(i.format),
                    f = a.convert(i.type),
                    d = x(i.internalFormat, p, f);
                P(s, i, u);
                var m, b = i.mipmaps;
                if (i.isDepthTexture) d = t.DEPTH_COMPONENT, l ? d = 1015 === i.type ? t.DEPTH_COMPONENT32F : 1014 === i.type ? t.DEPTH_COMPONENT24 : 1020 === i.type ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT16 : 1015 === i.type && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), 1026 === i.format && d === t.DEPTH_COMPONENT && 1012 !== i.type && 1014 !== i.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = 1012, f = a.convert(i.type)), 1027 === i.format && d === t.DEPTH_COMPONENT && (d = t.DEPTH_STENCIL, 1020 !== i.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = 1020, f = a.convert(i.type))), n.texImage2D(t.TEXTURE_2D, 0, d, h.width, h.height, 0, p, f, null);
                else if (i.isDataTexture)
                    if (b.length > 0 && u) {
                        for (var E = 0, w = b.length; E < w; E++) m = b[E], n.texImage2D(t.TEXTURE_2D, E, d, m.width, m.height, 0, p, f, m.data);
                        i.generateMipmaps = !1, e.__maxMipLevel = b.length - 1
                    } else n.texImage2D(t.TEXTURE_2D, 0, d, h.width, h.height, 0, p, f, h.data), e.__maxMipLevel = 0;
                else if (i.isCompressedTexture) {
                    for (E = 0, w = b.length; E < w; E++) m = b[E], 1023 !== i.format && 1022 !== i.format ? null !== p ? n.compressedTexImage2D(t.TEXTURE_2D, E, d, m.width, m.height, 0, m.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(t.TEXTURE_2D, E, d, m.width, m.height, 0, p, f, m.data);
                    e.__maxMipLevel = b.length - 1
                } else if (i.isDataTexture2DArray) n.texImage3D(t.TEXTURE_2D_ARRAY, 0, d, h.width, h.height, h.depth, 0, p, f, h.data), e.__maxMipLevel = 0;
                else if (i.isDataTexture3D) n.texImage3D(t.TEXTURE_3D, 0, d, h.width, h.height, h.depth, 0, p, f, h.data), e.__maxMipLevel = 0;
                else if (b.length > 0 && u) {
                    for (E = 0, w = b.length; E < w; E++) m = b[E], n.texImage2D(t.TEXTURE_2D, E, d, p, f, m);
                    i.generateMipmaps = !1, e.__maxMipLevel = b.length - 1
                } else n.texImage2D(t.TEXTURE_2D, 0, d, p, f, h), e.__maxMipLevel = 0;
                y(i, u) && _(s, i, h.width, h.height), e.__version = i.version, i.onUpdate && i.onUpdate(i)
            }

            function R(e, r, s, o) {
                var l = a.convert(r.texture.format),
                    h = a.convert(r.texture.type),
                    u = x(r.texture.internalFormat, l, h);
                n.texImage2D(o, 0, u, r.width, r.height, 0, l, h, null), t.bindFramebuffer(t.FRAMEBUFFER, e), t.framebufferTexture2D(t.FRAMEBUFFER, s, o, i.get(r.texture).__webglTexture, 0), t.bindFramebuffer(t.FRAMEBUFFER, null)
            }

            function I(e, n, i) {
                if (t.bindRenderbuffer(t.RENDERBUFFER, e), n.depthBuffer && !n.stencilBuffer) {
                    var r = t.DEPTH_COMPONENT16;
                    if (i) {
                        var s = n.depthTexture;
                        s && s.isDepthTexture && (1015 === s.type ? r = t.DEPTH_COMPONENT32F : 1014 === s.type && (r = t.DEPTH_COMPONENT24));
                        var o = O(n);
                        t.renderbufferStorageMultisample(t.RENDERBUFFER, o, r, n.width, n.height)
                    } else t.renderbufferStorage(t.RENDERBUFFER, r, n.width, n.height);
                    t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)
                } else if (n.depthBuffer && n.stencilBuffer) {
                    if (i) {
                        o = O(n);
                        t.renderbufferStorageMultisample(t.RENDERBUFFER, o, t.DEPTH24_STENCIL8, n.width, n.height)
                    } else t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height);
                    t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)
                } else {
                    var l = a.convert(n.texture.format),
                        h = a.convert(n.texture.type);
                    r = x(n.texture.internalFormat, l, h);
                    if (i) {
                        o = O(n);
                        t.renderbufferStorageMultisample(t.RENDERBUFFER, o, r, n.width, n.height)
                    } else t.renderbufferStorage(t.RENDERBUFFER, r, n.width, n.height)
                }
                t.bindRenderbuffer(t.RENDERBUFFER, null)
            }

            function k(e) {
                var n = i.get(e),
                    r = !0 === e.isWebGLCubeRenderTarget;
                if (e.depthTexture) {
                    if (r) throw new Error("target.depthTexture not supported in Cube render targets");
                    ! function(e, n) {
                        if (n && n.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                        if (t.bindFramebuffer(t.FRAMEBUFFER, e), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), S(n.depthTexture, 0);
                        var r = i.get(n.depthTexture).__webglTexture;
                        if (1026 === n.depthTexture.format) t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, r, 0);
                        else {
                            if (1027 !== n.depthTexture.format) throw new Error("Unknown depthTexture format");
                            t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, r, 0)
                        }
                    }(n.__webglFramebuffer, e)
                } else if (r) {
                    n.__webglDepthbuffer = [];
                    for (var a = 0; a < 6; a++) t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer[a]), n.__webglDepthbuffer[a] = t.createRenderbuffer(), I(n.__webglDepthbuffer[a], e, !1)
                } else t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer), n.__webglDepthbuffer = t.createRenderbuffer(), I(n.__webglDepthbuffer, e, !1);
                t.bindFramebuffer(t.FRAMEBUFFER, null)
            }

            function O(t) {
                return l && t.isWebGLMultisampleRenderTarget ? Math.min(p, t.samples) : 0
            }
            var N = !1,
                B = !1;
            this.allocateTextureUnit = function() {
                var t = D;
                return t >= h && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + h), D += 1, t
            }, this.resetTextureUnits = function() {
                D = 0
            }, this.setTexture2D = S, this.setTexture2DArray = function(e, r) {
                var a = i.get(e);
                e.version > 0 && a.__version !== e.version ? L(a, e, r) : (n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_2D_ARRAY, a.__webglTexture))
            }, this.setTexture3D = function(e, r) {
                var a = i.get(e);
                e.version > 0 && a.__version !== e.version ? L(a, e, r) : (n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_3D, a.__webglTexture))
            }, this.setTextureCube = M, this.setTextureCubeDynamic = T, this.setupRenderTarget = function(e) {
                var r = i.get(e),
                    o = i.get(e.texture);
                e.addEventListener("dispose", w), o.__webglTexture = t.createTexture(), s.memory.textures++;
                var h = !0 === e.isWebGLCubeRenderTarget,
                    u = !0 === e.isWebGLMultisampleRenderTarget,
                    c = v(e) || l;
                if (!l || 1022 !== e.texture.format || 1015 !== e.texture.type && 1016 !== e.texture.type || (e.texture.format = 1023, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), h) {
                    r.__webglFramebuffer = [];
                    for (var p = 0; p < 6; p++) r.__webglFramebuffer[p] = t.createFramebuffer()
                } else if (r.__webglFramebuffer = t.createFramebuffer(), u)
                    if (l) {
                        r.__webglMultisampledFramebuffer = t.createFramebuffer(), r.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, r.__webglColorRenderbuffer);
                        var f = a.convert(e.texture.format),
                            d = a.convert(e.texture.type),
                            m = x(e.texture.internalFormat, f, d),
                            g = O(e);
                        t.renderbufferStorageMultisample(t.RENDERBUFFER, g, m, e.width, e.height), t.bindFramebuffer(t.FRAMEBUFFER, r.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, r.__webglColorRenderbuffer), t.bindRenderbuffer(t.RENDERBUFFER, null), e.depthBuffer && (r.__webglDepthRenderbuffer = t.createRenderbuffer(), I(r.__webglDepthRenderbuffer, e, !0)), t.bindFramebuffer(t.FRAMEBUFFER, null)
                    } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                if (h) {
                    n.bindTexture(t.TEXTURE_CUBE_MAP, o.__webglTexture), P(t.TEXTURE_CUBE_MAP, e.texture, c);
                    for (p = 0; p < 6; p++) R(r.__webglFramebuffer[p], e, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + p);
                    y(e.texture, c) && _(t.TEXTURE_CUBE_MAP, e.texture, e.width, e.height), n.bindTexture(t.TEXTURE_CUBE_MAP, null)
                } else n.bindTexture(t.TEXTURE_2D, o.__webglTexture), P(t.TEXTURE_2D, e.texture, c), R(r.__webglFramebuffer, e, t.COLOR_ATTACHMENT0, t.TEXTURE_2D), y(e.texture, c) && _(t.TEXTURE_2D, e.texture, e.width, e.height), n.bindTexture(t.TEXTURE_2D, null);
                e.depthBuffer && k(e)
            }, this.updateRenderTargetMipmap = function(e) {
                var r = e.texture;
                if (y(r, v(e) || l)) {
                    var a = e.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
                        s = i.get(r).__webglTexture;
                    n.bindTexture(a, s), _(a, r, e.width, e.height), n.bindTexture(a, null)
                }
            }, this.updateMultisampleRenderTarget = function(e) {
                if (e.isWebGLMultisampleRenderTarget)
                    if (l) {
                        var n = i.get(e);
                        t.bindFramebuffer(t.READ_FRAMEBUFFER, n.__webglMultisampledFramebuffer), t.bindFramebuffer(t.DRAW_FRAMEBUFFER, n.__webglFramebuffer);
                        var r = e.width,
                            a = e.height,
                            s = t.COLOR_BUFFER_BIT;
                        e.depthBuffer && (s |= t.DEPTH_BUFFER_BIT), e.stencilBuffer && (s |= t.STENCIL_BUFFER_BIT), t.blitFramebuffer(0, 0, r, a, 0, 0, r, a, s, t.NEAREST), t.bindFramebuffer(t.FRAMEBUFFER, n.__webglMultisampledFramebuffer)
                    } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
            }, this.safeSetTexture2D = function(t, e) {
                t && t.isWebGLRenderTarget && (!1 === N && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), N = !0), t = t.texture), S(t, e)
            }, this.safeSetTextureCube = function(t, e) {
                t && t.isWebGLCubeRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), B = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? M(t, e) : T(t, e)
            }
        }

        function ah(t, e, n) {
            var i = n.isWebGL2;
            return {
                convert: function(n) {
                    var r;
                    if (1009 === n) return t.UNSIGNED_BYTE;
                    if (1017 === n) return t.UNSIGNED_SHORT_4_4_4_4;
                    if (1018 === n) return t.UNSIGNED_SHORT_5_5_5_1;
                    if (1019 === n) return t.UNSIGNED_SHORT_5_6_5;
                    if (1010 === n) return t.BYTE;
                    if (1011 === n) return t.SHORT;
                    if (1012 === n) return t.UNSIGNED_SHORT;
                    if (1013 === n) return t.INT;
                    if (1014 === n) return t.UNSIGNED_INT;
                    if (1015 === n) return t.FLOAT;
                    if (1016 === n) return i ? t.HALF_FLOAT : null !== (r = e.get("OES_texture_half_float")) ? r.HALF_FLOAT_OES : null;
                    if (1021 === n) return t.ALPHA;
                    if (1022 === n) return t.RGB;
                    if (1023 === n) return t.RGBA;
                    if (1024 === n) return t.LUMINANCE;
                    if (1025 === n) return t.LUMINANCE_ALPHA;
                    if (1026 === n) return t.DEPTH_COMPONENT;
                    if (1027 === n) return t.DEPTH_STENCIL;
                    if (1028 === n) return t.RED;
                    if (1029 === n) return t.RED_INTEGER;
                    if (1030 === n) return t.RG;
                    if (1031 === n) return t.RG_INTEGER;
                    if (1032 === n) return t.RGB_INTEGER;
                    if (1033 === n) return t.RGBA_INTEGER;
                    if (33776 === n || 33777 === n || 33778 === n || 33779 === n) {
                        if (null === (r = e.get("WEBGL_compressed_texture_s3tc"))) return null;
                        if (33776 === n) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (33777 === n) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (33778 === n) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (33779 === n) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if (35840 === n || 35841 === n || 35842 === n || 35843 === n) {
                        if (null === (r = e.get("WEBGL_compressed_texture_pvrtc"))) return null;
                        if (35840 === n) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === n) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (35842 === n) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === n) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (36196 === n) return null !== (r = e.get("WEBGL_compressed_texture_etc1")) ? r.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if ((37492 === n || 37496 === n) && null !== (r = e.get("WEBGL_compressed_texture_etc"))) {
                        if (37492 === n) return r.COMPRESSED_RGB8_ETC2;
                        if (37496 === n) return r.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    return 37808 === n || 37809 === n || 37810 === n || 37811 === n || 37812 === n || 37813 === n || 37814 === n || 37815 === n || 37816 === n || 37817 === n || 37818 === n || 37819 === n || 37820 === n || 37821 === n || 37840 === n || 37841 === n || 37842 === n || 37843 === n || 37844 === n || 37845 === n || 37846 === n || 37847 === n || 37848 === n || 37849 === n || 37850 === n || 37851 === n || 37852 === n || 37853 === n ? null !== (r = e.get("WEBGL_compressed_texture_astc")) ? n : null : 36492 === n ? null !== (r = e.get("EXT_texture_compression_bptc")) ? n : null : 1020 === n ? i ? t.UNSIGNED_INT_24_8 : null !== (r = e.get("WEBGL_depth_texture")) ? r.UNSIGNED_INT_24_8_WEBGL : null : void 0
                }
            }
        }

        function sh() {
            Ba.call(this), this.type = "Camera", this.matrixWorldInverse = new ca, this.projectionMatrix = new ca, this.projectionMatrixInverse = new ca
        }

        function oh(t, e, n, i) {
            sh.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== i ? i : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
        }

        function lh(t) {
            oh.call(this), this.cameras = t || []
        }

        function hh() {
            Ba.call(this), this.type = "Group"
        }

        function uh() {
            this._targetRay = null, this._grip = null
        }

        function ch(t, e) {
            var n = this,
                i = null,
                r = 1,
                a = null,
                s = "local-floor",
                o = null,
                l = [],
                h = new Map,
                u = new oh;
            u.layers.enable(1), u.viewport = new xa;
            var c = new oh;
            c.layers.enable(2), c.viewport = new xa;
            var p = [u, c],
                f = new lh;
            f.layers.enable(1), f.layers.enable(2);
            var d = null,
                m = null;

            function g(t) {
                var e = h.get(t.inputSource);
                e && e.dispatchEvent({
                    type: t.type
                })
            }

            function v() {
                h.forEach((function(t, e) {
                    t.disconnect(e)
                })), h.clear(), t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), D.stop(), n.isPresenting = !1, n.dispatchEvent({
                    type: "sessionend"
                })
            }

            function y(t) {
                a = t, D.setContext(i), D.start(), n.isPresenting = !0, n.dispatchEvent({
                    type: "sessionstart"
                })
            }

            function _(t) {
                for (var e = i.inputSources, n = 0; n < l.length; n++) h.set(e[n], l[n]);
                for (n = 0; n < t.removed.length; n++) {
                    var r = t.removed[n];
                    (a = h.get(r)) && (a.dispatchEvent({
                        type: "disconnected",
                        data: r
                    }), h.delete(r))
                }
                for (n = 0; n < t.added.length; n++) {
                    var a;
                    r = t.added[n];
                    (a = h.get(r)) && a.dispatchEvent({
                        type: "connected",
                        data: r
                    })
                }
            }
            this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
                var e = l[t];
                return void 0 === e && (e = new uh, l[t] = e), e.getTargetRaySpace()
            }, this.getControllerGrip = function(t) {
                var e = l[t];
                return void 0 === e && (e = new uh, l[t] = e), e.getGripSpace()
            }, this.setFramebufferScaleFactor = function(t) {
                r = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
            }, this.setReferenceSpaceType = function(t) {
                s = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
            }, this.getReferenceSpace = function() {
                return a
            }, this.getSession = function() {
                return i
            }, this.setSession = function(t) {
                if (null !== (i = t)) {
                    i.addEventListener("select", g), i.addEventListener("selectstart", g), i.addEventListener("selectend", g), i.addEventListener("squeeze", g), i.addEventListener("squeezestart", g), i.addEventListener("squeezeend", g), i.addEventListener("end", v);
                    var n = e.getContextAttributes(),
                        a = {
                            antialias: n.antialias,
                            alpha: n.alpha,
                            depth: n.depth,
                            stencil: n.stencil,
                            framebufferScaleFactor: r
                        },
                        o = new XRWebGLLayer(i, e, a);
                    i.updateRenderState({
                        baseLayer: o
                    }), i.requestReferenceSpace(s).then(y), i.addEventListener("inputsourceschange", _)
                }
            };
            var x = new Rr,
                b = new Rr;

            function E(t, e) {
                null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld)
            }
            this.getCamera = function(t) {
                f.near = c.near = u.near = t.near, f.far = c.far = u.far = t.far, d === f.near && m === f.far || (i.updateRenderState({
                    depthNear: f.near,
                    depthFar: f.far
                }), d = f.near, m = f.far);
                var e = t.parent,
                    n = f.cameras;
                E(f, e);
                for (var r = 0; r < n.length; r++) E(n[r], e);
                t.matrixWorld.copy(f.matrixWorld);
                for (var a = t.children, s = (r = 0, a.length); r < s; r++) a[r].updateMatrixWorld(!0);
                return 2 === n.length ? function(t, e, n) {
                    x.setFromMatrixPosition(e.matrixWorld), b.setFromMatrixPosition(n.matrixWorld);
                    var i = x.distanceTo(b),
                        r = e.projectionMatrix.elements,
                        a = n.projectionMatrix.elements,
                        s = r[14] / (r[10] - 1),
                        o = r[14] / (r[10] + 1),
                        l = (r[9] + 1) / r[5],
                        h = (r[9] - 1) / r[5],
                        u = (r[8] - 1) / r[0],
                        c = (a[8] + 1) / a[0],
                        p = s * u,
                        f = s * c,
                        d = i / (-u + c),
                        m = d * -u;
                    e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(d), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld);
                    var g = s + d,
                        v = o + d,
                        y = p - m,
                        _ = f + (i - m),
                        E = l * o / v * g,
                        w = h * o / v * g;
                    t.projectionMatrix.makePerspective(y, _, E, w, g, v)
                }(f, u, c) : f.projectionMatrix.copy(u.projectionMatrix), f
            };
            var w = null;
            var D = new Va;
            D.setAnimationLoop((function(e, n) {
                if (null !== (o = n.getViewerPose(a))) {
                    var r = o.views,
                        s = i.renderState.baseLayer;
                    t.setFramebuffer(s.framebuffer);
                    var h = !1;
                    r.length !== f.cameras.length && (f.cameras.length = 0, h = !0);
                    for (var u = 0; u < r.length; u++) {
                        var c = r[u],
                            d = s.getViewport(c),
                            m = p[u];
                        m.matrix.fromArray(c.transform.matrix), m.projectionMatrix.fromArray(c.projectionMatrix), m.viewport.set(d.x, d.y, d.width, d.height), 0 === u && f.matrix.copy(m.matrix), !0 === h && f.cameras.push(m)
                    }
                }
                var g = i.inputSources;
                for (u = 0; u < l.length; u++) {
                    var v = l[u],
                        y = g[u];
                    v.update(y, n, a)
                }
                w && w(e, n)
            })), this.setAnimationLoop = function(t) {
                w = t
            }, this.dispose = function() {}
        }

        function ph(t) {
            var e = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                n = void 0 !== t.context ? t.context : null,
                i = void 0 !== t.alpha && t.alpha,
                r = void 0 === t.depth || t.depth,
                a = void 0 === t.stencil || t.stencil,
                s = void 0 !== t.antialias && t.antialias,
                o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                h = void 0 !== t.powerPreference ? t.powerPreference : "default",
                u = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat,
                c = null,
                p = null;
            this.domElement = e, this.debug = {
                checkShaderErrors: !0
            }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = 3e3, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
            var f, d, m, g, v, y, _, x, b, E, w, D, S, M, T, A, C, P, F = this,
                L = !1,
                R = null,
                I = 0,
                k = 0,
                O = null,
                N = null,
                B = -1,
                z = {
                    geometry: null,
                    program: null,
                    wireframe: !1
                },
                V = null,
                U = null,
                G = new xa,
                H = new xa,
                j = null,
                W = e.width,
                X = e.height,
                q = 1,
                Y = null,
                Z = null,
                J = new xa(0, 0, W, X),
                K = new xa(0, 0, W, X),
                $ = !1,
                Q = new ia,
                tt = new go,
                et = !1,
                nt = !1,
                it = new ca,
                rt = new Rr;

            function at() {
                return null === O ? q : 1
            }
            try {
                var st = {
                    alpha: i,
                    depth: r,
                    stencil: a,
                    antialias: s,
                    premultipliedAlpha: o,
                    preserveDrawingBuffer: l,
                    powerPreference: h,
                    failIfMajorPerformanceCaveat: u,
                    xrCompatible: !0
                };
                if (e.addEventListener("webglcontextlost", ut, !1), e.addEventListener("webglcontextrestored", ct, !1), null === (f = n || e.getContext("webgl", st) || e.getContext("experimental-webgl", st))) throw null !== e.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                void 0 === f.getShaderPrecisionFormat && (f.getShaderPrecisionFormat = function() {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                })
            } catch (t) {
                throw console.error("THREE.WebGLRenderer: " + t.message), t
            }

            function ot() {
                d = new vo(f), !1 === (m = new mo(f, d, t)).isWebGL2 && (d.get("WEBGL_depth_texture"), d.get("OES_texture_float"), d.get("OES_texture_half_float"), d.get("OES_texture_half_float_linear"), d.get("OES_standard_derivatives"), d.get("OES_element_index_uint"), d.get("ANGLE_instanced_arrays")), d.get("OES_texture_float_linear"), P = new ah(f, d, m), (g = new ih(f, d, m)).scissor(H.copy(K).multiplyScalar(q).floor()), g.viewport(G.copy(J).multiplyScalar(q).floor()), v = new xo(f), y = new Gl, _ = new rh(f, d, g, y, m, P, v), x = new Ua(f, m), b = new yo(f, x, v), E = new wo(f, b, x, v), T = new Eo(f), w = new Ul(F, d, m), D = new Xl, S = new $l, M = new po(F, g, E, o), A = new fo(f, d, v, m), C = new _o(f, d, v, m), v.programs = w.programs, F.capabilities = m, F.extensions = d, F.properties = y, F.renderLists = D, F.state = g, F.info = v
            }
            ot();
            var lt = new ch(F, f);
            this.xr = lt;
            var ht = new nh(F, E, m.maxTextureSize);

            function ut(t) {
                t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), L = !0
            }

            function ct() {
                console.log("THREE.WebGLRenderer: Context Restored."), L = !1, ot()
            }

            function pt(t) {
                var e = t.target;
                e.removeEventListener("dispose", pt),
                    function(t) {
                        ft(t), y.remove(t)
                    }(e)
            }

            function ft(t) {
                var e = y.get(t).program;
                t.program = void 0, void 0 !== e && w.releaseProgram(e)
            }
            this.shadowMap = ht, this.getContext = function() {
                return f
            }, this.getContextAttributes = function() {
                return f.getContextAttributes()
            }, this.forceContextLoss = function() {
                var t = d.get("WEBGL_lose_context");
                t && t.loseContext()
            }, this.forceContextRestore = function() {
                var t = d.get("WEBGL_lose_context");
                t && t.restoreContext()
            }, this.getPixelRatio = function() {
                return q
            }, this.setPixelRatio = function(t) {
                void 0 !== t && (q = t, this.setSize(W, X, !1))
            }, this.getSize = function(t) {
                return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new Dr), t.set(W, X)
            }, this.setSize = function(t, n, i) {
                lt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (W = t, X = n, e.width = Math.floor(t * q), e.height = Math.floor(n * q), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
            }, this.getDrawingBufferSize = function(t) {
                return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new Dr), t.set(W * q, X * q).floor()
            }, this.setDrawingBufferSize = function(t, n, i) {
                W = t, X = n, q = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n)
            }, this.getCurrentViewport = function(t) {
                return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new xa), t.copy(G)
            }, this.getViewport = function(t) {
                return t.copy(J)
            }, this.setViewport = function(t, e, n, i) {
                t.isVector4 ? J.set(t.x, t.y, t.z, t.w) : J.set(t, e, n, i), g.viewport(G.copy(J).multiplyScalar(q).floor())
            }, this.getScissor = function(t) {
                return t.copy(K)
            }, this.setScissor = function(t, e, n, i) {
                t.isVector4 ? K.set(t.x, t.y, t.z, t.w) : K.set(t, e, n, i), g.scissor(H.copy(K).multiplyScalar(q).floor())
            }, this.getScissorTest = function() {
                return $
            }, this.setScissorTest = function(t) {
                g.setScissorTest($ = t)
            }, this.setOpaqueSort = function(t) {
                Y = t
            }, this.setTransparentSort = function(t) {
                Z = t
            }, this.getClearColor = function() {
                return M.getClearColor()
            }, this.setClearColor = function() {
                M.setClearColor.apply(M, arguments)
            }, this.getClearAlpha = function() {
                return M.getClearAlpha()
            }, this.setClearAlpha = function() {
                M.setClearAlpha.apply(M, arguments)
            }, this.clear = function(t, e, n) {
                var i = 0;
                (void 0 === t || t) && (i |= f.COLOR_BUFFER_BIT), (void 0 === e || e) && (i |= f.DEPTH_BUFFER_BIT), (void 0 === n || n) && (i |= f.STENCIL_BUFFER_BIT), f.clear(i)
            }, this.clearColor = function() {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }, this.dispose = function() {
                e.removeEventListener("webglcontextlost", ut, !1), e.removeEventListener("webglcontextrestored", ct, !1), D.dispose(), S.dispose(), y.dispose(), E.dispose(), lt.dispose(), gt.stop()
            }, this.renderBufferImmediate = function(t, e) {
                g.initAttributes();
                var n = y.get(t);
                t.hasPositions && !n.position && (n.position = f.createBuffer()), t.hasNormals && !n.normal && (n.normal = f.createBuffer()), t.hasUvs && !n.uv && (n.uv = f.createBuffer()), t.hasColors && !n.color && (n.color = f.createBuffer());
                var i = e.getAttributes();
                t.hasPositions && (f.bindBuffer(f.ARRAY_BUFFER, n.position), f.bufferData(f.ARRAY_BUFFER, t.positionArray, f.DYNAMIC_DRAW), g.enableAttribute(i.position), f.vertexAttribPointer(i.position, 3, f.FLOAT, !1, 0, 0)), t.hasNormals && (f.bindBuffer(f.ARRAY_BUFFER, n.normal), f.bufferData(f.ARRAY_BUFFER, t.normalArray, f.DYNAMIC_DRAW), g.enableAttribute(i.normal), f.vertexAttribPointer(i.normal, 3, f.FLOAT, !1, 0, 0)), t.hasUvs && (f.bindBuffer(f.ARRAY_BUFFER, n.uv), f.bufferData(f.ARRAY_BUFFER, t.uvArray, f.DYNAMIC_DRAW), g.enableAttribute(i.uv), f.vertexAttribPointer(i.uv, 2, f.FLOAT, !1, 0, 0)), t.hasColors && (f.bindBuffer(f.ARRAY_BUFFER, n.color), f.bufferData(f.ARRAY_BUFFER, t.colorArray, f.DYNAMIC_DRAW), g.enableAttribute(i.color), f.vertexAttribPointer(i.color, 3, f.FLOAT, !1, 0, 0)), g.disableUnusedAttributes(), f.drawArrays(f.TRIANGLES, 0, t.count), t.count = 0
            };
            var dt = new za;
            this.renderBufferDirect = function(t, e, n, i, r, a) {
                null === e && (e = dt);
                var s = r.isMesh && r.matrixWorld.determinant() < 0,
                    o = bt(t, e, i, r);
                g.setMaterial(i, s);
                var l = !1;
                z.geometry === n.id && z.program === o.id && z.wireframe === (!0 === i.wireframe) || (z.geometry = n.id, z.program = o.id, z.wireframe = !0 === i.wireframe, l = !0), (i.morphTargets || i.morphNormals) && (T.update(r, n, i, o), l = !0), !0 === r.isInstancedMesh && (l = !0);
                var h = n.index,
                    u = n.attributes.position;
                if (null === h) {
                    if (void 0 === u || 0 === u.count) return
                } else if (0 === h.count) return;
                var c, p = 1;
                !0 === i.wireframe && (h = b.getWireframeAttribute(n), p = 2);
                var v = A;
                null !== h && (c = x.get(h), (v = C).setIndex(c)), l && (! function(t, e, n, i) {
                    if (!1 === m.isWebGL2 && (t.isInstancedMesh || e.isInstancedBufferGeometry) && null === d.get("ANGLE_instanced_arrays")) return;
                    g.initAttributes();
                    var r = e.attributes,
                        a = i.getAttributes(),
                        s = n.defaultAttributeValues;
                    for (var o in a) {
                        var l = a[o];
                        if (l >= 0) {
                            var h = r[o];
                            if (void 0 !== h) {
                                var u = h.normalized,
                                    c = h.itemSize;
                                if (void 0 === (w = x.get(h))) continue;
                                var p = w.buffer,
                                    v = w.type,
                                    y = w.bytesPerElement;
                                if (h.isInterleavedBufferAttribute) {
                                    var _ = h.data,
                                        b = _.stride,
                                        E = h.offset;
                                    _ && _.isInstancedInterleavedBuffer ? (g.enableAttributeAndDivisor(l, _.meshPerAttribute), void 0 === e.maxInstancedCount && (e.maxInstancedCount = _.meshPerAttribute * _.count)) : g.enableAttribute(l), f.bindBuffer(f.ARRAY_BUFFER, p), g.vertexAttribPointer(l, c, v, u, b * y, E * y)
                                } else h.isInstancedBufferAttribute ? (g.enableAttributeAndDivisor(l, h.meshPerAttribute), void 0 === e.maxInstancedCount && (e.maxInstancedCount = h.meshPerAttribute * h.count)) : g.enableAttribute(l), f.bindBuffer(f.ARRAY_BUFFER, p), g.vertexAttribPointer(l, c, v, u, 0, 0)
                            } else if ("instanceMatrix" === o) {
                                var w;
                                if (void 0 === (w = x.get(t.instanceMatrix))) continue;
                                p = w.buffer, v = w.type;
                                g.enableAttributeAndDivisor(l + 0, 1), g.enableAttributeAndDivisor(l + 1, 1), g.enableAttributeAndDivisor(l + 2, 1), g.enableAttributeAndDivisor(l + 3, 1), f.bindBuffer(f.ARRAY_BUFFER, p), f.vertexAttribPointer(l + 0, 4, v, !1, 64, 0), f.vertexAttribPointer(l + 1, 4, v, !1, 64, 16), f.vertexAttribPointer(l + 2, 4, v, !1, 64, 32), f.vertexAttribPointer(l + 3, 4, v, !1, 64, 48)
                            } else if (void 0 !== s) {
                                var D = s[o];
                                if (void 0 !== D) switch (D.length) {
                                    case 2:
                                        f.vertexAttrib2fv(l, D);
                                        break;
                                    case 3:
                                        f.vertexAttrib3fv(l, D);
                                        break;
                                    case 4:
                                        f.vertexAttrib4fv(l, D);
                                        break;
                                    default:
                                        f.vertexAttrib1fv(l, D)
                                }
                            }
                        }
                    }
                    g.disableUnusedAttributes()
                }(r, n, i, o), null !== h && f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, c.buffer));
                var y = null !== h ? h.count : u.count,
                    _ = n.drawRange.start * p,
                    E = n.drawRange.count * p,
                    w = null !== a ? a.start * p : 0,
                    D = null !== a ? a.count * p : 1 / 0,
                    S = Math.max(_, w),
                    M = Math.min(y, _ + E, w + D) - 1,
                    P = Math.max(0, M - S + 1);
                if (0 !== P) {
                    if (r.isMesh) !0 === i.wireframe ? (g.setLineWidth(i.wireframeLinewidth * at()), v.setMode(f.LINES)) : v.setMode(f.TRIANGLES);
                    else if (r.isLine) {
                        var F = i.linewidth;
                        void 0 === F && (F = 1), g.setLineWidth(F * at()), r.isLineSegments ? v.setMode(f.LINES) : r.isLineLoop ? v.setMode(f.LINE_LOOP) : v.setMode(f.LINE_STRIP)
                    } else r.isPoints ? v.setMode(f.POINTS) : r.isSprite && v.setMode(f.TRIANGLES);
                    r.isInstancedMesh ? v.renderInstances(n, S, P, r.count) : n.isInstancedBufferGeometry ? v.renderInstances(n, S, P, n.maxInstancedCount) : v.render(S, P)
                }
            }, this.compile = function(t, e) {
                (p = S.get(t, e)).init(), t.traverse((function(t) {
                    t.isLight && (p.pushLight(t), t.castShadow && p.pushShadow(t))
                })), p.setupLights(e);
                var n = {};
                t.traverse((function(e) {
                    if (e.material)
                        if (Array.isArray(e.material))
                            for (var i = 0; i < e.material.length; i++) e.material[i].uuid in n == !1 && (xt(e.material[i], t, e), n[e.material[i].uuid] = !0);
                        else e.material.uuid in n == !1 && (xt(e.material, t, e), n[e.material.uuid] = !0)
                }))
            };
            var mt = null;
            var gt = new Va;

            function vt(t, e, n, i) {
                if (!1 !== t.visible) {
                    if (t.layers.test(e.layers))
                        if (t.isGroup) n = t.renderOrder;
                        else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                    else if (t.isLight) p.pushLight(t), t.castShadow && p.pushShadow(t);
                    else if (t.isSprite) {
                        if (!t.frustumCulled || Q.intersectsSprite(t)) {
                            i && rt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(it);
                            var r = E.update(t);
                            (a = t.material).visible && c.push(t, r, a, n, rt.z, null)
                        }
                    } else if (t.isImmediateRenderObject) i && rt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(it), c.push(t, null, t.material, n, rt.z, null);
                    else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== v.render.frame && (t.skeleton.update(), t.skeleton.frame = v.render.frame), !t.frustumCulled || Q.intersectsObject(t))) {
                        i && rt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(it);
                        r = E.update(t);
                        var a = t.material;
                        if (Array.isArray(a))
                            for (var s = r.groups, o = 0, l = s.length; o < l; o++) {
                                var h = s[o],
                                    u = a[h.materialIndex];
                                u && u.visible && c.push(t, r, u, n, rt.z, h)
                            } else a.visible && c.push(t, r, a, n, rt.z, null)
                    }
                    var f = t.children;
                    for (o = 0, l = f.length; o < l; o++) vt(f[o], e, n, i)
                }
            }

            function yt(t, e, n, i) {
                for (var r = 0, a = t.length; r < a; r++) {
                    var s = t[r],
                        o = s.object,
                        l = s.geometry,
                        h = void 0 === i ? s.material : i,
                        u = s.group;
                    if (n.isArrayCamera) {
                        U = n;
                        for (var c = n.cameras, f = 0, d = c.length; f < d; f++) {
                            var m = c[f];
                            o.layers.test(m.layers) && (g.viewport(G.copy(m.viewport)), p.setupLights(m), _t(o, e, m, l, h, u))
                        }
                    } else U = null, _t(o, e, n, l, h, u)
                }
            }

            function _t(t, e, n, i, r, a) {
                if (t.onBeforeRender(F, e, n, i, r, a), p = S.get(e, U || n), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                    var s = bt(n, e, r, t);
                    g.setMaterial(r), z.geometry = null, z.program = null, z.wireframe = !1,
                        function(t, e) {
                            t.render((function(t) {
                                F.renderBufferImmediate(t, e)
                            }))
                        }(t, s)
                } else F.renderBufferDirect(n, e, i, r, t, a);
                t.onAfterRender(F, e, n, i, r, a), p = S.get(e, U || n)
            }

            function xt(t, e, n) {
                var i = y.get(t),
                    r = p.state.lights,
                    a = p.state.shadowsArray,
                    s = r.state.version,
                    o = w.getParameters(t, r.state, a, e, tt.numPlanes, tt.numIntersection, n),
                    l = w.getProgramCacheKey(o),
                    h = i.program,
                    u = !0;
                if (void 0 === h) t.addEventListener("dispose", pt);
                else if (h.cacheKey !== l) ft(t);
                else if (i.lightsStateVersion !== s) i.lightsStateVersion = s, u = !1;
                else {
                    if (void 0 !== o.shaderID) return;
                    u = !1
                }
                u && (h = w.acquireProgram(o, l), i.program = h, i.uniforms = o.uniforms, i.outputEncoding = o.outputEncoding, t.program = h);
                var c = h.getAttributes();
                if (t.morphTargets) {
                    t.numSupportedMorphTargets = 0;
                    for (var f = 0; f < F.maxMorphTargets; f++) c["morphTarget" + f] >= 0 && t.numSupportedMorphTargets++
                }
                if (t.morphNormals) {
                    t.numSupportedMorphNormals = 0;
                    for (f = 0; f < F.maxMorphNormals; f++) c["morphNormal" + f] >= 0 && t.numSupportedMorphNormals++
                }
                var d = i.uniforms;
                (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (i.numClippingPlanes = tt.numPlanes, i.numIntersection = tt.numIntersection, d.clippingPlanes = tt.uniform), i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.needsLights = function(t) {
                    return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                }(t), i.lightsStateVersion = s, i.needsLights && (d.ambientLightColor.value = r.state.ambient, d.lightProbe.value = r.state.probe, d.directionalLights.value = r.state.directional, d.directionalLightShadows.value = r.state.directionalShadow, d.spotLights.value = r.state.spot, d.spotLightShadows.value = r.state.spotShadow, d.rectAreaLights.value = r.state.rectArea, d.pointLights.value = r.state.point, d.pointLightShadows.value = r.state.pointShadow, d.hemisphereLights.value = r.state.hemi, d.directionalShadowMap.value = r.state.directionalShadowMap, d.directionalShadowMatrix.value = r.state.directionalShadowMatrix, d.spotShadowMap.value = r.state.spotShadowMap, d.spotShadowMatrix.value = r.state.spotShadowMatrix, d.pointShadowMap.value = r.state.pointShadowMap, d.pointShadowMatrix.value = r.state.pointShadowMatrix);
                var m = i.program.getUniforms(),
                    g = bl.seqWithValue(m.seq, d);
                i.uniformsList = g
            }

            function bt(t, e, n, i) {
                _.resetTextureUnits();
                var r = e.fog,
                    a = n.isMeshStandardMaterial ? e.environment : null,
                    s = null === O ? F.outputEncoding : O.texture.encoding,
                    o = y.get(n),
                    l = p.state.lights;
                if (et && (nt || t !== V)) {
                    var h = t === V && n.id === B;
                    tt.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, t, o, h)
                }
                n.version === o.__version ? void 0 === o.program || n.fog && o.fog !== r || o.environment !== a || o.needsLights && o.lightsStateVersion !== l.state.version ? xt(n, e, i) : void 0 === o.numClippingPlanes || o.numClippingPlanes === tt.numPlanes && o.numIntersection === tt.numIntersection ? o.outputEncoding !== s && xt(n, e, i) : xt(n, e, i) : (xt(n, e, i), o.__version = n.version);
                var u, c, d = !1,
                    v = !1,
                    x = !1,
                    b = o.program,
                    E = b.getUniforms(),
                    w = o.uniforms;
                if (g.useProgram(b.program) && (d = !0, v = !0, x = !0), n.id !== B && (B = n.id, v = !0), d || V !== t) {
                    if (E.setValue(f, "projectionMatrix", t.projectionMatrix), m.logarithmicDepthBuffer && E.setValue(f, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), V !== t && (V = t, v = !0, x = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                        var D = E.map.cameraPosition;
                        void 0 !== D && D.setValue(f, rt.setFromMatrixPosition(t.matrixWorld))
                    }(n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && E.setValue(f, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && E.setValue(f, "viewMatrix", t.matrixWorldInverse)
                }
                if (n.skinning) {
                    E.setOptional(f, i, "bindMatrix"), E.setOptional(f, i, "bindMatrixInverse");
                    var S = i.skeleton;
                    if (S) {
                        var M = S.bones;
                        if (m.floatVertexTextures) {
                            if (void 0 === S.boneTexture) {
                                var T = Math.sqrt(4 * M.length);
                                T = Er.ceilPowerOfTwo(T), T = Math.max(T, 4);
                                var A = new Float32Array(T * T * 4);
                                A.set(S.boneMatrices);
                                var C = new Cr(A, T, T, 1023, 1015);
                                S.boneMatrices = A, S.boneTexture = C, S.boneTextureSize = T
                            }
                            E.setValue(f, "boneTexture", S.boneTexture, _), E.setValue(f, "boneTextureSize", S.boneTextureSize)
                        } else E.setOptional(f, S, "boneMatrices")
                    }
                }
                return (v || o.receiveShadow !== i.receiveShadow) && (o.receiveShadow = i.receiveShadow, E.setValue(f, "receiveShadow", i.receiveShadow)), v && (E.setValue(f, "toneMappingExposure", F.toneMappingExposure), E.setValue(f, "toneMappingWhitePoint", F.toneMappingWhitePoint), o.needsLights && (c = x, (u = w).ambientLightColor.needsUpdate = c, u.lightProbe.needsUpdate = c, u.directionalLights.needsUpdate = c, u.directionalLightShadows.needsUpdate = c, u.pointLights.needsUpdate = c, u.pointLightShadows.needsUpdate = c, u.spotLights.needsUpdate = c, u.spotLightShadows.needsUpdate = c, u.rectAreaLights.needsUpdate = c, u.hemisphereLights.needsUpdate = c), r && n.fog && function(t, e) {
                    t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                }(w, r), n.isMeshBasicMaterial ? Et(w, n) : n.isMeshLambertMaterial ? (Et(w, n), function(t, e) {
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                }(w, n)) : n.isMeshToonMaterial ? (Et(w, n), function(t, e) {
                    t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.gradientMap && (t.gradientMap.value = e.gradientMap);
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                    e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                    e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }(w, n)) : n.isMeshPhongMaterial ? (Et(w, n), function(t, e) {
                    t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                    e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                    e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }(w, n)) : n.isMeshStandardMaterial ? (Et(w, n, a), n.isMeshPhysicalMaterial ? function(t, e, n) {
                    wt(t, e, n), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen);
                    e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);
                    e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);
                    e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate());
                    t.transparency.value = e.transparency
                }(w, n, a) : wt(w, n, a)) : n.isMeshMatcapMaterial ? (Et(w, n), function(t, e) {
                    e.matcap && (t.matcap.value = e.matcap);
                    e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                    e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }(w, n)) : n.isMeshDepthMaterial ? (Et(w, n), function(t, e) {
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }(w, n)) : n.isMeshDistanceMaterial ? (Et(w, n), function(t, e) {
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
                    t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                }(w, n)) : n.isMeshNormalMaterial ? (Et(w, n), function(t, e) {
                    e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                    e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }(w, n)) : n.isLineBasicMaterial ? (function(t, e) {
                    t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
                }(w, n), n.isLineDashedMaterial && function(t, e) {
                    t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                }(w, n)) : n.isPointsMaterial ? function(t, e) {
                    t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * q, t.scale.value = .5 * X, e.map && (t.map.value = e.map);
                    e.alphaMap && (t.alphaMap.value = e.alphaMap);
                    var n;
                    e.map ? n = e.map : e.alphaMap && (n = e.alphaMap);
                    void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                }(w, n) : n.isSpriteMaterial ? function(t, e) {
                    t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map);
                    e.alphaMap && (t.alphaMap.value = e.alphaMap);
                    var n;
                    e.map ? n = e.map : e.alphaMap && (n = e.alphaMap);
                    void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                }(w, n) : n.isShadowMaterial && (w.color.value.copy(n.color), w.opacity.value = n.opacity), void 0 !== w.ltc_1 && (w.ltc_1.value = _a.LTC_1), void 0 !== w.ltc_2 && (w.ltc_2.value = _a.LTC_2), bl.upload(f, o.uniformsList, w, _), n.isShaderMaterial && (n.uniformsNeedUpdate = !1)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (bl.upload(f, o.uniformsList, w, _), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && E.setValue(f, "center", i.center), E.setValue(f, "modelViewMatrix", i.modelViewMatrix), E.setValue(f, "normalMatrix", i.normalMatrix), E.setValue(f, "modelMatrix", i.matrixWorld), b
            }

            function Et(t, e, n) {
                t.opacity.value = e.opacity, e.color && t.diffuse.value.copy(e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap);
                var i, r, a = e.envMap || n;
                a && (t.envMap.value = a, t.flipEnvMap.value = a.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio, t.maxMipLevel.value = y.get(a).__maxMipLevel), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map ? i = e.map : e.specularMap ? i = e.specularMap : e.displacementMap ? i = e.displacementMap : e.normalMap ? i = e.normalMap : e.bumpMap ? i = e.bumpMap : e.roughnessMap ? i = e.roughnessMap : e.metalnessMap ? i = e.metalnessMap : e.alphaMap ? i = e.alphaMap : e.emissiveMap && (i = e.emissiveMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix)), e.aoMap ? r = e.aoMap : e.lightMap && (r = e.lightMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), t.uv2Transform.value.copy(r.matrix))
            }

            function wt(t, e, n) {
                t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), (e.envMap || n) && (t.envMapIntensity.value = e.envMapIntensity)
            }
            gt.setAnimationLoop((function(t) {
                lt.isPresenting || mt && mt(t)
            })), "undefined" != typeof window && gt.setContext(window), this.setAnimationLoop = function(t) {
                mt = t, lt.setAnimationLoop(t), gt.start()
            }, this.render = function(t, e) {
                var n, i;
                if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), i = arguments[3]), e && e.isCamera) {
                    if (!L) {
                        z.geometry = null, z.program = null, z.wireframe = !1, B = -1, V = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), lt.enabled && lt.isPresenting && (e = lt.getCamera(e)), t.onBeforeRender(F, t, e, n || O), (p = S.get(t, e)).init(), it.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), Q.setFromProjectionMatrix(it), nt = this.localClippingEnabled, et = tt.init(this.clippingPlanes, nt, e), (c = D.get(t, e)).init(), vt(t, e, 0, F.sortObjects), c.finish(), !0 === F.sortObjects && c.sort(Y, Z), et && tt.beginShadows();
                        var r = p.state.shadowsArray;
                        ht.render(r, t, e), p.setupLights(e), et && tt.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), M.render(c, t, e, i);
                        var a = c.opaque,
                            s = c.transparent;
                        if (t.overrideMaterial) {
                            var o = t.overrideMaterial;
                            a.length && yt(a, t, e, o), s.length && yt(s, t, e, o)
                        } else a.length && yt(a, t, e), s.length && yt(s, t, e);
                        t.onAfterRender(F, t, e), null !== O && (_.updateRenderTargetMipmap(O), _.updateMultisampleRenderTarget(O)), g.buffers.depth.setTest(!0), g.buffers.depth.setMask(!0), g.buffers.color.setMask(!0), g.setPolygonOffset(!1), c = null, p = null
                    }
                } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
            }, this.setFramebuffer = function(t) {
                R !== t && null === O && f.bindFramebuffer(f.FRAMEBUFFER, t), R = t
            }, this.getActiveCubeFace = function() {
                return I
            }, this.getActiveMipmapLevel = function() {
                return k
            }, this.getRenderTarget = function() {
                return O
            }, this.setRenderTarget = function(t, e, n) {
                O = t, I = e, k = n, t && void 0 === y.get(t).__webglFramebuffer && _.setupRenderTarget(t);
                var i = R,
                    r = !1;
                if (t) {
                    var a = y.get(t).__webglFramebuffer;
                    t.isWebGLCubeRenderTarget ? (i = a[e || 0], r = !0) : i = t.isWebGLMultisampleRenderTarget ? y.get(t).__webglMultisampledFramebuffer : a, G.copy(t.viewport), H.copy(t.scissor), j = t.scissorTest
                } else G.copy(J).multiplyScalar(q).floor(), H.copy(K).multiplyScalar(q).floor(), j = $;
                if (N !== i && (f.bindFramebuffer(f.FRAMEBUFFER, i), N = i), g.viewport(G), g.scissor(H), g.setScissorTest(j), r) {
                    var s = y.get(t.texture);
                    f.framebufferTexture2D(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.TEXTURE_CUBE_MAP_POSITIVE_X + (e || 0), s.__webglTexture, n || 0)
                }
            }, this.readRenderTargetPixels = function(t, e, n, i, r, a, s) {
                if (t && t.isWebGLRenderTarget) {
                    var o = y.get(t).__webglFramebuffer;
                    if (t.isWebGLCubeRenderTarget && void 0 !== s && (o = o[s]), o) {
                        var l = !1;
                        o !== N && (f.bindFramebuffer(f.FRAMEBUFFER, o), l = !0);
                        try {
                            var h = t.texture,
                                u = h.format,
                                c = h.type;
                            if (1023 !== u && P.convert(u) !== f.getParameter(f.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            if (!(1009 === c || P.convert(c) === f.getParameter(f.IMPLEMENTATION_COLOR_READ_TYPE) || 1015 === c && (m.isWebGL2 || d.get("OES_texture_float") || d.get("WEBGL_color_buffer_float")) || 1016 === c && (m.isWebGL2 ? d.get("EXT_color_buffer_float") : d.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            f.checkFramebufferStatus(f.FRAMEBUFFER) === f.FRAMEBUFFER_COMPLETE ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && f.readPixels(e, n, i, r, P.convert(u), P.convert(c), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                        } finally {
                            l && f.bindFramebuffer(f.FRAMEBUFFER, N)
                        }
                    }
                } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
            }, this.copyFramebufferToTexture = function(t, e, n) {
                void 0 === n && (n = 0);
                var i = Math.pow(2, -n),
                    r = Math.floor(e.image.width * i),
                    a = Math.floor(e.image.height * i),
                    s = P.convert(e.format);
                _.setTexture2D(e, 0), f.copyTexImage2D(f.TEXTURE_2D, n, s, t.x, t.y, r, a, 0), g.unbindTexture()
            }, this.copyTextureToTexture = function(t, e, n, i) {
                void 0 === i && (i = 0);
                var r = e.image.width,
                    a = e.image.height,
                    s = P.convert(n.format),
                    o = P.convert(n.type);
                _.setTexture2D(n, 0), e.isDataTexture ? f.texSubImage2D(f.TEXTURE_2D, i, t.x, t.y, r, a, s, o, e.image.data) : e.isCompressedTexture ? f.compressedTexSubImage2D(f.TEXTURE_2D, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, s, e.mipmaps[0].data) : f.texSubImage2D(f.TEXTURE_2D, i, t.x, t.y, s, o, e.image), 0 === i && n.generateMipmaps && f.generateMipmap(f.TEXTURE_2D), g.unbindTexture()
            }, this.initTexture = function(t) {
                _.setTexture2D(t, 0), g.unbindTexture()
            }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }

        function fh(t, e, n, i, r, a) {
            sh.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== i ? i : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix()
        }

        function dh(t) {
            return function(t) {
                if (Array.isArray(t)) return mh(t)
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
            }(t) || function(t, e) {
                if (!t) return;
                if ("string" == typeof t) return mh(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                "Object" === n && t.constructor && (n = t.constructor.name);
                if ("Map" === n || "Set" === n) return Array.from(t);
                if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return mh(t, e)
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function mh(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
            return i
        }

        function gh(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function vh(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }
        sh.prototype = Object.assign(Object.create(Ba.prototype), {
            constructor: sh,
            isCamera: !0,
            copy: function(t, e) {
                return Ba.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
            },
            getWorldDirection: function(t) {
                void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new Rr), this.updateMatrixWorld(!0);
                var e = this.matrixWorld.elements;
                return t.set(-e[8], -e[9], -e[10]).normalize()
            },
            updateMatrixWorld: function(t) {
                Ba.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
            },
            updateWorldMatrix: function(t, e) {
                Ba.prototype.updateWorldMatrix.call(this, t, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            }
        }), oh.prototype = Object.assign(Object.create(sh.prototype), {
            constructor: oh,
            isPerspectiveCamera: !0,
            copy: function(t, e) {
                return sh.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
            },
            setFocalLength: function(t) {
                var e = .5 * this.getFilmHeight() / t;
                this.fov = 2 * Er.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
            },
            getFocalLength: function() {
                var t = Math.tan(.5 * Er.DEG2RAD * this.fov);
                return .5 * this.getFilmHeight() / t
            },
            getEffectiveFOV: function() {
                return 2 * Er.RAD2DEG * Math.atan(Math.tan(.5 * Er.DEG2RAD * this.fov) / this.zoom)
            },
            getFilmWidth: function() {
                return this.filmGauge * Math.min(this.aspect, 1)
            },
            getFilmHeight: function() {
                return this.filmGauge / Math.max(this.aspect, 1)
            },
            setViewOffset: function(t, e, n, i, r, a) {
                this.aspect = t / e, null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
            },
            clearViewOffset: function() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function() {
                var t = this.near,
                    e = t * Math.tan(.5 * Er.DEG2RAD * this.fov) / this.zoom,
                    n = 2 * e,
                    i = this.aspect * n,
                    r = -.5 * i,
                    a = this.view;
                if (null !== this.view && this.view.enabled) {
                    var s = a.fullWidth,
                        o = a.fullHeight;
                    r += a.offsetX * i / s, e -= a.offsetY * n / o, i *= a.width / s, n *= a.height / o
                }
                var l = this.filmOffset;
                0 !== l && (r += t * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
            },
            toJSON: function(t) {
                var e = Ba.prototype.toJSON.call(this, t);
                return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
            }
        }), lh.prototype = Object.assign(Object.create(oh.prototype), {
            constructor: lh,
            isArrayCamera: !0
        }), hh.prototype = Object.assign(Object.create(Ba.prototype), {
            constructor: hh,
            isGroup: !0
        }), Object.assign(uh.prototype, {
            constructor: uh,
            getTargetRaySpace: function() {
                return null === this._targetRay && (this._targetRay = new hh, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay
            },
            getGripSpace: function() {
                return null === this._grip && (this._grip = new hh, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip
            },
            dispatchEvent: function(t) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), this
            },
            disconnect: function(t) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: t
                }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), this
            },
            update: function(t, e, n) {
                var i = null,
                    r = null,
                    a = this._targetRay,
                    s = this._grip;
                return t && (null !== a && null !== (i = e.getPose(t.targetRaySpace, n)) && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale)), null !== s && t.gripSpace && null !== (r = e.getPose(t.gripSpace, n)) && (s.matrix.fromArray(r.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale))), null !== a && (a.visible = null !== i), null !== s && (s.visible = null !== r), this
            }
        }), Object.assign(ch.prototype, wr.prototype), fh.prototype = Object.assign(Object.create(sh.prototype), {
            constructor: fh,
            isOrthographicCamera: !0,
            copy: function(t, e) {
                return sh.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
            },
            setViewOffset: function(t, e, n, i, r, a) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
            },
            clearViewOffset: function() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function() {
                var t = (this.right - this.left) / (2 * this.zoom),
                    e = (this.top - this.bottom) / (2 * this.zoom),
                    n = (this.right + this.left) / 2,
                    i = (this.top + this.bottom) / 2,
                    r = n - t,
                    a = n + t,
                    s = i + e,
                    o = i - e;
                if (null !== this.view && this.view.enabled) {
                    var l = (this.right - this.left) / this.view.fullWidth / this.zoom,
                        h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    a = (r += l * this.view.offsetX) + l * this.view.width, o = (s -= h * this.view.offsetY) - h * this.view.height
                }
                this.projectionMatrix.makeOrthographic(r, a, s, o, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
            },
            toJSON: function(t) {
                var e = Ba.prototype.toJSON.call(this, t);
                return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
            }
        });
        var yh = f.bounds;
        const _h = new(function() {
            function t() {
                var e = this;
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), vh(this, "run", (function(t) {
                    var n = t.current,
                        i = t.diff,
                        r = e.state,
                        a = [].concat(dh(pu.group.children), dh(pu.slides.children));
                    r.current = n, r.x += .5, a && a.forEach((function(t) {
                        t.material && (t.st ? t.onRaf(r.current, i, e.visible(t.bounds, n)) : t.onRaf(r.current))
                    })), pu.toggleSlides(r.current), e.renderer.render(e.scene, e.camera)
                })), vh(this, "resize", (function() {
                    var t = yh.ww,
                        n = yh.wh;
                    e.camera.updateProjectionMatrix(), e.renderer.setSize(t, n), pu.resize()
                })), this.scene = new za, this.camera = null, this.renderer = null, this.state = {
                    current: 0,
                    x: 0
                }
            }
            var e, n, i;
            return e = t, (n = [{
                key: "init",
                value: function(t) {
                    if (!this.initial) {
                        this.initial = !0;
                        var e = yh.ww,
                            n = yh.wh;
                        this.camera = new oh(45, e / n, .1, 100), this.camera.position.z = 50, this.renderer = new ph({
                            alpha: !0,
                            antialias: !0
                        }), this.renderer.setPixelRatio(1), this.renderer.setSize(e, n), this.renderer.setClearColor(16777215, 0), this.renderer.domElement.classList.add("gl"), this.scene.add(pu.group), this.scene.add(pu.slides)
                    }
                    this.el = t, this.el.appendChild(this.renderer.domElement), this.addEvents()
                }
            }, {
                key: "addEvents",
                value: function() {
                    k.on("tick", this.run), k.on("resize:on-reset", this.resize)
                }
            }, {
                key: "visible",
                value: function(t) {
                    var e = t.start,
                        n = t.end,
                        i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state.current;
                    return i > e && i < n
                }
            }, {
                key: "removeEvents",
                value: function() {
                    k.off("tick", this.run), k.off("resize:on-reset", this.resize)
                }
            }, {
                key: "destroy",
                value: function() {
                    this.removeEvents(), this.renderer.domElement.remove(), pu.removePlanes()
                }
            }]) && gh(e.prototype, n), i && gh(e, i), t
        }());

        function xh(t) {
            return t.getBoundingClientRect()
        }

        function bh(t) {
            return (bh = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function Eh(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }

        function wh(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function Dh(t, e) {
            return (Dh = Object.setPrototypeOf || function(t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function Sh(t) {
            var e = function() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
                } catch (t) {
                    return !1
                }
            }();
            return function() {
                var n, i = Th(t);
                if (e) {
                    var r = Th(this).constructor;
                    n = Reflect.construct(i, arguments, r)
                } else n = i.apply(this, arguments);
                return Mh(this, n)
            }
        }

        function Mh(t, e) {
            return !e || "object" !== bh(e) && "function" != typeof e ? function(t) {
                if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t
            }(t) : e
        }

        function Th(t) {
            return (Th = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            })(t)
        }
        var Ah = f.dom,
            Ch = f.bounds,
            Ph = function(t) {
                ! function(t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            writable: !0,
                            configurable: !0
                        }
                    }), e && Dh(t, e)
                }(a, t);
                var e, n, i, r = Sh(a);

                function a() {
                    return Eh(this, a), r.apply(this, arguments)
                }
                return e = a, (n = [{
                    key: "init",
                    value: function() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        this.args = t, this.el = this.args.el, this.name = this.args.name, this.progress = {
                            x: 0,
                            y: 0
                        }, this.static = !1, this.out = !0, this.setBounds()
                    }
                }, {
                    key: "update",
                    value: function() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ah.body;
                        this.removed = !1, this.el = d('[data-gl-id="'.concat(this.name, '"]'), t), this.resize()
                    }
                }, {
                    key: "setBounds",
                    value: function() {
                        var t = Ch.ww,
                            e = Ch.wh,
                            n = Ch.hero,
                            i = xh(this.el),
                            r = i.left,
                            a = i.top,
                            s = i.bottom,
                            o = i.width,
                            l = i.height;
                        this.bounds = {
                            left: r,
                            width: o,
                            height: l,
                            top: a,
                            start: a - e - 100,
                            end: s + 100,
                            min: r < t ? -t : 0,
                            max: r > t ? n.w + t : n.w
                        }, this.updateSize(), this.updateY(), this.updateX()
                    }
                }, {
                    key: "resize",
                    value: function() {
                        !this.removed && this.setBounds()
                    }
                }, {
                    key: "calculateUnitSize",
                    value: function() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.position.z,
                            e = _h.camera.fov * Math.PI / 180,
                            n = 2 * Math.tan(e / 2) * t,
                            i = n * _h.camera.aspect;
                        return {
                            width: i,
                            height: n
                        }
                    }
                }, {
                    key: "updateSize",
                    value: function() {
                        this.camUnit = this.calculateUnitSize(_h.camera.position.z - this.position.z);
                        var t = Ch.ww,
                            e = Ch.wh,
                            n = this.bounds,
                            i = n.width / t,
                            r = n.height / e;
                        i && r && (this.scale.x = this.camUnit.width * i, this.scale.y = this.camUnit.height * r)
                    }
                }, {
                    key: "updateY",
                    value: function() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                            e = Ch.wh,
                            n = this.bounds.top,
                            i = this.camUnit.height;
                        this.position.y = i / 2 - this.scale.y / 2, this.position.y -= (n - t) / e * i
                    }
                }, {
                    key: "updateX",
                    value: function() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                            e = Ch.ww,
                            n = this.bounds,
                            i = n.left,
                            r = n.min,
                            a = n.max,
                            s = this.camUnit.width;
                        if (this.position.x = -s / 2 + this.scale.x / 2, this.slide) {
                            var o = t + _h.state.x,
                                l = vr.utils.wrap(r, a, o);
                            this.position.x += (i - l) / e * s
                        } else this.position.x += (i + t) / e * s
                    }
                }, {
                    key: "onRaf",
                    value: function() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                        !this.static && (this.slide ? this.updateX(t) : this.updateY(t))
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        this.parent && this.parent.remove(this), this.removed = !0, this.visible = this.static = !1
                    }
                }]) && wh(e.prototype, n), i && wh(e, i), a
            }(Ba);

        function Fh(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }
        var Lh = f.bounds,
            Rh = f.dom,
            Ih = function t() {
                var e = this;
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), Fh(this, "render", (function() {
                    e.renderer.render(e.scene, e.camera)
                })), Fh(this, "out", (function(t) {
                    var n = t.done,
                        i = t.from,
                        r = e.mat.uniforms.uProgress;
                    e.tl.clear().to(r, {
                        value: 1,
                        duration: 1,
                        ease: "power2.inOut",
                        onUpdate: function() {
                            return e.render()
                        }
                    }, 0).add((function() {
                        i.remove(), n()
                    })).play()
                })), Fh(this, "in", (function(t) {
                    var n = t.done,
                        i = e.mat.uniforms,
                        r = i.uProgress,
                        a = i.uOut;
                    e.tl.clear().set(a, {
                        value: !1
                    }).to(r, {
                        value: 0,
                        duration: .85,
                        ease: "power3.inOut",
                        onUpdate: function() {
                            return e.render()
                        }
                    }, 0).set(a, {
                        value: !0
                    }).add((function() {
                        return n()
                    })).play()
                })), Fh(this, "resize", (function() {
                    var t = Lh.ww,
                        n = Lh.wh;
                    e.camera.left = t / -2, e.camera.right = t / 2, e.camera.top = n / 2, e.camera.bottom = n / -2, e.camera.updateProjectionMatrix(), e.renderer.setSize(t, n), e.triangle.scale.set(t / 2, n / 2, 1)
                }));
                var n = Lh.ww,
                    i = Lh.wh;
                this.renderer = new ph({
                    alpha: !0,
                    antialias: !0
                }), this.renderer.setPixelRatio(1), this.renderer.setSize(n, i), this.renderer.setClearColor(16777215, 0), this.scene = new za, this.camera = new fh(n / -2, n / 2, i / 2, i / -2, 1, 100), this.camera.lookAt(this.scene.position), this.camera.position.z = 1, this.renderer.domElement.classList.add("t"), Rh.body.appendChild(this.renderer.domElement), this.geo = new ds;
                var r = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
                    a = new Float32Array([0, 0, 2, 0, 0, 2]);
                this.geo.setAttribute("uv", new Za(a, 2)), this.geo.setAttribute("position", new Za(r, 3)), this.texture = new Ar, this.texture.generateMipMaps = !1, this.texture.minFilter = 1006, this.texture.magFilter = 1006, this.texture.format = 1022;
                var s = new Image;
                s.src = "/static/bg-gradient.png", s.decode().then((function() {
                    e.texture.image = s, e.texture.needsUpdate = !0
                })), this.mat = new ws({
                    fragmentShader: "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D uTexture;\n\nuniform float uProgress;\n\nuniform bool uOut;\n\nvec4 transparent = vec4(0., 0., 0., 0.);\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec2 uv = vUv;\n\n  vec4 tex = texture2D(uTexture, uv);\n\n  if (!uOut) uv.y = 1. - uv.y;\n  float t = step(uv.y, uProgress);\n  vec4 color = mix(transparent, tex, t);\n  \n  gl_FragColor = color;\n}  ",
                    vertexShader: "precision highp float;\n#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(){\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",
                    uniforms: {
                        uProgress: {
                            value: 0
                        },
                        uTexture: {
                            value: this.texture
                        },
                        uOut: {
                            value: !0
                        }
                    }
                }), this.triangle = new oo(this.geo, this.mat), this.triangle.scale.set(n / 2, i / 2, 1), this.triangle.frustumCulled = !1, this.scene.add(this.triangle), this.tl = vr.timeline({
                    paused: !0
                }), k.on("transition:out", this.out), k.on("transition:in", this.in), k.on("resize:on-reset", this.resize)
            };

        function kh(t) {
            return (kh = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function Oh(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }

        function Nh(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function Bh(t, e, n) {
            return (Bh = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(t, e, n) {
                var i = function(t, e) {
                    for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Hh(t)););
                    return t
                }(t, e);
                if (i) {
                    var r = Object.getOwnPropertyDescriptor(i, e);
                    return r.get ? r.get.call(n) : r.value
                }
            })(t, e, n || t)
        }

        function zh(t, e) {
            return (zh = Object.setPrototypeOf || function(t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function Vh(t) {
            var e = function() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
                } catch (t) {
                    return !1
                }
            }();
            return function() {
                var n, i = Hh(t);
                if (e) {
                    var r = Hh(this).constructor;
                    n = Reflect.construct(i, arguments, r)
                } else n = i.apply(this, arguments);
                return Uh(this, n)
            }
        }

        function Uh(t, e) {
            return !e || "object" !== kh(e) && "function" != typeof e ? Gh(t) : e
        }

        function Gh(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }

        function Hh(t) {
            return (Hh = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            })(t)
        }

        function jh(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }
        var Wh = new vs(1, 1, 15, 1),
            Xh = new ws({
                vertexShader: "precision highp float;\n#define GLSLIFY 1\n\nuniform float uProgress;\nuniform float uOffset;\nuniform float uVelo;\nuniform float uStrength;\n\n#define M_PI 3.1415926535897932384626433832795\n\nvarying vec2 vUv;\n\nvoid main(){\n  vec3 pos = position;\n  vec4 mvPosition = modelViewMatrix * vec4(pos, 1.);\n\n  float dist = mvPosition.x / uOffset;\n  mvPosition.z += sin(dist * M_PI + M_PI / 2.) * -uStrength * (1. + (uVelo * 1.5));\n\n  vUv = uv;\n  gl_Position = projectionMatrix * mvPosition;\n}",
                fragmentShader: "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D uTexture;\n\nuniform float uAlpha;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec2 uv = vUv;\n\n  vec4 texture = texture2D(uTexture, uv);\n  \n  gl_FragColor = texture * uAlpha;\n}"
            }),
            qh = f.bounds,
            Yh = f.flags,
            Zh = function(t) {
                ! function(t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            writable: !0,
                            configurable: !0
                        }
                    }), e && zh(t, e)
                }(a, t);
                var e, n, i, r = Vh(a);

                function a() {
                    var t;
                    Oh(this, a);
                    for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
                    return jh(Gh(t = r.call.apply(r, [this].concat(n))), "play", (function() {
                        t.visible = !0
                    })), jh(Gh(t), "pause", (function() {
                        t.visible = !1
                    })), t
                }
                return e = a, (n = [{
                    key: "init",
                    value: function(t) {
                        var e = this;
                        if (Bh(Hh(a.prototype), "init", this).call(this, t), this.geometry = Wh, this.material = Xh.clone(), this.texture = new Ar, this.texture.generateMipMaps = !1, this.texture.minFilter = 1006, this.texture.magFilter = 1006, this.texture.format = 1022, this.slide = !0, this.initial = !0, this.material.uniforms = {
                                uTime: {
                                    value: 0
                                },
                                uTexture: {
                                    value: this.texture
                                },
                                uVelo: {
                                    value: 0
                                },
                                uStrength: {
                                    value: 0
                                },
                                uProgress: {
                                    value: 0
                                },
                                uAlpha: {
                                    value: 1
                                },
                                uOffset: {
                                    value: 0
                                }
                            }, this.setUnis(), Yh.isDesktop) this.vid = document.createElement("video"), this.vid.src = location.origin + this.el.dataset.vid, this.vid.muted = !0, this.vid.loop = !0, this.vid.currentTime = 1, this.vid.lastFrame = !1, this.vid.preload = !0, this.vid.play();
                        else {
                            var n = new Image;
                            n.src = this.el.dataset.img, n.decode().then((function() {
                                e.texture.image = n, e.texture.needsUpdate = !0
                            }))
                        }
                        this.mesh = new oo(this.geometry, this.material), this.add(this.mesh), pu.slides.add(this), pu.planes[this.name] = this, this.onAdd()
                    }
                }, {
                    key: "onAdd",
                    value: function() {
                        this.vid && this.vid.play(), k.on("intro:in", this.play), k.on("intro:out", this.pause)
                    }
                }, {
                    key: "setUnis",
                    value: function() {
                        var t = this.material.uniforms,
                            e = t.uStrength,
                            n = t.uOffset;
                        e.value = qh.ww / 100, n.value = this.camUnit.width
                    }
                }, {
                    key: "updateX",
                    value: function(t) {
                        this.visible && this.material && (Bh(Hh(a.prototype), "updateX", this).call(this, t), this.material.uniforms.uVelo.value = _u.velo.diff, this.vid && this.updateVid())
                    }
                }, {
                    key: "updateVid",
                    value: function() {
                        this.vid.readyState >= this.vid.HAVE_CURRENT_DATA && (this.vid.lastFrame ? this.vid.lastFrame = !1 : (this.vid.lastFrame = !0, this.initial && (this.initial = !1, this.texture.image = this.vid, pu.loaded.push(!0), 10 === pu.loaded.length && (Yh.loaded = !0, k.emit("gl:loaded"))), this.texture.needsUpdate = !0))
                    }
                }, {
                    key: "resize",
                    value: function() {
                        Bh(Hh(a.prototype), "resize", this).call(this), this.setUnis()
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        Bh(Hh(a.prototype), "destroy", this).call(this), k.off("intro:in", this.play), k.off("intro:out", this.pause), this.vid && this.vid.pause()
                    }
                }]) && Nh(e.prototype, n), i && Nh(e, i), a
            }(Ph);

        function Jh(t) {
            return (Jh = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function Kh(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }

        function $h(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function Qh(t, e, n) {
            return (Qh = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(t, e, n) {
                var i = function(t, e) {
                    for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = iu(t)););
                    return t
                }(t, e);
                if (i) {
                    var r = Object.getOwnPropertyDescriptor(i, e);
                    return r.get ? r.get.call(n) : r.value
                }
            })(t, e, n || t)
        }

        function tu(t, e) {
            return (tu = Object.setPrototypeOf || function(t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function eu(t) {
            var e = function() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
                } catch (t) {
                    return !1
                }
            }();
            return function() {
                var n, i = iu(t);
                if (e) {
                    var r = iu(this).constructor;
                    n = Reflect.construct(i, arguments, r)
                } else n = i.apply(this, arguments);
                return nu(this, n)
            }
        }

        function nu(t, e) {
            return !e || "object" !== Jh(e) && "function" != typeof e ? function(t) {
                if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t
            }(t) : e
        }

        function iu(t) {
            return (iu = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            })(t)
        }
        var ru = new vs(1, 1, 15, 1),
            au = new ws({
                vertexShader: "precision mediump float;\n#define GLSLIFY 1\n\nuniform float uProgress;\nuniform float uVelo;\n\n#define M_PI 3.1415926535897932384626433832795\n\nvarying vec2 vUv;\n\nvoid main(){\n  vec3 pos = position;\n\n  pos.y += ((sin(uv.x * M_PI) * uVelo) * 0.35);\n\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\n}",
                fragmentShader: "precision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D uTexture;\n\nuniform float uAlpha;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec2 uv = vUv;\n\n  vec4 texture = texture2D(uTexture, uv);\n  \n  gl_FragColor = texture;\n}"
            }),
            su = function(t) {
                ! function(t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            writable: !0,
                            configurable: !0
                        }
                    }), e && tu(t, e)
                }(a, t);
                var e, n, i, r = eu(a);

                function a() {
                    return Kh(this, a), r.apply(this, arguments)
                }
                return e = a, (n = [{
                    key: "init",
                    value: function(t) {
                        Qh(iu(a.prototype), "init", this).call(this, t), this.geometry = ru, this.material = au.clone(), this.texture = new Ar, this.texture.generateMipMaps = !1, this.texture.minFilter = 1006, this.texture.magFilter = 1006, this.texture.format = 1022, this.st = !0, this.animated = !1, this.initial = !0, this.material.uniforms = {
                            uTime: {
                                value: 0
                            },
                            uTexture: {
                                value: this.texture
                            },
                            uVelo: {
                                value: 0
                            },
                            uProgress: {
                                value: 0
                            },
                            uAlpha: {
                                value: 1
                            },
                            uOffset: {
                                value: this.camUnit.width
                            }
                        }, this.vid = document.createElement("video"), this.vid.src = location.origin + this.el.dataset.src, this.vid.muted = !0, this.vid.loop = !0, this.vid.currentTime = 1, this.vid.lastFrame = !1, this.vid.preload = !0, this.mesh = new oo(this.geometry, this.material), this.mesh.renderOrder = 10, this.add(this.mesh), pu.group.add(this), pu.planes[this.name] = this
                    }
                }, {
                    key: "onRaf",
                    value: function() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                        !this.static && this.material && (this.updateY(t), this.material.uniforms.uVelo.value = e, this.updateVid(), n ? this.vid.play() : this.vid.pause())
                    }
                }, {
                    key: "updateVid",
                    value: function() {
                        this.vid.readyState >= this.vid.HAVE_ENOUGH_DATA && (this.vid.lastFrame ? this.vid.lastFrame = !1 : (this.vid.lastFrame = !0, this.initial && (this.initial = !1, this.texture.image = this.vid), this.texture.needsUpdate = !0))
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        Qh(iu(a.prototype), "destroy", this).call(this)
                    }
                }]) && $h(e.prototype, n), i && $h(e, i), a
            }(Ph);

        function ou(t) {
            return function(t) {
                if (Array.isArray(t)) return lu(t)
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
            }(t) || function(t, e) {
                if (!t) return;
                if ("string" == typeof t) return lu(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                "Object" === n && t.constructor && (n = t.constructor.name);
                if ("Map" === n || "Set" === n) return Array.from(t);
                if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return lu(t, e)
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function lu(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
            return i
        }

        function hu(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }
        var uu = f.bounds,
            cu = f.flags;
        const pu = new(function() {
            function e() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.planes = {}, this.slides = new hh, this.group = new hh, this.hero = d(".js-hero-inner"), this.heroVids = m(".js-hero-vid"), this.heroContent = d(".js-hero-content"), this.sv = !1, this.loaded = []
            }
            var n, i, r;
            return n = e, (i = [{
                key: "fromDom",
                value: function(e, n) {
                    var i = e.dataset.glId,
                        r = e.dataset.glComponent,
                        a = this.planes[i];
                    if (a && !a.keep) this.add(a, n);
                    else if (!a) {
                        if (cu.isDevice && "PlaneVideo" === r) return;
                        (new t[r]).init({
                            el: e,
                            name: i
                        })
                    }
                }
            }, {
                key: "addPlanes",
                value: function(t) {
                    var e = this,
                        n = t.el,
                        i = m("[data-gl-id]", n);
                    i && i.forEach((function(t) {
                        return e.fromDom(t, n)
                    }))
                }
            }, {
                key: "add",
                value: function(t, e) {
                    t.visible || (t.name.includes("slide") ? this.slides.add(t) : this.group.add(t), t.visible = !0, t.material.uniforms.uAlpha.value = 1, t.update(e), t.onAdd && t.onAdd())
                }
            }, {
                key: "resize",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                    for (var e in this.planes) this.planes[e].resize(t)
                }
            }, {
                key: "setStatic",
                value: function() {
                    [].concat(ou(this.group.children), ou(this.slides.children)).forEach((function(t) {
                        return t.static = !0
                    }))
                }
            }, {
                key: "removePlanes",
                value: function() {
                    for (var t in this.planes) this.remove(this.planes[t])
                }
            }, {
                key: "remove",
                value: function(t) {
                    t.destroy()
                }
            }, {
                key: "toggleSlides",
                value: function(t) {
                    var e = uu.hero.h;
                    t > e && !this.sv ? (k.emit("intro:out"), vr.set(this.heroContent, {
                        autoAlpha: 0
                    }), this.sv = !0) : t <= e && this.sv && (this.sv = !1, vr.set(this.heroContent, {
                        autoAlpha: 1
                    }), k.emit("intro:in"))
                }
            }]) && hu(n.prototype, i), r && hu(n, r), e
        }());

        function fu(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function du(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }
        var mu = f.dom,
            gu = f.flags,
            vu = gu.isDevice,
            yu = gu.isDesktop;
        const _u = new(function() {
            function t() {
                var e = this;
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), du(this, "tick", (function() {
                    vu ? (e.target = mu.scroll.scrollTop, k.emit("tick", {
                        target: e.target,
                        current: e.target,
                        diff: 0
                    })) : (e.last = e.current, e.current = yr(e.current, e.target, e.ease), e.rounded = Math.round(100 * e.current) / 100, e.diff = 5e-4 * (e.target - e.current), pu.sv || (e.velo.current = yr(e.velo.current, e.rounded, e.velo.ease), e.velo.diff = vr.utils.clamp(0, .75, 5e-4 * (e.rounded - e.velo.current))), k.emit("tick", {
                        target: e.target,
                        current: e.rounded,
                        diff: e.diff,
                        still: Math.abs(e.current - e.last) <= .001
                    }))
                })), du(this, "onScroll", (function(t) {
                    var n = t.y;
                    gu.locked || (e.target += n, e.clamp())
                })), du(this, "reset", (function() {
                    e.target = e.current = e.rounded = 0
                })), du(this, "resize", (function() {
                    e.clamp(), e.rounded = e.current = e.target
                })), this.target = 0, this.current = 0, this.rounded = 0, this.velo = {
                    current: 0,
                    diff: 0,
                    ease: .075
                }, this.ease = .115, this.init()
            }
            var e, n, i;
            return e = t, (n = [{
                key: "clamp",
                value: function() {
                    this.target = vr.utils.clamp(0, f.bounds.scroll, this.target)
                }
            }, {
                key: "init",
                value: function() {
                    vr.ticker.fps(-1), vr.ticker.add(this.tick), yu && (k.on("scroll", this.onScroll), k.on("resize:on-reset", this.resize), k.on("scroll:on-reset", this.reset))
                }
            }]) && fu(e.prototype, n), i && fu(e, i), t
        }());
        var xu = __webpack_require__(198),
            bu = __webpack_require__.n(xu);

        function Eu(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }
        var wu = f.dom,
            Du = f.bounds,
            Su = f.flags.isDevice;
        new(function() {
            function t() {
                var e, n, i, r = this;
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), i = function() {
                    var t = window.innerWidth;
                    Su && t === Du.ww || (Du.ww = t, Du.wh = window.innerHeight, r.setOrientation(wu, Du), r.setVh(), k.emit("resize"), Su && k.emit("resize:on-reset"))
                }, (n = "resize") in (e = this) ? Object.defineProperty(e, n, {
                    value: i,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[n] = i, this.setOrientation(wu, Du), this.setVh(), k.on("resize", window, bu()(this.resize, 200)), k.on("orientationchange", window, this.resize)
            }
            var e, n, i;
            return e = t, (n = [{
                key: "setOrientation",
                value: function(t, e) {
                    var n = t.body,
                        i = e.wh;
                    e.ww < i ? n.classList.add("is-portrait") : n.classList.remove("is-portrait")
                }
            }, {
                key: "setVh",
                value: function() {
                    wu.body.style.setProperty("--vh", "".concat(.01 * Du.wh, "px"))
                }
            }]) && Eu(e.prototype, n), i && Eu(e, i), t
        }());

        function Mu(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function Tu(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }
        var Au = f.flags,
            Cu = Au.isDevice;
        new(function() {
            function t() {
                var e = this;
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), Tu(this, "onMove", (function(t) {
                    if (Au.dragging) {
                        var n = e.getPos(t),
                            i = n.x,
                            r = n.y,
                            a = n.target;
                        k.emit("mousemove", {
                            x: i,
                            y: r,
                            target: a,
                            e: t
                        })
                    }
                })), Tu(this, "onDown", (function(t) {
                    if (3 !== t.which) {
                        var n = e.getPos(t),
                            i = n.x,
                            r = n.y,
                            a = n.target;
                        e.on = i, k.emit("mousedown", {
                            x: i,
                            y: r,
                            target: a
                        })
                    }
                })), Tu(this, "onUp", (function(t) {
                    var n = e.getPos(t),
                        i = n.x,
                        r = n.target;
                    e.off = i;
                    var a = Math.abs(e.off - e.on) < 10;
                    k.emit("mouseup", {
                        x: i,
                        target: r,
                        click: a
                    })
                })), this.on = 0, this.off = 0, this.events = {
                    move: Cu ? "touchmove" : "mousemove",
                    down: Cu ? "touchstart" : "mousedown",
                    up: Cu ? "touchend" : "mouseup"
                }, this.addEvents()
            }
            var e, n, i;
            return e = t, (n = [{
                key: "addEvents",
                value: function() {
                    var t = this.events,
                        e = t.move,
                        n = t.down,
                        i = t.up;
                    window.addEventListener(e, this.onMove, {
                        passive: !1
                    }), window.addEventListener(n, this.onDown, {
                        passive: !1
                    }), window.addEventListener(i, this.onUp, {
                        passive: !1
                    }), k.on("click", window, (function(t) {
                        return k.emit("click", t)
                    }))
                }
            }, {
                key: "getPos",
                value: function(t) {
                    return {
                        x: t.changedTouches ? t.changedTouches[0].clientX : t.clientX,
                        y: t.changedTouches ? t.changedTouches[0].clientY : t.clientY,
                        target: t.target
                    }
                }
            }]) && Mu(e.prototype, n), i && Mu(e, i), t
        }());

        function Pu(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }
        const Fu = new(function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.isRunning = !1, this.el = d(".js-pe")
            }
            var e, n, i;
            return e = t, (n = [{
                key: "run",
                value: function() {
                    var t = this;
                    clearTimeout(this.timer), this.timer = setTimeout((function() {
                        t.isRunning = !1, t.togglePointers("none")
                    }), 300), this.isRunning || (this.isRunning = !0, this.togglePointers("all"))
                }
            }, {
                key: "togglePointers",
                value: function(t) {
                    this.el.style.pointerEvents = t
                }
            }]) && Pu(e.prototype, n), i && Pu(e, i), t
        }());

        function Lu(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }
        var Ru = f.dom,
            Iu = f.flags;
        const ku = new function t() {
            var e = this;
            ! function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), Lu(this, "handle", (function(t) {
                t.forEach((function(t) {
                    var n = e.cache.find((function(e) {
                        var n = e.el;
                        return t.target === n
                    }));
                    n && (t.isIntersecting ? (n.enter && n.enter(n, t.target), n.intersecting = !0) : (n.leave && n.leave(n, t.target), n.intersecting = !1))
                }))
            })), Lu(this, "destroy", (function() {
                e.cache.forEach((function(t, n) {
                    e.inst.unobserve(t.el), t.ani && t.ani.destroy(), e.cache.splice(0, n)
                }))
            })), this.inst = new IntersectionObserver(this.handle, {
                root: Iu.isDesktop ? null : Ru.scroll
            }), k.on("on-leave-completed", this.destroy), this.cache = []
        };
        var Ou, Nu, Bu, zu, Vu, Uu = __webpack_require__(809),
            Gu = __webpack_require__.n(Uu),
            Hu = function() {
                return "undefined" != typeof window
            },
            ju = function() {
                return Ou || Hu() && (Ou = window.gsap) && Ou.registerPlugin && Ou
            },
            Wu = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi,
            Xu = {
                rect: ["width", "height"],
                circle: ["r", "r"],
                ellipse: ["rx", "ry"],
                line: ["x2", "y2"]
            },
            qu = function(t) {
                return Math.round(1e4 * t) / 1e4
            },
            Yu = function(t) {
                return parseFloat(t || 0)
            },
            Zu = function(t, e) {
                return Yu(t.getAttribute(e))
            },
            Ju = Math.sqrt,
            Ku = function(t, e, n, i, r, a) {
                return Ju(Math.pow((Yu(n) - Yu(t)) * r, 2) + Math.pow((Yu(i) - Yu(e)) * a, 2))
            },
            $u = function(t) {
                return console.warn(t)
            },
            Qu = function(t) {
                return "non-scaling-stroke" === t.getAttribute("vector-effect")
            },
            tc = function(t) {
                if (!(t = Nu(t)[0])) return 0;
                var e, n, i, r, a, s, o, l = t.tagName.toLowerCase(),
                    h = t.style,
                    u = 1,
                    c = 1;
                Qu(t) && (c = t.getScreenCTM(), u = Ju(c.a * c.a + c.b * c.b), c = Ju(c.d * c.d + c.c * c.c));
                try {
                    n = t.getBBox()
                } catch (t) {
                    $u("Some browsers won't measure invisible elements (like display:none or masks inside defs).")
                }
                var p = n || {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    },
                    f = p.x,
                    d = p.y,
                    m = p.width,
                    g = p.height;
                if (n && (m || g) || !Xu[l] || (m = Zu(t, Xu[l][0]), g = Zu(t, Xu[l][1]), "rect" !== l && "line" !== l && (m *= 2, g *= 2), "line" === l && (f = Zu(t, "x1"), d = Zu(t, "y1"), m = Math.abs(m - f), g = Math.abs(g - d))), "path" === l) r = h.strokeDasharray, h.strokeDasharray = "none", e = t.getTotalLength() || 0, u !== c && $u("Warning: <path> length cannot be measured when vector-effect is non-scaling-stroke and the element isn't proportionally scaled."), e *= (u + c) / 2, h.strokeDasharray = r;
                else if ("rect" === l) e = 2 * m * u + 2 * g * c;
                else if ("line" === l) e = Ku(f, d, f + m, d + g, u, c);
                else if ("polyline" === l || "polygon" === l)
                    for (i = t.getAttribute("points").match(Wu) || [], "polygon" === l && i.push(i[0], i[1]), e = 0, a = 2; a < i.length; a += 2) e += Ku(i[a - 2], i[a - 1], i[a], i[a + 1], u, c) || 0;
                else "circle" !== l && "ellipse" !== l || (s = m / 2 * u, o = g / 2 * c, e = Math.PI * (3 * (s + o) - Ju((3 * s + o) * (s + 3 * o))));
                return e || 0
            },
            ec = function(t, e) {
                if (!(t = Nu(t)[0])) return [0, 0];
                e || (e = tc(t) + 1);
                var n = Bu.getComputedStyle(t),
                    i = n.strokeDasharray || "",
                    r = Yu(n.strokeDashoffset),
                    a = i.indexOf(",");
                return a < 0 && (a = i.indexOf(" ")), (i = a < 0 ? e : Yu(i.substr(0, a)) || 1e-5) > e && (i = e), [Math.max(0, -r), Math.max(0, i - r)]
            },
            nc = function() {
                Hu() && (document, Bu = window, Vu = Ou = ju(), Nu = Ou.utils.toArray, zu = -1 !== ((Bu.navigator || {}).userAgent || "").indexOf("Edge"))
            },
            ic = {
                version: "3.2.6",
                name: "drawSVG",
                register: function(t) {
                    Ou = t, nc()
                },
                init: function(t, e, n, i, r) {
                    if (!t.getBBox) return !1;
                    Vu || nc();
                    var a, s, o, l, h = tc(t) + 1;
                    return this._style = t.style, this._target = t, e + "" == "true" ? e = "0 100%" : e ? -1 === (e + "").indexOf(" ") && (e = "0 " + e) : e = "0 0", s = function(t, e, n) {
                        var i, r, a = t.indexOf(" ");
                        return a < 0 ? (i = void 0 !== n ? n + "" : t, r = t) : (i = t.substr(0, a), r = t.substr(a + 1)), (i = ~i.indexOf("%") ? Yu(i) / 100 * e : Yu(i)) > (r = ~r.indexOf("%") ? Yu(r) / 100 * e : Yu(r)) ? [r, i] : [i, r]
                    }(e, h, (a = ec(t, h))[0]), this._length = qu(h + 10), 0 === a[0] && 0 === s[0] ? (o = Math.max(1e-5, s[1] - h), this._dash = qu(h + o), this._offset = qu(h - a[1] + o), this._offsetPT = this.add(this, "_offset", this._offset, qu(h - s[1] + o))) : (this._dash = qu(a[1] - a[0]) || 1e-6, this._offset = qu(-a[0]), this._dashPT = this.add(this, "_dash", this._dash, qu(s[1] - s[0]) || 1e-5), this._offsetPT = this.add(this, "_offset", this._offset, qu(-s[0]))), zu && (l = Bu.getComputedStyle(t)).strokeLinecap !== l.strokeLinejoin && (s = Yu(l.strokeMiterlimit), this.add(t.style, "strokeMiterlimit", s, s + .01)), this._live = Qu(t) || ~(e + "").indexOf("live"), this._props.push("drawSVG"), 1
                },
                render: function(t, e) {
                    var n, i, r, a, s = e._pt,
                        o = e._style;
                    if (s) {
                        for (e._live && (n = tc(e._target) + 11) !== e._length && (i = n / e._length, e._length = n, e._offsetPT.s *= i, e._offsetPT.c *= i, e._dashPT ? (e._dashPT.s *= i, e._dashPT.c *= i) : e._dash *= i); s;) s.r(t, s.d), s = s._next;
                        r = e._dash, a = e._offset, n = e._length, o.strokeDashoffset = e._offset, 1 !== t && t ? o.strokeDasharray = r + "px," + n + "px" : (r - a < .001 && n - r <= 10 && (o.strokeDashoffset = a + 1), o.strokeDasharray = a < .001 && n - r <= 10 ? "none" : a === r ? "0px, 999999px" : r + "px," + n + "px")
                    }
                },
                getLength: tc,
                getPosition: ec
            };

        function rc(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function ac(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }
        ju() && Ou.registerPlugin(ic), vr.registerPlugin(ic);
        var sc = f.flags,
            oc = function() {
                function t() {
                    var e = this;
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), ac(this, "run", (function() {
                        var t = sc.isDevice,
                            n = sc.loaded;
                        !e.home || t || n ? e.go() : k.on("gl:loaded", e.go)
                    })), ac(this, "go", (function() {
                        e.tl.pause(), e.tl.tweenTo("end"), e.clock.loop = !1
                    })), this.el = d(".js-mask"), this.ui = {
                        bg: d(".js-mask-bg"),
                        circle: d(".js-mask-circle"),
                        outline: d(".js-mask-outline"),
                        clock: d(".js-mask-clock")
                    }, this.home = d(".js-h-circle"), this.init()
                }
                var e, n, i;
                return e = t, (n = [{
                    key: "init",
                    value: function() {
                        this.createClock(), this.prepare(), this.run()
                    }
                }, {
                    key: "addEvents",
                    value: function() {
                        k.on("loaded", this.run)
                    }
                }, {
                    key: "createClock",
                    value: function() {
                        var t = this.ui.clock;
                        this.clock = Gu().loadAnimation({
                            container: t,
                            renderer: "svg",
                            loop: !0,
                            autoplay: !1,
                            path: "./static/lottie/preloader/data.json"
                        }), this.clock.setSubframe(!1), this.clock.setSpeed(1.25)
                    }
                }, {
                    key: "prepare",
                    value: function() {
                        var t, e = this;
                        this.home && (t = xh(this.home).bottom);
                        var n = this.ui,
                            i = n.circle,
                            r = n.bg,
                            a = n.outline;
                        this.tl = vr.timeline({
                            paused: !0,
                            immediateRender: !0,
                            onStart: function() {
                                e.clock.play()
                            },
                            onComplete: function() {
                                e.destroy(), e.el.innerHTML = "", f.flags.locked = !1
                            }
                        }).addLabel("start"), this.home ? this.tl.set([a, ".js-h-progress"], {
                            alpha: vr.utils.wrap([1, 0])
                        }) : this.tl.set(a, {
                            alpha: 1
                        }), this.tl.from(a, {
                            drawSVG: 0,
                            duration: 1.75,
                            ease: "power2.inOut"
                        }).addLabel("loaded"), this.home ? this.tl.to(i, {
                            y: t - xh(i).bottom,
                            scale: .75,
                            duration: 2,
                            ease: "power2.inOut"
                        }).to(r, {
                            alpha: 0,
                            duration: .95,
                            ease: "power1.inOut"
                        }, "-=0.95").to([i, ".js-h-progress"], {
                            alpha: vr.utils.wrap([0, 1]),
                            duration: .15,
                            ease: "linear"
                        }) : this.tl.to(this.el, {
                            alpha: 0,
                            duration: .85,
                            ease: "power1.inOut"
                        }), this.tl.addLabel("end")
                    }
                }, {
                    key: "removeEvents",
                    value: function() {
                        k.off("loaded", this.run)
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        this.removeEvents(), this.clock.destroy(), this.tl.kill(), this.ui = null
                    }
                }]) && rc(e.prototype, n), i && rc(e, i), t
            }();

        function lc(t) {
            return function(t) {
                if (Array.isArray(t)) return hc(t)
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
            }(t) || function(t, e) {
                if (!t) return;
                if ("string" == typeof t) return hc(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                "Object" === n && t.constructor && (n = t.constructor.name);
                if ("Map" === n || "Set" === n) return Array.from(t);
                if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return hc(t, e)
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function hc(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
            return i
        }

        function uc(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }

        function cc(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function pc(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }
        var fc = f.flags,
            dc = function() {
                function t() {
                    var e = this,
                        n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m("[data-smooth-item]");
                    uc(this, t), pc(this, "run", (function(t) {
                        var n = t.current;
                        e.current = n, !e.resizing && e.transformSections()
                    })), pc(this, "resize", (function() {
                        e.resizing = !0, e.getSections(), k.emit("resize:on-reset"), e.transformSections(), e.resizing = !1
                    })), this.elems = n, this.current = 0, this.last = null, this.resizing = !1, this.sections = null, this.init()
                }
                var e, n, i;
                return e = t, (n = [{
                    key: "init",
                    value: function() {
                        this.getSections(), this.addEvents()
                    }
                }, {
                    key: "addEvents",
                    value: function() {
                        k.on("tick", this.run), k.on("resize", this.resize)
                    }
                }, {
                    key: "update",
                    value: function(t) {
                        this.elems = t, this.getSections()
                    }
                }, {
                    key: "getSections",
                    value: function() {
                        if (this.elems) {
                            var t = f.bounds,
                                e = this.elems.length - 1;
                            this.sections = lc(this.elems).map((function(n, i) {
                                n.style.transform = "translate3d(0, 0, 0)";
                                var r = xh(n),
                                    a = r.top,
                                    s = r.bottom;
                                return i === e && (t.scroll = s - t.wh), {
                                    el: n,
                                    start: a - t.wh,
                                    end: s,
                                    out: !0
                                }
                            }))
                        }
                    }
                }, {
                    key: "transformSections",
                    value: function() {
                        var t = this;
                        fc.locked || this.sections.length > 0 && this.sections.forEach((function(e) {
                            t.visible(e) || t.resizing ? (e.out && (e.out = !1), t.transform(e.el)) : e.out || (e.out = !0, t.transform(e.el))
                        }))
                    }
                }, {
                    key: "transform",
                    value: function(t) {
                        t.style.transform = "translate3d(0, ".concat(-this.current, "px, 0)")
                    }
                }, {
                    key: "visible",
                    value: function(t) {
                        var e = t.start,
                            n = t.end;
                        return this.current > e && this.current < n
                    }
                }, {
                    key: "removeEvents",
                    value: function() {
                        k.off("tick", this.run), k.off("resize", this.resize)
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        this.removeEvents(), this.sections = this.elems = null, k.emit("scroll:on-reset")
                    }
                }]) && cc(e.prototype, n), i && cc(e, i), t
            }(),
            mc = __webpack_require__(862),
            gc = __webpack_require__.n(mc);

        function vc(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }
        new(function() {
            function t() {
                var e, n, i, r = this;
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), i = function(t) {
                    for (var e = function(e) {
                            var n = t[e];
                            if (n.isIntersecting) {
                                var i = r.cache.find((function(t) {
                                    return t.el === n.target
                                }));
                                i.intersecting = !0, i.tl.play(), r.observer.unobserve(n.target)
                            }
                        }, n = 0; n < t.length; n++) e(n)
                }, (n = "handle") in (e = this) ? Object.defineProperty(e, n, {
                    value: i,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[n] = i, this.el = f.dom.body, this.cache = null, this.observer = new IntersectionObserver(this.handle, {
                    root: null,
                    rootMargin: "0px 0px 10% 0px",
                    threshold: [0, 0]
                })
            }
            var e, n, i;
            return e = t, (n = [{
                key: "update",
                value: function(t) {
                    this.getElems(t), this.observe()
                }
            }, {
                key: "getElems",
                value: function(t) {
                    var e = this;
                    this.cache = null, this.cache = [];
                    var n = m("[data-scroll]", t);
                    n && n.forEach((function(t) {
                        t.getBoundingClientRect().top < f.bounds.wh || e.cache.push({
                            el: t,
                            intersecting: !1,
                            tl: e.getTimelines(t, t.dataset.scroll)
                        })
                    }))
                }
            }, {
                key: "getTimelines",
                value: function(t, e) {
                    var n = vr.timeline({
                        paused: !0,
                        immediateRender: !0
                    });
                    if ("words" === e) {
                        var i = new(gc())(t, {
                            type: "lines, words"
                        });
                        n.set(i.lines, {
                            overflow: "hidden"
                        }).from(i.words, {
                            yPercent: 100,
                            duration: 1.75,
                            stagger: .1,
                            ease: "expo"
                        }, 0)
                    }
                    return n.progress(1).progress(0), n
                }
            }, {
                key: "observe",
                value: function() {
                    var t = this;
                    this.cache.forEach((function(e) {
                        return t.observer.observe(e.el)
                    }))
                }
            }, {
                key: "clean",
                value: function() {
                    var t = this;
                    this.cache.forEach((function(e) {
                        return t.observer.unobserve(e.el)
                    }))
                }
            }, {
                key: "destroy",
                value: function() {
                    this.observer.disconnect(), this.observer = null, this.cache = null
                }
            }]) && vc(e.prototype, n), i && vc(e, i), t
        }());

        function yc(t) {
            return function(t) {
                if (Array.isArray(t)) return _c(t)
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
            }(t) || function(t, e) {
                if (!t) return;
                if ("string" == typeof t) return _c(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                "Object" === n && t.constructor && (n = t.constructor.name);
                if ("Map" === n || "Set" === n) return Array.from(t);
                if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _c(t, e)
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function _c(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
            return i
        }

        function xc(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function bc(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }
        var Ec = f.flags,
            wc = function() {
                function t() {
                    var e = this;
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), bc(this, "ui", {}), bc(this, "run", (function() {
                        var t = e.state,
                            n = t.target - t.current;
                        !t.dragging && Math.abs(n) <= .001 || (t.current += n * e.opts.ease, t.rounded = Math.round(100 * t.current) / 100, t.progress = t.rounded / t.max, !t.resizing && e.transform())
                    })), bc(this, "down", (function(t) {
                        var n = t.x,
                            i = t.y;
                        if (t.target.closest(".js-pricing-draggable")) {
                            var r = e.state;
                            Ec.dragging = !0, r.dragging = !0, r.cancel.x = n, r.cancel.y = i, r.on = r.target + n * e.opts.speed, !e.initial && e.removeCTA()
                        }
                    })), bc(this, "move", (function(t) {
                        var n = t.x,
                            i = t.y,
                            r = t.e,
                            a = e.state;
                        if (a.dragging) {
                            var s = a.cancel;
                            Math.abs(n - s.x) > Math.abs(i - s.y) && r.cancelable && (r.preventDefault(), r.stopPropagation()), a.target = a.on - n * e.opts.speed, e.clamp()
                        }
                    })), bc(this, "up", (function() {
                        Ec.dragging = !1, e.state.dragging = !1
                    })), bc(this, "click", (function(t) {
                        var n = t.target.closest(".js-pricing-bullet");
                        if (n) {
                            var i = e.state;
                            i.target = i.snap[e.ui.bullets.indexOf(n)]
                        }
                    })), bc(this, "resize", (function() {
                        var t = e.state;
                        t.resizing = !0, e.setBounds(), e.setScale(), e.clamp(), t.rounded = t.current = t.target, e.transform(), t.resizing = !1
                    })), this.el = d(".js-pricing"), this.ui.container = d(".js-pricing-slides"), this.ui.slides = yc(m(".js-pricing-slide")), this.ui.bullets = yc(m(".js-pricing-bullet")), this.ui.handle = d(".js-pricing-handle"), this.state = {
                        target: 0,
                        current: 0,
                        rounded: 0,
                        scale: 0,
                        on: 0,
                        max: 0,
                        cancel: {
                            x: 0,
                            y: 0
                        },
                        dragging: !1,
                        resizing: !1,
                        snap: null
                    }, this.opts = {
                        speed: 2,
                        ease: .085
                    }, this.init()
                }
                var e, n, i;
                return e = t, (n = [{
                    key: "init",
                    value: function() {
                        this.setBounds(), this.addEvents()
                    }
                }, {
                    key: "addEvents",
                    value: function() {
                        k.on("tick", this.run), k.on("mousedown", this.down), k.on("mouseup", this.up), k.on("mousemove", this.move), k.on("click", this.click), k.on("resize", this.resize)
                    }
                }, {
                    key: "setBounds",
                    value: function() {
                        var t = this,
                            e = this.ui,
                            n = e.slides,
                            i = e.container,
                            r = f.bounds.ww;
                        i.style.transform = "translate3d(0, 0, 0)";
                        var a = r - xh(i).right;
                        this.state.max = xh(n[n.length - 1]).right + a - r, this.state.snap = n.map((function(e, i) {
                            return t.state.max / (n.length - 1) * i
                        })), this.setScale()
                    }
                }, {
                    key: "setScale",
                    value: function() {
                        var t = this.ui.bullets,
                            e = this.state,
                            n = xh(t[t.length - 1]).left - xh(t[0]).left;
                        e.scale = e.max / n
                    }
                }, {
                    key: "transform",
                    value: function() {
                        var t = this.ui,
                            e = t.container,
                            n = t.handle,
                            i = this.state,
                            r = i.rounded,
                            a = i.scale;
                        e.style.transform = "translate3d(".concat(-r, "px, 0, 0)"), n.style.transform = "translate3d(".concat(r / a, "px, 0, 0)")
                    }
                }, {
                    key: "removeCTA",
                    value: function() {
                        this.initial = !0;
                        var t = m(".js-btn-next", this.el);
                        vr.to(t, {
                            alpha: 0,
                            duration: .35,
                            ease: "power1",
                            onComplete: function() {
                                return t.remove()
                            }
                        })
                    }
                }, {
                    key: "clamp",
                    value: function() {
                        var t = this.state;
                        t.target = vr.utils.clamp(0, t.max, t.target)
                    }
                }, {
                    key: "removeEvents",
                    value: function() {
                        k.off("tick", this.run), k.off("mousedown", this.down), k.off("mouseup", this.up), k.off("mousemove", this.move), k.off("resize", this.resize), k.off("click", this.click)
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        this.removeEvents(), this.state = null, this.opts = null, this.ui = null
                    }
                }]) && xc(e.prototype, n), i && xc(e, i), t
            }();

        function Dc(t) {
            return function(t) {
                if (Array.isArray(t)) return Sc(t)
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
            }(t) || function(t, e) {
                if (!t) return;
                if ("string" == typeof t) return Sc(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                "Object" === n && t.constructor && (n = t.constructor.name);
                if ("Map" === n || "Set" === n) return Array.from(t);
                if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Sc(t, e)
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function Sc(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
            return i
        }

        function Mc(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }

        function Tc(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function Ac(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }
        var Cc = f.bounds,
            Pc = function() {
                function t() {
                    var e = this,
                        n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m("[data-stick]");
                    Mc(this, t), Ac(this, "run", (function(t) {
                        var n = t.current;
                        e.current = n, !e.resizing && e.transformElems(n)
                    })), Ac(this, "resize", (function() {
                        e.resizing = !0, e.cache = null, e.getCache(), e.transformElems(), e.resizing = !1
                    })), this.elems = Dc(n), this.cache = null, this.resizing = !1, this.init()
                }
                var e, n, i;
                return e = t, (n = [{
                    key: "init",
                    value: function() {
                        this.getCache(), this.addEvents()
                    }
                }, {
                    key: "addEvents",
                    value: function() {
                        k.on("tick", this.run), k.on("resize:on-reset", this.resize)
                    }
                }, {
                    key: "transformElems",
                    value: function() {
                        var t = this,
                            e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.current;
                        this.cache && this.cache.forEach((function(n) {
                            var i = t.visible(n, e),
                                r = i.visible,
                                a = i.progress;
                            r || t.resizing ? (n.out && (n.out = !1), t.transform(n, e, a)) : n.out || (n.out = !0, t.transform(n, e, a))
                        }))
                    }
                }, {
                    key: "transform",
                    value: function(t, e, n) {
                        var i = t.els.node,
                            r = t.bounds,
                            a = r.start,
                            s = r.max,
                            o = r.min,
                            l = t.tl,
                            h = e - a,
                            u = vr.utils.clamp(o, s, h);
                        l && n && l.progress(n);
                        var c = d(".article-bottom-action");
                        c && (u > 0 && 0 === c.clientHeight && (c.style.height = "85px", c.style.opacity = "100%"), (0 === u && 0 !== c.clientHeight || u === s) && (c.style.opacity = "0", c.style.height = 0)), i.style.transform = "translate3d(0, ".concat(u, "px, 0)")
                    }
                }, {
                    key: "visible",
                    value: function(t, e) {
                        var n, i = t.duration,
                            r = i.start,
                            a = i.end,
                            s = e > r && e < a;
                        return t.tl && s && (n = vr.utils.clamp(0, 1, (e - r) / (a - r))), {
                            visible: s,
                            progress: n
                        }
                    }
                }, {
                    key: "getCache",
                    value: function() {
                        var t = this,
                            e = Cc.wh;
                        this.cache = this.elems.map((function(n) {
                            return t.base({
                                el: n
                            }, e)
                        }));
                        var n = m(".js-stick-talent"),
                            i = m(".js-stick-hiw");
                        n.length > 0 && this.addTalentText(), i.length > 0 && this.addHiw()
                    }
                }, {
                    key: "base",
                    value: function() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Cc.wh;
                        return function() {
                            var n = t.el,
                                i = {};
                            i.node = t.el, i.node.style.transform = "translate3d(0, 0, 0)", i.start = t.start || d("[data-stick-start]", n) || n.closest("[data-stick-start]"), i.end = t.end || d("[data-stick-end]", i.start) || n.closest("[data-stick-end]");
                            var r = {
                                    node: xh(n),
                                    start: xh(i.start),
                                    end: xh(i.end)
                                },
                                a = {
                                    start: r.start.top - e,
                                    end: r.end.bottom,
                                    height: r.node.height,
                                    progress: 0
                                },
                                s = 2 * (r.node.top - r.start.top),
                                o = e - r.node.height;
                            return {
                                els: i,
                                rects: r,
                                duration: a,
                                bounds: {
                                    start: r.start.top,
                                    max: r.start.bottom - r.start.top - e - s + o,
                                    min: 0
                                },
                                tl: null
                            }
                        }()
                    }
                }, {
                    key: "addTalentText",
                    value: function() {
                        var t = this.base({
                                el: d(".js-stick-talent"),
                                end: d(".js-stick-talent-end")
                            }),
                            e = t.bounds,
                            n = t.rects,
                            i = f.bounds.wh,
                            r = .5 * (i - n.node.height);
                        e.start = n.start.top - r, e.max = n.end.bottom - e.start - i + (i - n.end.height) / 2, t.tl = vr.timeline({
                            paused: !0,
                            defaults: {
                                ease: "linear",
                                duration: 1
                            }
                        }).fromTo(".js-tal-r", {
                            xPercent: 0,
                            alpha: 0
                        }, {
                            xPercent: -37.5,
                            alpha: 1
                        }), this.cache.push(t)
                    }
                }, {
                    key: "addHiw",
                    value: function() {
                        var t = this.base({
                                el: d(".js-stick-hiw"),
                                end: d(".js-stick-hiw-end")
                            }),
                            e = t.bounds,
                            n = t.rects,
                            i = .5 * (f.bounds.wh - n.node.height);
                        e.start = n.start.top - i, this.cache.push(t)
                    }
                }, {
                    key: "removeEvents",
                    value: function() {
                        k.off("tick", this.run), k.off("resize:on-reset", this.resize)
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        this.removeEvents(), this.cache = null
                    }
                }]) && Tc(e.prototype, n), i && Tc(e, i), t
            }();

        function Fc(t) {
            return function(t) {
                if (Array.isArray(t)) return Lc(t)
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
            }(t) || function(t, e) {
                if (!t) return;
                if ("string" == typeof t) return Lc(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                "Object" === n && t.constructor && (n = t.constructor.name);
                if ("Map" === n || "Set" === n) return Array.from(t);
                if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Lc(t, e)
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function Lc(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
            return i
        }

        function Rc(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }
        var Ic = f.flags.isDesktop,
            kc = function() {
                function t() {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.elems = [].concat(Fc(m(".js-bm")), Fc(m(Ic ? ".js-bm-d" : ".js-bm-m"))), this.slides = d(".js-hiw-slides"), this.last = null, this.init()
                }
                var e, n, i;
                return e = t, (n = [{
                    key: "init",
                    value: function() {
                        var t = this;
                        this.elems.forEach((function(e) {
                            return t.set(e)
                        }))
                    }
                }, {
                    key: "set",
                    value: function(t) {
                        var e = Gu().loadAnimation({
                            container: t,
                            renderer: "svg",
                            loop: !0,
                            autoplay: !1,
                            path: "/static/lottie/".concat(t.dataset.name, "/data.json")
                        });
                        e.setSubframe(!1), ku.cache.push({
                            el: t,
                            ani: e,
                            enter: function(t) {
                                Ic && (t.el.style.visibility = "visible"), t.ani.play()
                            },
                            leave: function(t) {
                                t.ani.stop(), Ic && (t.el.style.visibility = "hidden")
                            },
                            intersecting: !1
                        }), ku.inst.observe(t)
                    }
                }]) && Rc(e.prototype, n), i && Rc(e, i), t
            }();

        function Oc(t) {
            return function(t) {
                if (Array.isArray(t)) return Nc(t)
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
            }(t) || function(t, e) {
                if (!t) return;
                if ("string" == typeof t) return Nc(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                "Object" === n && t.constructor && (n = t.constructor.name);
                if ("Map" === n || "Set" === n) return Array.from(t);
                if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Nc(t, e)
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function Nc(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
            return i
        }

        function Bc(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function zc(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }
        var Vc = f.flags,
            Uc = f.bounds,
            Gc = function() {
                function t() {
                    var e = this;
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), zc(this, "ui", {}), zc(this, "run", (function() {
                        var t = e.state,
                            n = t.target - t.current;
                        !t.dragging && Math.abs(n) <= .001 || (t.current += n * e.opts.ease, t.rounded = Math.round(100 * t.current) / 100, t.progress = t.rounded / t.max, !t.resizing && e.transformSlides())
                    })), zc(this, "down", (function(t) {
                        var n = t.x,
                            i = t.y;
                        if (t.target.closest(".js-proof-draggable")) {
                            var r = e.state;
                            Vc.dragging = !0, r.dragging = !0, r.cancel.x = n, r.cancel.y = i, r.on = r.target + n * e.opts.speed, !e.initial && e.removeCTA()
                        }
                    })), zc(this, "move", (function(t) {
                        var n = t.x,
                            i = t.y,
                            r = t.e,
                            a = e.state;
                        if (a.dragging) {
                            var s = a.cancel;
                            Math.abs(n - s.x) > Math.abs(i - s.y) && r.cancelable && (r.preventDefault(), r.stopPropagation()), a.target = a.on - n * e.opts.speed, e.clamp()
                        }
                    })), zc(this, "up", (function() {
                        Vc.dragging = !1, e.state.dragging = !1
                    })), zc(this, "resize", (function() {
                        var t = e.state;
                        t.resizing = !0, e.setCache(), e.clamp(), t.rounded = t.current = t.target, e.transformSlides(), t.resizing = !1
                    })), this.el = d(".js-proof"), this.ui.container = d(".js-proof-slides"), this.ui.slides = Oc(m(".js-proof-slide")), this.state = {
                        target: 0,
                        current: 0,
                        rounded: 0,
                        on: 0,
                        max: 0,
                        cancel: {
                            x: 0,
                            y: 0
                        },
                        dragging: !1,
                        resizing: !1
                    }, this.opts = {
                        speed: 2,
                        ease: .085
                    }, this.init()
                }
                var e, n, i;
                return e = t, (n = [{
                    key: "init",
                    value: function() {
                        this.setCache(), this.addEvents()
                    }
                }, {
                    key: "addEvents",
                    value: function() {
                        k.on("tick", this.run), k.on("mousedown", this.down), k.on("mouseup", this.up), k.on("mousemove", this.move), k.on("resize", this.resize)
                    }
                }, {
                    key: "setCache",
                    value: function() {
                        var t = this,
                            e = this.ui,
                            n = e.slides,
                            i = e.container,
                            r = Uc.ww,
                            a = n.length - 1;
                        this.cache = n.map((function(e, n) {
                            e.style.transform = "translate3d(0, 0, 0)";
                            var s = xh(e),
                                o = s.left,
                                l = s.right;
                            return n === a && (t.state.max = l + (r - xh(i).right) - r), {
                                el: e,
                                start: o - r - 50,
                                end: l + 50,
                                out: !0
                            }
                        }))
                    }
                }, {
                    key: "transform",
                    value: function(t, e) {
                        t.style.transform = "translate3d(".concat(-e, "px, 0, 0)")
                    }
                }, {
                    key: "transformSlides",
                    value: function() {
                        var t = this,
                            e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.state.rounded;
                        this.cache.forEach((function(n) {
                            t.visible(n, e) || t.state.resizing ? (n.out && (n.out = !1, n.el.style.visibility = "visible"), t.transform(n.el, e)) : n.out || (n.out = !0, t.transform(n.el, e), n.el.style.visibility = "hidden")
                        }))
                    }
                }, {
                    key: "visible",
                    value: function(t, e) {
                        var n = t.start,
                            i = t.end;
                        return e > n && e < i
                    }
                }, {
                    key: "removeCTA",
                    value: function() {
                        this.initial = !0;
                        var t = d(".js-btn-next", this.el);
                        vr.to(t, {
                            alpha: 0,
                            duration: .35,
                            ease: "power1",
                            onComplete: function() {
                                return t.remove()
                            }
                        })
                    }
                }, {
                    key: "clamp",
                    value: function() {
                        var t = this.state;
                        t.target = vr.utils.clamp(0, t.max, t.target)
                    }
                }, {
                    key: "removeEvents",
                    value: function() {
                        k.off("tick", this.run), k.off("mousedown", this.down), k.off("mouseup", this.up), k.off("mousemove", this.move), k.off("resize", this.resize)
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        this.removeEvents(), this.state = null, this.opts = null, this.ui = null
                    }
                }]) && Bc(e.prototype, n), i && Bc(e, i), t
            }();

        function Hc(t, e) {
            var n = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
                var i = Object.getOwnPropertySymbols(t);
                e && (i = i.filter((function(e) {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                }))), n.push.apply(n, i)
            }
            return n
        }

        function jc(t) {
            for (var e = 1; e < arguments.length; e++) {
                var n = null != arguments[e] ? arguments[e] : {};
                e % 2 ? Hc(Object(n), !0).forEach((function(e) {
                    Zc(t, e, n[e])
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Hc(Object(n)).forEach((function(e) {
                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                }))
            }
            return t
        }

        function Wc(t) {
            return function(t) {
                if (Array.isArray(t)) return Xc(t)
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
            }(t) || function(t, e) {
                if (!t) return;
                if ("string" == typeof t) return Xc(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                "Object" === n && t.constructor && (n = t.constructor.name);
                if ("Map" === n || "Set" === n) return Array.from(t);
                if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Xc(t, e)
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function Xc(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
            return i
        }

        function qc(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }

        function Yc(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function Zc(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }
        var Jc = function() {
            function t() {
                var e = this,
                    n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m("[data-from]");
                qc(this, t), Zc(this, "run", (function(t) {
                    var n = t.current;
                    e.current = n, !e.resizing && e.playTimelines()
                })), Zc(this, "resize", (function() {
                    e.resizing = !0, e.cache = null, e.getCache(), e.playTimelines(), e.resizing = !1
                })), this.elems = Wc(n), this.current = 0, this.resizing = !1, this.init()
            }
            var e, n, i;
            return e = t, (n = [{
                key: "init",
                value: function() {
                    this.getCache(), this.addEvents()
                }
            }, {
                key: "addEvents",
                value: function() {
                    k.on("tick", this.run), k.on("resize:on-reset", this.resize)
                }
            }, {
                key: "playTimelines",
                value: function() {
                    var t = this,
                        e = f.bounds.wh;
                    this.cache.forEach((function(n) {
                        if (t.visible(n) || t.resizing) {
                            var i = n.rect,
                                r = i.top,
                                a = i.height,
                                s = n.tl,
                                o = vr.utils.clamp(0, 1, 1 - (-t.current + r + a) / (a + e));
                            s.progress(o)
                        }
                    }))
                }
            }, {
                key: "getCache",
                value: function() {
                    this.cache = this.elems.map((function(t) {
                        var e = JSON.parse(t.dataset.from),
                            n = JSON.parse(t.dataset.to),
                            i = vr.timeline({
                                paused: !0
                            }).fromTo(t, 1, e, jc(jc({}, n), {
                                ease: "linear"
                            }));
                        i.progress(1);
                        var r = t.getBoundingClientRect();
                        return i.progress(0), {
                            tl: i,
                            rect: r,
                            start: r.top - f.bounds.wh,
                            end: r.bottom
                        }
                    }))
                }
            }, {
                key: "visible",
                value: function(t) {
                    var e = t.start,
                        n = t.end;
                    return this.current > e && this.current < n
                }
            }, {
                key: "removeEvents",
                value: function() {
                    k.off("tick", this.run), k.off("resize:on-reset", this.resize)
                }
            }, {
                key: "destroy",
                value: function() {
                    this.removeEvents(), this.cache = this.elems = null
                }
            }]) && Yc(e.prototype, n), i && Yc(e, i), t
        }();

        function Kc(t) {
            return function(t) {
                if (Array.isArray(t)) return $c(t)
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
            }(t) || function(t, e) {
                if (!t) return;
                if ("string" == typeof t) return $c(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                "Object" === n && t.constructor && (n = t.constructor.name);
                if ("Map" === n || "Set" === n) return Array.from(t);
                if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return $c(t, e)
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function $c(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
            return i
        }

        function Qc(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function tp(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }
        vr.registerPlugin(ic);
        var ep = f.bounds,
            np = f.flags.isDevice,
            ip = function() {
                function t() {
                    var e = this;
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), tp(this, "ui", {}), tp(this, "addEvents", (function() {
                        k.on("tick", e.run), k.on("resize:on-reset", e.resize)
                    })), tp(this, "run", (function(t) {
                        var n = t.current;
                        (!e.state.resizing || n > e.bounds.max) && e.animate(n)
                    })), tp(this, "resize", (function() {
                        var t = e.state;
                        t.resizing = !0, e.setBounds(), e.setTlA(), e.setTlB(), e.animate(), t.resizing = !1
                    })), tp(this, "removeEvents", (function() {
                        k.off("tick", e.run), k.off("resize:on-reset", e.resize)
                    })), this.ui.texts = Kc(m(".js-h-txt")), this.ui.intro = d(".js-intro"), this.ui.introContent = d(".js-intro-content"), this.state = {
                        progress: {
                            a: 0,
                            b: 0
                        },
                        resizing: !1
                    }, this.tl = {
                        a: null,
                        b: null
                    }, this.init()
                }
                var e, n, i;
                return e = t, (n = [{
                    key: "init",
                    value: function() {
                        this.cacheTexts(), this.setBounds(), this.setLottie(), this.setTlA(), this.setTlB(), this.addEvents()
                    }
                }, {
                    key: "setBounds",
                    value: function() {
                        var t = this.ui,
                            e = t.intro,
                            n = t.introContent,
                            i = np ? _u.target : 0,
                            r = xh(n).top + i,
                            a = xh(e).top + i,
                            s = r - .5 * ep.wh - a,
                            o = r;
                        this.bounds = {
                            start: a,
                            end: s,
                            max: o
                        }
                    }
                }, {
                    key: "cacheTexts",
                    value: function() {
                        this.texts = this.ui.texts.map((function(t, e) {
                            var n = m(".js-h-txt__l", t),
                                i = vr.timeline({
                                    paused: !0
                                }),
                                r = .25 * e,
                                a = .25 * (e + 1),
                                s = [m(".js-h-uline", t), m(".js-h-uline span", t)];
                            return 0 !== e && vr.set(n, {
                                yPercent: 100
                            }), 1 === e ? {
                                i: e,
                                el: t,
                                lines: n,
                                uline: s,
                                tl: i,
                                p1: r,
                                p2: a,
                                p1T: !1,
                                p2T: !1
                            } : 2 === e ? {
                                i: e,
                                el: t,
                                lines: n,
                                uline: s,
                                tl: i,
                                p1: r,
                                p1T: !1
                            } : {
                                i: e,
                                el: t,
                                lines: n,
                                uline: s,
                                tl: i,
                                p2: a,
                                p2T: !1
                            }
                        }))
                    }
                }, {
                    key: "setLottie",
                    value: function() {
                        this.icon = Gu().loadAnimation({
                            container: d(".js-h-progress"),
                            loop: !1,
                            autoplay: !1,
                            path: "/static/lottie/progress/data.json"
                        })
                    }
                }, {
                    key: "setTlA",
                    value: function() {
                        var t = this,
                            e = {
                                progress: 0
                            };
                        this.tl.a && this.tl.a.kill(), this.tl.a = vr.timeline({
                            paused: !0,
                            defaults: {
                                ease: "linear"
                            }
                        }).fromTo(".js-h-circle path", {
                            drawSVG: 0
                        }, {
                            drawSVG: "100%",
                            duration: .8,
                            ease: "power1.inOut"
                        }, 0).to(e, {
                            progress: 1,
                            duration: 1,
                            onUpdate: function() {
                                t.icon.goToAndStop(e.progress * t.icon.getDuration(!1) * 1e3, !1)
                            }
                        }, 0)
                    }
                }, {
                    key: "setTlB",
                    value: function() {
                        var t = this,
                            e = {
                                progress: 1
                            };
                        !this.state.resizing && (this.planes = pu.slides.children.filter((function(t) {
                            return t.name.includes("slide")
                        }))), this.tl.b && this.tl.b.kill(), this.tl.b = vr.timeline({
                            paused: !0,
                            defaults: {
                                ease: "linear"
                            }
                        }).fromTo(".js-intro__bg", {
                            alpha: 0
                        }, {
                            alpha: 1,
                            duration: .25,
                            ease: "linear"
                        }, 0).fromTo([".js-h-logo, .js-h-play-icon"], {
                            alpha: 1
                        }, {
                            alpha: 0,
                            duration: .25,
                            ease: "linear"
                        }, 0).to(e, {
                            progress: 0,
                            duration: 1,
                            onUpdate: function() {
                                t.togglePlanes(e.progress)
                            }
                        }, 0).fromTo(".js-h-txt--last", {
                            alpha: 1
                        }, {
                            alpha: 0,
                            duration: .9
                        }, 0)
                    }
                }, {
                    key: "animate",
                    value: function() {
                        var t = this,
                            e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _u.target,
                            n = this.state.progress,
                            i = this.bounds,
                            r = i.start,
                            a = i.end;
                        n.a = vr.utils.clamp(0, 1, e / r), n.b = vr.utils.clamp(0, 1, (e - r) / a), this.texts.forEach((function(e) {
                            return t.toggleTexts(e, n.a)
                        })), this.tl.a.progress(n.a), this.tl.b.progress(n.b)
                    }
                }, {
                    key: "togglePlanes",
                    value: function(t) {
                        this.planes.forEach((function(e) {
                            return e.material.uniforms.uAlpha.value = t
                        }))
                    }
                }, {
                    key: "toggleTexts",
                    value: function(t, e) {
                        t.p1 && this.toggleP1(t, e), this.toggleP2(t, e)
                    }
                }, {
                    key: "toggleP1",
                    value: function(t, e) {
                        e > t.p1 && !t.p1T ? (t.p1T = !0, t.tl.clear().set(t.uline, {
                            alpha: 1
                        }).fromTo(t.lines, {
                            yPercent: 100
                        }, {
                            yPercent: 0,
                            duration: 1.1,
                            stagger: .075,
                            ease: "expo"
                        }, .35).fromTo(t.uline, {
                            xPercent: vr.utils.wrap([-100, 100])
                        }, {
                            xPercent: 0,
                            duration: 1,
                            ease: "expo.inOut"
                        }, .45).play()) : e <= t.p1 && t.p1T && (t.p1T = !1, t.tl.clear().to(t.lines, {
                            yPercent: -100,
                            duration: .5,
                            stagger: .075,
                            ease: "power2.inOut"
                        }).to(t.uline, {
                            xPercent: vr.utils.wrap([100, -100]),
                            duration: .5,
                            ease: "expo.inOut"
                        }, 0).play())
                    }
                }, {
                    key: "toggleP2",
                    value: function(t, e) {
                        e > t.p2 && !t.p2T ? (t.p2T = !0, t.tl.clear().to(t.lines, {
                            yPercent: -100,
                            duration: .5,
                            stagger: .075,
                            ease: "power2.inOut"
                        }).to(t.uline, {
                            xPercent: vr.utils.wrap([100, -100]),
                            duration: .5,
                            ease: "expo.inOut"
                        }, 0).play()) : e <= t.p2 && t.p2T && (t.p2T = !1, t.tl.clear().set(t.uline, {
                            alpha: 1
                        }).fromTo(t.lines, {
                            yPercent: 100
                        }, {
                            yPercent: 0,
                            duration: 1.1,
                            stagger: .075,
                            ease: "expo"
                        }, .35).fromTo(t.uline, {
                            xPercent: vr.utils.wrap([-100, 100])
                        }, {
                            xPercent: 0,
                            duration: 1,
                            ease: "expo.inOut"
                        }, .45).play())
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        this.removeEvents(), this.planes = null, this.tl.a.kill(), this.tl.b.kill(), this.state = null, this.texts = null
                    }
                }]) && Qc(e.prototype, n), i && Qc(e, i), t
            }();

        function rp(t) {
            return function(t) {
                if (Array.isArray(t)) return ap(t)
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
            }(t) || function(t, e) {
                if (!t) return;
                if ("string" == typeof t) return ap(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                "Object" === n && t.constructor && (n = t.constructor.name);
                if ("Map" === n || "Set" === n) return Array.from(t);
                if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ap(t, e)
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function ap(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
            return i
        }

        function sp(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function op(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }
        var lp, hp, up, cp, pp, fp, dp, mp = f.bounds,
            gp = f.flags,
            vp = function() {
                function t() {
                    var e = this;
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), op(this, "ui", {}), op(this, "run", (function() {
                        var t = e.state,
                            n = t.target,
                            i = n.x,
                            r = n.scale,
                            a = t.current,
                            s = t.resize,
                            o = i - a.x;
                        Math.abs(o) <= .001 || (a.x += .1 * o, a.scale += .1 * (r - a.scale), !s && e.transformLine(a.x, a.scale))
                    })), op(this, "handle", (function(t) {
                        t.forEach((function(t) {
                            var n = e.cache && e.cache.menu.find((function(e) {
                                return e.elem === t.target
                            }));
                            if (n) {
                                var i = n.el,
                                    r = n.i,
                                    a = n.x,
                                    s = n.scaleX;
                                if (t.isIntersecting) {
                                    var o = e.state;
                                    o.last && o.last.classList.remove("is-active"), o.i = r, e.line(a, s), i.classList.add("is-active"), o.last = i
                                }
                            } else {
                                var l = e.cache.hiw.find((function(e) {
                                    return e.elem === t.target
                                })).el;
                                if (t.isIntersecting) {
                                    var h = e.state.hiw;
                                    h.last && h.last.classList.remove("is-active"), l.classList.add("is-active"), h.last = l
                                }
                            }
                        }))
                    })), op(this, "anchorScroll", (function() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                        t && t.preventDefault();
                        var n = e.cache.elems[e.ui.elems.indexOf(t.currentTarget)];
                        vr.to(_u, {
                            target: n,
                            duration: 1.5,
                            ease: "power3.inOut"
                        })
                    })), op(this, "arrowScroll", (function(t) {
                        var n = t.currentTarget,
                            i = e.ui.arrows.indexOf(n),
                            r = vr.utils.clamp(0, mp.scroll, e.cache.arrows[i]);
                        vr.to(_u, {
                            target: r,
                            duration: 1,
                            ease: "power3.inOut"
                        })
                    })), op(this, "resize", (function() {
                        var t = e.state;
                        t.resize = !0, e.setElemCache(), e.setArrowCache(), e.updateMenuCache(), t.resize = !1
                    })), this.ui.elems = rp(m("[data-anchor]")), this.ui.menuElems = this.ui.elems.filter((function(t) {
                        return t.classList.contains("js-sm-link")
                    })), this.ui.hiwElems = this.ui.elems.filter((function(t) {
                        return t.classList.contains("js-hiw-link")
                    })), this.ui.arrows = rp(m(".js-s-arrow")), this.ui.line = d(".js-sh-line"), this.state = {
                        last: null,
                        target: {
                            scale: 0,
                            x: 0
                        },
                        current: {
                            scale: 0,
                            x: 0
                        },
                        hiw: {
                            last: 0
                        },
                        i: 0
                    }, this.cache = {
                        elems: null,
                        arrows: null,
                        menu: null,
                        hiw: null
                    }, this.o = new IntersectionObserver(this.handle, {
                        root: null,
                        rootMargin: "-25% 0px -25% 0px",
                        threshold: [0, 0]
                    }), this.init()
                }
                var e, n, i;
                return e = t, (n = [{
                    key: "init",
                    value: function() {
                        this.setElemCache(), this.setArrowCache(), this.setMenuCache(), this.setHiwCache(), this.addEvents()
                    }
                }, {
                    key: "addEvents",
                    value: function() {
                        var t = this.ui,
                            e = t.elems,
                            n = t.arrows;
                        k.on("tick", this.run), k.on("resize:on-reset", this.resize), e.length && k.on("click", e, this.anchorScroll), n.length && k.on("click", n, this.arrowScroll)
                    }
                }, {
                    key: "setElemCache",
                    value: function() {
                        var t = mp.ww;
                        this.cache.elems = this.ui.elems.map((function(e) {
                            var n = d("".concat(e.dataset.anchor)),
                                i = t * (n.dataset.offset || .1);
                            return xh(n).top - i
                        }))
                    }
                }, {
                    key: "setArrowCache",
                    value: function() {
                        var t = mp.ww,
                            e = this.ui.arrows;
                        e.length && (this.cache.arrows = e.map((function(n, i) {
                            return i >= e.length - 2 ? 0 : xh(e[i + 1]).top - .1 * t
                        })))
                    }
                }, {
                    key: "setMenuCache",
                    value: function() {
                        var t = this,
                            e = this.ui,
                            n = e.menuElems,
                            i = e.line;
                        if (n.length) {
                            var r = xh(i).width;
                            this.cache.menu = n.map((function(e, n) {
                                var a = d("".concat(e.dataset.anchor)),
                                    s = e.offsetLeft,
                                    o = e.offsetWidth / r;
                                return 0 === n && (gp.initial ? vr.timeline().set(i, {
                                    alpha: 1
                                }).fromTo(i, {
                                    scaleX: 0,
                                    x: 0
                                }, {
                                    scaleX: o,
                                    x: s,
                                    duration: .75,
                                    ease: "power3.inOut"
                                }) : vr.set(i, {
                                    alpha: 1,
                                    scaleX: o,
                                    x: s
                                })), t.o.observe(a), {
                                    el: e,
                                    elem: a,
                                    i: n,
                                    x: s,
                                    scaleX: o
                                }
                            }))
                        }
                    }
                }, {
                    key: "setHiwCache",
                    value: function() {
                        var t = this,
                            e = this.ui.hiwElems;
                        e.length && (this.cache.hiw = e.map((function(e) {
                            var n = d("".concat(e.dataset.anchor));
                            return t.o.observe(n), {
                                el: e,
                                elem: n
                            }
                        })))
                    }
                }, {
                    key: "updateMenuCache",
                    value: function() {
                        var t = this.cache.menu;
                        if (t) {
                            this.transformLine(0, 1);
                            var e = xh(this.ui.line).width;
                            t.forEach((function(t) {
                                t.x = t.el.offsetLeft, t.scaleX = t.el.offsetWidth / e
                            })), this.line(), this.transformLine()
                        }
                    }
                }, {
                    key: "transformLine",
                    value: function() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.state.current.x,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state.current.scale,
                            n = this.ui.line;
                        n && (n.style.transform = "translate3d(".concat(t, "px, 0, 0) scaleX(").concat(e, ")"))
                    }
                }, {
                    key: "line",
                    value: function() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.cache.menu[this.state.i].x,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.cache.menu[this.state.i].scaleX,
                            n = this.state.target;
                        n.scale = e, n.x = t
                    }
                }, {
                    key: "removeEvents",
                    value: function() {
                        var t = this.ui,
                            e = t.elems,
                            n = t.arrows;
                        e.length && k.off("click", e, this.anchorScroll), n.length && k.off("click", n, this.arrowScroll), k.off("resize:on-reset", this.resize)
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        this.removeEvents(), this.cache = null, this.ui = null
                    }
                }]) && sp(e.prototype, n), i && sp(e, i), t
            }(),
            yp = function() {
                return "undefined" != typeof window
            },
            _p = function() {
                return lp || yp() && (lp = window.gsap) && lp.registerPlugin && lp
            },
            xp = function(t) {
                return "string" == typeof t
            },
            bp = function(t, e) {
                var n = "x" === e ? "Width" : "Height",
                    i = "scroll" + n,
                    r = "client" + n;
                return t === up || t === cp || t === pp ? Math.max(cp[i], pp[i]) - (up["inner" + n] || cp[r] || pp[r]) : t[i] - t["offset" + n]
            },
            Ep = function(t, e) {
                var n = "scroll" + ("x" === e ? "Left" : "Top");
                return t === up && (null != t.pageXOffset ? n = "page" + e.toUpperCase() + "Offset" : t = null != cp[n] ? cp : pp),
                    function() {
                        return t[n]
                    }
            },
            wp = function(t, e) {
                var n = fp(t)[0].getBoundingClientRect(),
                    i = !e || e === up || e === pp,
                    r = i ? {
                        top: cp.clientTop - (up.pageYOffset || cp.scrollTop || pp.scrollTop || 0),
                        left: cp.clientLeft - (up.pageXOffset || cp.scrollLeft || pp.scrollLeft || 0)
                    } : e.getBoundingClientRect(),
                    a = {
                        x: n.left - r.left,
                        y: n.top - r.top
                    };
                return !i && e && (a.x += Ep(e, "x")(), a.y += Ep(e, "y")()), a
            },
            Dp = function(t, e, n, i, r) {
                return isNaN(t) || "object" == typeof t ? xp(t) && "=" === t.charAt(1) ? parseFloat(t.substr(2)) * ("-" === t.charAt(0) ? -1 : 1) + i - r : "max" === t ? bp(e, n) - r : Math.min(bp(e, n), wp(t, e)[n] - r) : parseFloat(t) - r
            },
            Sp = function() {
                lp = _p(), yp() && lp && document.body && (up = window, pp = document.body, cp = document.documentElement, fp = lp.utils.toArray, lp.config({
                    autoKillThreshold: 7
                }), dp = lp.config(), hp = 1)
            },
            Mp = {
                version: "3.5.1",
                name: "scrollTo",
                rawVars: 1,
                register: function(t) {
                    lp = t, Sp()
                },
                init: function(t, e, n, i, r) {
                    hp || Sp();
                    this.isWin = t === up, this.target = t, this.tween = n, "object" != typeof e ? xp((e = {
                        y: e
                    }).y) && "max" !== e.y && "=" !== e.y.charAt(1) && (e.x = e.y) : e.nodeType && (e = {
                        y: e,
                        x: e
                    }), this.vars = e, this.autoKill = !!e.autoKill, this.getX = Ep(t, "x"), this.getY = Ep(t, "y"), this.x = this.xPrev = this.getX(), this.y = this.yPrev = this.getY(), null != e.x ? (this.add(this, "x", this.x, Dp(e.x, t, "x", this.x, e.offsetX || 0), i, r, Math.round), this._props.push("scrollTo_x")) : this.skipX = 1, null != e.y ? (this.add(this, "y", this.y, Dp(e.y, t, "y", this.y, e.offsetY || 0), i, r, Math.round), this._props.push("scrollTo_y")) : this.skipY = 1
                },
                render: function(t, e) {
                    for (var n, i, r, a, s, o = e._pt, l = e.target, h = e.tween, u = e.autoKill, c = e.xPrev, p = e.yPrev, f = e.isWin; o;) o.r(t, o.d), o = o._next;
                    n = f || !e.skipX ? e.getX() : c, r = (i = f || !e.skipY ? e.getY() : p) - p, a = n - c, s = dp.autoKillThreshold, e.x < 0 && (e.x = 0), e.y < 0 && (e.y = 0), u && (!e.skipX && (a > s || a < -s) && n < bp(l, "x") && (e.skipX = 1), !e.skipY && (r > s || r < -s) && i < bp(l, "y") && (e.skipY = 1), e.skipX && e.skipY && (h.kill(), e.vars.onAutoKill && e.vars.onAutoKill.apply(h, e.vars.onAutoKillParams || []))), f ? up.scrollTo(e.skipX ? n : e.x, e.skipY ? i : e.y) : (e.skipY || (l.scrollTop = e.y), e.skipX || (l.scrollLeft = e.x)), e.xPrev = e.x, e.yPrev = e.y
                },
                kill: function(t) {
                    var e = "scrollTo" === t;
                    (e || "scrollTo_x" === t) && (this.skipX = 1), (e || "scrollTo_y" === t) && (this.skipY = 1)
                }
            };

        function Tp(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }

        function Ap(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function Cp(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }
        Mp.max = bp, Mp.getOffset = wp, Mp.buildGetter = Ep, _p() && lp.registerPlugin(Mp), vr.registerPlugin(Mp);
        var Pp = f.dom.scroll,
            Fp = function() {
                function t() {
                    var e = this,
                        n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m("[data-anchor]");
                    Tp(this, t), Cp(this, "animate", (function(t) {
                        var n = t.currentTarget;
                        e.tl.clear().to(Pp, {
                            scrollTo: {
                                y: "".concat(n.dataset.anchor),
                                offsetY: 200
                            },
                            duration: 1.5,
                            ease: "power3.inOut"
                        }).play()
                    })), this.elems = n, this.tl = vr.timeline({
                        paused: !0
                    }), k.on("click", this.elems, this.animate)
                }
                var e, n, i;
                return e = t, (n = [{
                    key: "destroy",
                    value: function() {
                        k.off("click", this.elems, this.animate), this.tl.kill()
                    }
                }]) && Ap(e.prototype, n), i && Ap(e, i), t
            }();

        function Lp(t) {
            return function(t) {
                if (Array.isArray(t)) return Rp(t)
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
            }(t) || function(t, e) {
                if (!t) return;
                if ("string" == typeof t) return Rp(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                "Object" === n && t.constructor && (n = t.constructor.name);
                if ("Map" === n || "Set" === n) return Array.from(t);
                if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Rp(t, e)
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function Rp(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
            return i
        }

        function Ip(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function kp(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }
        var Op = f.flags,
            Np = function() {
                function t() {
                    var e = this;
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), kp(this, "ui", {}), kp(this, "click", (function(t) {
                        var n = t.target;
                        if (t.click) {
                            var i = n.closest("[data-v-src]");
                            i && e.open(i.dataset.vSrc)
                        }
                    })), kp(this, "enter", (function(t) {
                        var n = t.currentTarget;
                        e.cache[e.ui.elems.indexOf(n)].a.goToAndPlay(1)
                    })), kp(this, "close", (function() {
                        e.state.open = !1;
                        var t = e.ui,
                            n = t.vm,
                            i = t.vid;
                        e.tl.clear().to(n, {
                            autoAlpha: 0,
                            duration: .35,
                            ease: "power1"
                        }).add((function() {
                            return i.pause()
                        })).play(), Op.locked = !1, n.classList.remove("is-open")
                    })), this.ui.elems = Lp(m("[data-v-src]")), this.ui.vm = d(".js-vm"), this.ui.vid = d(".js-vm-vid"), this.tl = vr.timeline({
                        paused: !0
                    }), this.state = {
                        open: !1
                    }, this.init()
                }
                var e, n, i;
                return e = t, (n = [{
                    key: "init",
                    value: function() {
                        this.setCache(), this.addEvents()
                    }
                }, {
                    key: "addEvents",
                    value: function() {
                        k.on("click", ".js-vm-close", this.close), k.on("mouseup", this.click), Op.hover && k.on("mouseenter", this.ui.elems, this.enter)
                    }
                }, {
                    key: "setCache",
                    value: function() {
                        this.cache = this.ui.elems.map((function(t) {
                            var e = Gu().loadAnimation({
                                container: t,
                                renderer: "svg",
                                loop: !1,
                                autoplay: !1,
                                path: "/static/lottie/play/data.json"
                            });
                            return e.setSubframe(!1), {
                                a: e
                            }
                        }))
                    }
                }, {
                    key: "open",
                    value: function(t) {
                        var e = this.state;
                        if (!e.open) {
                            e.open = !0;
                            var n = this.ui,
                                i = n.vm,
                                r = n.vid;
                            t !== r.src && (r.src = t), r.play(), this.tl.clear().to(i, {
                                autoAlpha: 1,
                                duration: .35,
                                ease: "power1"
                            }).add((function() {
                                Op.locked = !0
                            })).play(), i.classList.add("is-open")
                        }
                    }
                }]) && Ip(e.prototype, n), i && Ip(e, i), t
            }();

        function Bp(t) {
            return function(t) {
                if (Array.isArray(t)) return zp(t)
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
            }(t) || function(t, e) {
                if (!t) return;
                if ("string" == typeof t) return zp(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                "Object" === n && t.constructor && (n = t.constructor.name);
                if ("Map" === n || "Set" === n) return Array.from(t);
                if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return zp(t, e)
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function zp(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
            return i
        }

        function Vp(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }

        function Up(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }
        var Gp = f.flags.isDevice,
            Hp = function() {
                function t() {
                    var e = this,
                        n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m("[data-lazy-src]");
                    Vp(this, t), this.elems = n, Gp && (this.elems = [].concat(Bp(this.elems), Bp(m("[data-lazy-src-m]")))), this.elems.forEach((function(t) {
                        return e.set(t)
                    })), this.load()
                }
                var e, n, i;
                return e = t, (n = [{
                    key: "load",
                    value: function() {
                        var t = m("[data-lazy-load]");
                        t && t.forEach((function(t) {
                            return t.src = t.dataset.lazyLoad
                        }))
                    }
                }, {
                    key: "set",
                    value: function() {
                        this.elems.forEach((function(t) {
                            ku.cache.push({
                                el: t,
                                enter: function(e, n) {
                                    var i = e.e,
                                        r = void 0 === i ? t : i,
                                        a = "IMG" === t.nodeName,
                                        s = r.dataset.lazySrc || r.dataset.lazySrcM,
                                        o = new Image;
                                    o.src = s, o.decode().then((function() {
                                        a ? r.src = s : r.appendChild(o), r.classList.add("is-animated")
                                    })), ku.inst.unobserve(n)
                                }
                            }), ku.inst.observe(t)
                        }))
                    }
                }]) && Up(e.prototype, n), i && Up(e, i), t
            }();

        function jp(t) {
            return function(t) {
                if (Array.isArray(t)) return Wp(t)
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
            }(t) || function(t, e) {
                if (!t) return;
                if ("string" == typeof t) return Wp(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                "Object" === n && t.constructor && (n = t.constructor.name);
                if ("Map" === n || "Set" === n) return Array.from(t);
                if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Wp(t, e)
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function Wp(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
            return i
        }

        function Xp(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function qp(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }
        var Yp = f.bounds,
            Zp = function() {
                function t() {
                    var e = this;
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), qp(this, "run", (function(t) {
                        var n = t.current;
                        if (!t.still) {
                            var i = e.i,
                                r = e.visible(n);
                            r ? (!e.initial && e.setInitial(), i.last = i.current, i.current = Math.round(vr.utils.clamp(0, 1, (n - e.min) / e.max) * e.total), i.last !== i.current && e.check()) : r || e.out || i.current !== e.total || (e.out = !0, e.cache[e.total].ani.stop())
                        }
                    })), qp(this, "resize", (function() {
                        e.cache.forEach((function(t, n) {
                            return e.setBounds(n, t.el)
                        }))
                    })), this.container = d(".js-hiw-slides"), this.slides = jp(m(".js-hiw-slide")), this.current = 0, this.total = this.slides.length - 1, this.z = this.total + 1, this.i = {
                        last: 0,
                        curent: 0
                    }, this.initial = !1, this.init()
                }
                var e, n, i;
                return e = t, (n = [{
                    key: "init",
                    value: function() {
                        this.setCache(), this.addEvents()
                    }
                }, {
                    key: "addEvents",
                    value: function() {
                        k.on("tick", this.run), k.on("resize:on-reset", this.resize)
                    }
                }, {
                    key: "check",
                    value: function() {
                        var t = this.cache[this.i.last],
                            e = this.cache[this.i.current],
                            n = e.inner,
                            i = e.ani;
                        t && t.ani.stop(), this.z += 1, this.container.appendChild(n), this.tl(n, t), i.play()
                    }
                }, {
                    key: "setInitial",
                    value: function() {
                        this.initial = !0;
                        var t = this.cache[0],
                            e = t.ani,
                            n = t.inner;
                        e.play(), vr.set(n, {
                            alpha: 1
                        })
                    }
                }, {
                    key: "tl",
                    value: function(t, e) {
                        return vr.timeline({
                            onComplete: function() {
                                return e && e.inner.remove()
                            }
                        }).set(t, {
                            zIndex: this.z
                        }).fromTo(t, {
                            alpha: 0
                        }, {
                            alpha: 1,
                            duration: .25,
                            ease: "power1"
                        })
                    }
                }, {
                    key: "visible",
                    value: function() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.current;
                        return t > this.start && t < this.end
                    }
                }, {
                    key: "setCache",
                    value: function() {
                        var t = this;
                        this.cache = this.slides.map((function(e, n) {
                            var i = d("[data-name]", e),
                                r = Gu().loadAnimation({
                                    container: i,
                                    renderer: "svg",
                                    loop: !0,
                                    autoplay: !1,
                                    path: "/static/lottie/".concat(i.dataset.name, "/data.json")
                                });
                            return r.setSubframe(!1), t.setBounds(n, e), i.remove(), t.container.appendChild(i), vr.set(i, {
                                alpha: 0
                            }), {
                                inner: i,
                                el: e,
                                ani: r
                            }
                        }))
                    }
                }, {
                    key: "setBounds",
                    value: function(t, e) {
                        if (0 === t || t === this.total) {
                            var n = Yp.wh,
                                i = .25 * n,
                                r = xh(e),
                                a = r.top,
                                s = r.bottom;
                            0 === t && (this.start = a - n, this.min = a - i), t === this.total && (this.end = s, this.max = a - i - this.min)
                        }
                    }
                }, {
                    key: "removeEvents",
                    value: function() {
                        k.off("tick", this.run), k.off("resize:on-reset", this.resize)
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        this.removeEvents(), this.cache.forEach((function(t) {
                            return t.ani.destroy()
                        })), this.cache = this.i = null
                    }
                }]) && Xp(e.prototype, n), i && Xp(e, i), t
            }();

        function Jp(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }
        var Kp = function() {
            function t(e) {
                var n, i, r, a = this;
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), r = function(t) {
                    t && t.preventDefault(), document.MC_callback = function(t) {
                        "success" == t.result ? a.msg.textContent = "Thank you! We’ll be in touch soon." : a.msg.textContent = "Hmm, something's not working. Do you have another email address we can try?"
                    }, a.appendScript()
                }, (i = "submit") in (n = this) ? Object.defineProperty(n, i, {
                    value: r,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : n[i] = r, this.el = e, this.form = d("form", this.el), this.action = this.form.getAttribute("action"), this.inputs = {
                    email: d(".js-mc-email", this.form),
                    name: d(".js-mc-name", this.form),
                    proposal: d(".js-mc-proposal", this.form)
                }, this.msg = d(".js-mc-msg", this.form), this.addEvents()
            }
            var e, n, i;
            return e = t, (n = [{
                key: "addEvents",
                value: function() {
                    k.on("submit", this.el, this.submit)
                }
            }, {
                key: "appendScript",
                value: function() {
                    dataLayer.push({
                        event: "email capture form submit",
                        action: "send user details to Mail Chimp"
                    });
                    var t = d(".js-mc-script");
                    t && t.remove();
                    var e = this.inputs,
                        n = e.email,
                        i = e.name,
                        r = e.proposal,
                        a = document.createElement("script");
                    a.type = "text/javascript", a.classList.add("js-mc-script"), a.src = "".concat(this.action, "&c=document.MC_callback&EMAIL=").concat(n.value, "&NAME=").concat(i.value, "&PROPOSAL=").concat(r.value), d("head").appendChild(a)
                }
            }, {
                key: "destroy",
                value: function() {
                    k.off("submit", this.el, this.submit)
                }
            }]) && Jp(e.prototype, n), i && Jp(e, i), t
        }();

        function $p(t) {
            return ($p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function Qp(t) {
            return function(t) {
                if (Array.isArray(t)) return tf(t)
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
            }(t) || function(t, e) {
                if (!t) return;
                if ("string" == typeof t) return tf(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                "Object" === n && t.constructor && (n = t.constructor.name);
                if ("Map" === n || "Set" === n) return Array.from(t);
                if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return tf(t, e)
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function tf(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
            return i
        }

        function ef(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }

        function nf(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function rf(t, e) {
            return (rf = Object.setPrototypeOf || function(t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function af(t) {
            var e = function() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
                } catch (t) {
                    return !1
                }
            }();
            return function() {
                var n, i = of (t);
                if (e) {
                    var r = of (this).constructor;
                    n = Reflect.construct(i, arguments, r)
                } else n = i.apply(this, arguments);
                return sf(this, n)
            }
        }

        function sf(t, e) {
            return !e || "object" !== $p(e) && "function" != typeof e ? function(t) {
                if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t
            }(t) : e
        }

        function of (t) {
            return ( of = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            })(t)
        }
        var lf = f.flags,
            hf = f.dom,
            uf = lf.isDevice,
            cf = lf.isDesktop,
            pf = function(t) {
                ! function(t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            writable: !0,
                            configurable: !0
                        }
                    }), e && rf(t, e)
                }(a, t);
                var e, n, i, r = af(a);

                function a() {
                    return ef(this, a), r.apply(this, arguments)
                }
                return e = a, (n = [{
                    key: "initial",
                    value: function() {
                        var t = this;
                        new oc, f.addClasses(), this.onEnter(), window.onload = function() {
                            return t.loaded()
                        }
                    }
                }, {
                    key: "onEnter",
                    value: function() {
                        hf.scroll.scrollTop = 0, this.el = this.wrap.lastElementChild
                    }
                }, {
                    key: "onLeave",
                    value: function() {
                        this.scrollTo && this.scrollTo.destroy(), this.forms && this.forms.forEach((function(t) {
                            return t.destroy()
                        })), this.stickies && this.stickies.destroy(), this.pricing && this.pricing.destroy()
                    }
                }, {
                    key: "onEnterCompleted",
                    value: function() {
                        this.handleVm(), this.handleSmoothScroll(), this.handleLazy(), this.handleScrollTo(), this.handleMC(), this.sticky(), this.handlePricing(), this.lottieScroll = new kc, this.parallax = new Jc
                    }
                }, {
                    key: "onLeaveCompleted",
                    value: function() {
                        this.smoothScroll && this.smoothScroll.destroy(), k.emit("on-leave-completed")
                    }
                }, {
                    key: "handleSmoothScroll",
                    value: function() {
                        if (!uf) {
                            var t = m("[data-smooth-item]");
                            t.length > 0 && (this.smoothScroll = new dc(t))
                        }
                    }
                }, {
                    key: "handleScrollTo",
                    value: function() {
                        if (cf) this.scrollTo = new vp;
                        else {
                            var t = m("[data-anchor]");
                            t.length && (this.scrollTo = new Fp(t))
                        }
                    }
                }, {
                    key: "handleVm",
                    value: function() {
                        this.vm = new Np
                    }
                }, {
                    key: "handleLazy",
                    value: function() {
                        var t = m("[data-lazy-src]");
                        t.length > 0 && (this.lazy = new Hp(t))
                    }
                }, {
                    key: "handleMC",
                    value: function() {
                        var t = m(".js-mc-form", this.el);
                        t.length > 0 && (this.forms = Qp(t).map((function(t) {
                            return new Kp(t)
                        })))
                    }
                }, {
                    key: "sticky",
                    value: function() {
                        if (!uf) {
                            var t = m("[data-stick]");
                            t.length > 0 && (this.stickies = new Pc(t))
                        }
                    }
                }, {
                    key: "handlePricing",
                    value: function() {
                        var t = m(".js-pricing", this.el);
                        t.length > 0 && (this.pricing = Qp(t).map((function(t) {
                            return new wc(t)
                        })))
                    }
                }, {
                    key: "loaded",
                    value: function() {
                        this.onEnterCompleted(), new Ih, k.emit("loaded"), lf.initial = !0
                    }
                }, {
                    key: "setup",
                    value: function() {
                        this.initial()
                    }
                }]) && nf(e.prototype, n), i && nf(e, i), a
            }(l.Renderer);

        function ff(t) {
            return (ff = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function df(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }

        function mf(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function gf(t, e, n) {
            return (gf = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(t, e, n) {
                var i = function(t, e) {
                    for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = bf(t)););
                    return t
                }(t, e);
                if (i) {
                    var r = Object.getOwnPropertyDescriptor(i, e);
                    return r.get ? r.get.call(n) : r.value
                }
            })(t, e, n || t)
        }

        function vf(t, e) {
            return (vf = Object.setPrototypeOf || function(t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function yf(t) {
            var e = function() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
                } catch (t) {
                    return !1
                }
            }();
            return function() {
                var n, i = bf(t);
                if (e) {
                    var r = bf(this).constructor;
                    n = Reflect.construct(i, arguments, r)
                } else n = i.apply(this, arguments);
                return _f(this, n)
            }
        }

        function _f(t, e) {
            return !e || "object" !== ff(e) && "function" != typeof e ? xf(t) : e
        }

        function xf(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }

        function bf(t) {
            return (bf = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            })(t)
        }

        function Ef(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }
        var wf = f.bounds,
            Df = f.flags.isDevice,
            Sf = wf.hero,
            Mf = function(t) {
                ! function(t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            writable: !0,
                            configurable: !0
                        }
                    }), e && vf(t, e)
                }(a, t);
                var e, n, i, r = yf(a);

                function a() {
                    var t;
                    df(this, a);
                    for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
                    return Ef(xf(t = r.call.apply(r, [this].concat(n))), "setHeroBounds", (function() {
                        var e = wf.ww,
                            n = m(".js-hero-slide", t.el),
                            i = d(".js-hero", t.el);
                        n && (Sf.w = xh(n[n.length - 1]).right - e), i && (Sf.h = xh(i).height)
                    })), t
                }
                return e = a, (n = [{
                    key: "initial",
                    value: function() {
                        gf(bf(a.prototype), "initial", this).call(this), k.on("resize", this.setHeroBounds)
                    }
                }, {
                    key: "onEnter",
                    value: function() {
                        gf(bf(a.prototype), "onEnter", this).call(this), this.setHeroBounds(), this.initGl(), this.intro = new ip
                    }
                }, {
                    key: "onLeave",
                    value: function() {
                        gf(bf(a.prototype), "onLeave", this).call(this), this.stickies && this.stickies.destroy(), this.hiw && this.hiw.destroy(), this.pricing && this.pricing.destroy(), this.proof && this.proof.destroy()
                    }
                }, {
                    key: "onEnterCompleted",
                    value: function() {
                        gf(bf(a.prototype), "onEnterCompleted", this).call(this), !Df && (this.stickies = new Pc, this.hiw = new Zp), this.pricing = new wc, this.proof = new Gc
                    }
                }, {
                    key: "onLeaveCompleted",
                    value: function() {
                        gf(bf(a.prototype), "onLeaveCompleted", this).call(this), this.intro && this.intro.destroy(), _h.destroy()
                    }
                }, {
                    key: "initGl",
                    value: function() {
                        _h.init(this.el), pu.addPlanes({
                            el: this.el
                        })
                    }
                }]) && mf(e.prototype, n), i && mf(e, i), a
            }(pf);

        function Tf(t) {
            return (Tf = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function Af(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }

        function Cf(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function Pf(t, e) {
            return (Pf = Object.setPrototypeOf || function(t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function Ff(t) {
            var e = function() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
                } catch (t) {
                    return !1
                }
            }();
            return function() {
                var n, i = Rf(t);
                if (e) {
                    var r = Rf(this).constructor;
                    n = Reflect.construct(i, arguments, r)
                } else n = i.apply(this, arguments);
                return Lf(this, n)
            }
        }

        function Lf(t, e) {
            return !e || "object" !== Tf(e) && "function" != typeof e ? function(t) {
                if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t
            }(t) : e
        }

        function Rf(t) {
            return (Rf = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            })(t)
        }
        var If = function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Pf(t, e)
            }(a, t);
            var e, n, i, r = Ff(a);

            function a() {
                return Af(this, a), r.apply(this, arguments)
            }
            return e = a, (n = [{
                key: "in",
                value: function(t) {
                    var e = t.done;
                    k.emit("transition:in", {
                        done: e
                    })
                }
            }, {
                key: "out",
                value: function(t) {
                    var e = t.from,
                        n = t.done;
                    k.emit("transition:out", {
                        done: n,
                        from: e
                    })
                }
            }]) && Cf(e.prototype, n), i && Cf(e, i), a
        }(l.Transition);

        function kf(t) {
            return (kf = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function Of(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function Nf(t, e, n) {
            return (Nf = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(t, e, n) {
                var i = function(t, e) {
                    for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Uf(t)););
                    return t
                }(t, e);
                if (i) {
                    var r = Object.getOwnPropertyDescriptor(i, e);
                    return r.get ? r.get.call(n) : r.value
                }
            })(t, e, n || t)
        }

        function Bf(t, e) {
            return (Bf = Object.setPrototypeOf || function(t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function zf(t) {
            var e = function() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
                } catch (t) {
                    return !1
                }
            }();
            return function() {
                var n, i = Uf(t);
                if (e) {
                    var r = Uf(this).constructor;
                    n = Reflect.construct(i, arguments, r)
                } else n = i.apply(this, arguments);
                return Vf(this, n)
            }
        }

        function Vf(t, e) {
            return !e || "object" !== kf(e) && "function" != typeof e ? function(t) {
                if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t
            }(t) : e
        }

        function Uf(t) {
            return (Uf = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            })(t)
        }
        l.initial = !1;
        new(function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Bf(t, e)
            }(a, t);
            var e, n, i, r = zf(a);

            function a() {
                var t;
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, a), (t = r.call(this, {
                    renderers: {
                        home: Mf,
                        default: pf
                    },
                    transitions: {
                        default: If
                    }
                })).on("NAVIGATE_END", (function(t) {
                    var e = t.to,
                        n = t.location;
                    "undefined" != typeof gtag && gtag("config", "UA-71854614-3", {
                        page_path: n.pathname,
                        page_title: e.page.title,
                        page_location: n.href
                    })
                })), t
            }
            return e = a, (n = [{
                key: "navigate",
                value: function(t) {
                    f.dom.lastClicked = t.currentTarget, Nf(Uf(a.prototype), "navigate", this).call(this, t)
                }
            }]) && Of(e.prototype, n), i && Of(e, i), a
        }(l.Core));
        "scrollRestoration" in history && (history.scrollRestoration = "manual")
    })()
})();